
## java 21 features


보면 언어 자체의 업데이트된 내용들만 있는 것이 아니다.
	언어 자체만 두고 봤을때는 Record Pattern, Pattern Matching for switch Expressions and Statements 만 추가 되었다.

- Core Java Library
    
    - JEP 431: [Sequenced Collections](https://openjdk.org/jeps/431)
    - JEP 442: [Foreign Function & Memory API (Third Preview)](https://openjdk.org/jeps/442)
    - JEP 444: [Virtual Threads](https://openjdk.org/jeps/444)
    - JEP 446: [Scoped Values (Preview)](https://openjdk.org/jeps/446)
    - JEP 448: [Vector API (Sixth Incubator)](https://openjdk.org/jeps/448)
    - JEP 453: [Structured Concurrency (Preview)](https://openjdk.org/jeps/453)
    
- Java Language Specification
    
    - JEP 430: [String Templates (Preview)](https://openjdk.org/jeps/430)
    - JEP 440: [Record Patterns](https://openjdk.org/jeps/440)
    - JEP 441: [Pattern Matching for switch](https://openjdk.org/jeps/441)
    - JEP 443: [Unnamed Patterns and Variables (Preview)](https://openjdk.org/jeps/443)
    - JEP 445: [Unnamed Classes and Instance Main Methods (Preview)](https://openjdk.org/jeps/445)
    
- HotSpot
    
    - JEP 439: [Generational ZGC](https://openjdk.org/jeps/439)
    - JEP 449: [Deprecate the Windows 32-bit x86 Port for Removal](https://openjdk.org/jeps/449)
    - JEP 451: [Prepare to Disallow the Dynamic Loading of Agents](https://openjdk.org/jeps/451)
    
- Security Library
    
    - JEP 452: [Key Encapsulation Mechanism API](https://openjdk.org/jeps/452)

출처: [https://mangkyu.tistory.com/308](https://mangkyu.tistory.com/308) [MangKyu's Diary:티스토리]


### Sequenced Collections

기존 

```java
// List
list.get(0)
list.get(list.size() - 1)
```

처음과 마지막 요소에 대한 인터페이스 제공

![[Screenshot 2025-12-07 at 11.22.57 PM.png|700]]


기본 구조가 바뀌었다!


### Virtual Thread

```java
fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println("World!")
    }
    println("Hello")
}
```

이거 코틀린에서만 있었던 거라던데...


### Record Pattern

기존에 instanceof 로 패턴매칭을 할때

```java
if (staff[i] instanceof Manager) { 
	Manager boss = (Manager) staff[i]; 
	boss.setBonus(5000); 
}
```

여기서 Manager 를 3번이나 쓰는게 아까움

자바 16에서 제공하는 기능

```java
if (staff[i] instanceof Manager boss) { 
	boss.setBonus(5000); 
}
```

바로 조건문 안에서 선언해서 쓸 수 있게 해준다.

저 if 문 안에 다른 조건식도 바로 쓸 수 있음

```java
if (e instanceof Executive exec && exec.getTitle().getLength < 10) {
 ...
}
```

이게 가능한 이유는 오른쪽 식이 무조건 왼쪽 식이 true 일때만 조건을 따지기 때문임.
그래서 && 와는 다른 연산자 || 를 생각했을때

```java
if (e instanceof Executive exec || exec.getTitle().getLength < 10) ...
```

얘는 에러가 뜬다.
삼항 연산자도 에러가 뜸

그리고 java 16 에서 제공하는 이러한 기능을 'pattern matching' 이라고 함.

기존 레코드 클래스에 instance of 연산자를 적용하면 

```java
record Point(int x, int y) {}

static void printSum(Object obj) {
    if (obj instanceof Point p) {
        int x = p.x();
        int y = p.y();
        System.out.println(x+y);
    }
}
```

이런식으로 썼었는데, 자바 21 부터는

```java
static void printSum(Object obj) {
    if (obj instanceof Point(int x, int y)) {
        System.out.println(x+y);
    }
}
```


### Patter matching for switch

```java
// Prior to Java 21
static String formatter(Object obj) {
    String formatted = "unknown";
    if (obj instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (obj instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (obj instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (obj instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}

// As of Java 21
static String formatterPatternSwitch(Object obj) {
    return switch (obj) {
        case Integer i -> String.format("int %d", i);
        case Long l    -> String.format("long %d", l);
        case Double d  -> String.format("double %f", d);
        case String s  -> String.format("String %s", s);
        default        -> obj.toString();
    };
}
```


### null 검사

```java
// Prior to Java 21
static void testFooBarOld(String s) {
    if (s == null) {
        System.out.println("Oops!");
        return;
    }
    switch (s) {
        case "Foo", "Bar" -> System.out.println("Great");
        default           -> System.out.println("Ok");
    }
}

// As of Java 21
static void testFooBarNew(String s) {
    switch (s) {
        case null         -> System.out.println("Oops");
        case "Foo", "Bar" -> System.out.println("Great");
        default           -> System.out.println("Ok");
    }
}
```


### case 세분화

```java
// Prior to Java 21
static void testStringOld(String response) {
    switch (response) {
        case null -> { }
        case String s -> {
            if (s.equalsIgnoreCase("YES"))
                System.out.println("You got it");
            else if (s.equalsIgnoreCase("NO"))
                System.out.println("Shame");
            else
                System.out.println("Sorry?");
        }
    }
}

// As of Java 21
static void testStringNew(String response) {
    switch (response) {
        case null -> { }
        case String s
        when s.equalsIgnoreCase("YES") -> {
            System.out.println("You got it");
        }
        case String s
        when s.equalsIgnoreCase("NO") -> {
            System.out.println("Shame");
        }
        case String s -> {
            System.out.println("Sorry?");
        }
    }
}
```


### enum 개선

```java
// Prior to Java 21
public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }

static void testforHearts(Suit s) {
    switch (s) {
        case HEARTS -> System.out.println("It's a heart!");
        default -> System.out.println("Some other suit");
    }
} // switch 문에서 제한적인 enum 사용


// Prior to Java 21
sealed interface CardClassification permits Suit, Tarot {}
public enum Suit implements CardClassification { CLUBS, DIAMONDS, HEARTS, SPADES }
final class Tarot implements CardClassification {}

static void exhaustiveSwitchWithoutEnumSupport(CardClassification c) {
    switch (c) {
        case Suit s when s == Suit.CLUBS -> {
            System.out.println("It's clubs");
        }
        case Suit s when s == Suit.DIAMONDS -> {
            System.out.println("It's diamonds");
        }
        case Suit s when s == Suit.HEARTS -> {
            System.out.println("It's hearts");
        }
        case Suit s -> {
            System.out.println("It's spades");
        }
        case Tarot t -> {
            System.out.println("It's a tarot");
        }
    }
}

// As of Java 21
static void exhaustiveSwitchWithBetterEnumSupport(CardClassification c) {
    switch (c) {
        case Suit.CLUBS -> {
            System.out.println("It's clubs");
        }
        case Suit.DIAMONDS -> {
            System.out.println("It's diamonds");
        }
        case Suit.HEARTS -> {
            System.out.println("It's hearts");
        }
        case Suit.SPADES -> {
            System.out.println("It's spades");
        }
        case Tarot t -> {
            System.out.println("It's a tarot");
        }
    }
}
```


#### enum 이 implement 도 가능했었나 ...?

원래 가능했었다

```java
// 1. Interface 정의  
public interface Operation {  
    double apply(double x, double y);  
}  
  
// 2. BasicOperation enum 구현  
public enum BasicOperation implements Operation {  
    PLUS("+") {  
       public double apply(double x, double y) { return x + y; }  
    },  
    MINUS("-") {  
       public double apply(double x, double y) { return x - y; }  
    },  
    TIMES("*") {  
       public double apply(double x, double y) { return x * y; }  
    },  
    DIVIDE("/") {  
       public double apply(double x, double y) { return x / y; }  
    };  
  
    private final String symbol;  
  
    BasicOperation(String symbol) {  
       this.symbol = symbol;  
    }  
  
    @Override  
    public String toString() {  
       return symbol;  
    }  
}  
  
public static void main(String[] args) {  
    double x = 4.0;  
    double y = 2.0;  
  
    for (BasicOperation op : BasicOperation.values()) {  
       System.out.printf("%f %s %f : %f\n", x, op, y, op.apply(x, y));  
    }  
}
```

enum 은 특별한 종류의 class -> class can implement interface

대신 enum 은 이미 Enum\<E> 를 상속받고 있기떄문에 다른 클래스를 extends 할 수 없따

- 여기서 "+" 를 저기에 넣는 이유
-> enum 의 constructor. 

`("+")` 같은 constructor parameter는 각 enum constant에 연관된 데이터를 저장하는 필드(field)입니다. 이를 통해 `toString()`으로 "PLUS" 대신 "+"를 출력할 수 있습니다.​

저기서 
```java
PLUS("+") {  
       public double apply(double x, double y) { return x + y; }  
    },  
```
안에 apply 메서드 지워버리면 apply 구현하라고 에러뜸




#### sealed interface  ??

java 17 에서 나온 개념이다.


```java
// 
sealed interface CardClassification permits Suit, Tarot {}

public enum Suit implements CardClassification { CLUBS, DIAMONDS, HEARTS, SPADES }
final class Tarot implements CardClassification {}

static void exhaustiveSwitchWithoutEnumSupport(CardClassification c) {
    switch (c) {
        case Suit s when s == Suit.CLUBS -> {
            System.out.println("It's clubs");
        }
        case Suit s when s == Suit.DIAMONDS -> {
            System.out.println("It's diamonds");
        }
        case Suit s when s == Suit.HEARTS -> {
            System.out.println("It's hearts");
        }
        case Suit s -> {
            System.out.println("It's spades");
        }
        case Tarot t -> {
            System.out.println("It's a tarot");
        }
    }
}
```



### Generational ZGC

ZGC는 짧은 지연 시간과 높은 확정성을 위해 고안된 GC 알고리즘으로 Java 15부터 프로덕션 환경에서 사용할 수 있게 되었다. [약한 세대 가설(Weak Generational Hypothesis)](https://mangkyu.tistory.com/118)을 따라 대부분의 객체는 금방 죽기 때문에, 금방 죽는 Young 영역과 오래 살아남는 Old 영역을 분리하여 관리하는 것이 좋다. 그래서 Java 21에서는 이러한 방식을 통해 ZGC의 기능을 확장하여 성능을 개선시키고자 하였다. ZGC와 관련된 자세한 내용은 추후의 별도 포스팅을 통해 살펴볼 예정이다.

출처: [https://mangkyu.tistory.com/308](https://mangkyu.tistory.com/308) [MangKyu's Diary:티스토리]


### Key Encapsulation Mechanism API

Java21에는 공개 키 암호화를 사용하여 대칭 키를 보호하는 암호화 기술인 KEM(Key Encapsulation Mechanism) API가 도입되었다. 기존의 기술은 무작위로 생성된 대칭 키를 공개 키로 암호화하는 것이지만, 패딩이 필요하고 보안을 증명하기 어려울 수 있다. 대신 KEM은 공개 키의 속성을 사용하여 패딩이 필요 없는 관련 대칭 키를 도출한다.

KEM은 양자 공격을 방어하기 위한 핵심 도구가 될 것이다. 다른 보안 제공업체들은 이미 표준 KEM API에 대한 필요성을 표명했고, 자바 역시 이를 공식적으로 도입하기로 결정하였다.

출처: [https://mangkyu.tistory.com/308](https://mangkyu.tistory.com/308) [MangKyu's Diary:티스토리]


```java
package javax.crypto;

public class DecapsulateException extends GeneralSecurityException;

public final class KEM {

    public static KEM getInstance(String alg)
        throws NoSuchAlgorithmException;
    public static KEM getInstance(String alg, Provider p)
        throws NoSuchAlgorithmException;
    public static KEM getInstance(String alg, String p)
        throws NoSuchAlgorithmException, NoSuchProviderException;

    public static final class Encapsulated {
        public Encapsulated(SecretKey key, byte[] encapsulation, byte[] params);
        public SecretKey key();
        public byte[] encapsulation();
        public byte[] params();
    }

    public static final class Encapsulator {
        String providerName();
        int secretSize();           // Size of the shared secret
        int encapsulationSize();    // Size of the key encapsulation message
        Encapsulated encapsulate();
        Encapsulated encapsulate(int from, int to, String algorithm);
    }

    public Encapsulator newEncapsulator(PublicKey pk)
            throws InvalidKeyException;
    public Encapsulator newEncapsulator(PublicKey pk, SecureRandom sr)
            throws InvalidKeyException;
    public Encapsulator newEncapsulator(PublicKey pk, AlgorithmParameterSpec spec,
                                        SecureRandom sr)
            throws InvalidAlgorithmParameterException, InvalidKeyException;

    public static final class Decapsulator {
        String providerName();
        int secretSize();           // Size of the shared secret
        int encapsulationSize();    // Size of the key encapsulation message
        SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException;
        SecretKey decapsulate(byte[] encapsulation, int from, int to,
                              String algorithm)
                throws DecapsulateException;
    }

    public Decapsulator newDecapsulator(PrivateKey sk)
            throws InvalidKeyException;
    public Decapsulator newDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)
            throws InvalidAlgorithmParameterException, InvalidKeyException;

}

출처: [https://mangkyu.tistory.com/308](https://mangkyu.tistory.com/308) [MangKyu's Diary:티스토리]
```