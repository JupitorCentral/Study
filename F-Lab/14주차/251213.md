## shared lock

어떤 트랜잭션이 특정 데이터에 대해 shared lock 을 얻으면, 
그 락이 유지되는 동안 다른 트랜잭션이 해당 데이터에 대해 shared lock 을 또 취득할 수 있으며
이 shared lock 을 얻으면 해당 데이터를 읽을 순 있으나 쓸 수 는 없음

그리고 이 shared lock 이 걸려있으면 exclusive lock 을 설정할 수 없음

## exclusive lock

어떤 트랜잭션이 어떤 데이터에 대해 exclusive lock 을 설정하면, 그 데이터에 대해 읽거나 쓸 수 있는데
그 락이 유지되는 동안 다른 트랜잭션은 해당 데이터에 대해 shared lock, exclusive lock 을 얻을 수 없음.
즉, 읽거나 쓸 수 없음

## intension lock

하나의 트랜잭션이 특정한 테이블 또는 페이지에 락을 걸려고 할때, 락의 충돌이 있는지 없는지
모든 레코드를 살펴보는 것은 매우 비효율적인 일이다. 

어떤 테이블의 레코드 중 하나라도 다른 트랜잭션이 exclusive lock 을 걸어버리면, 해당 테이블 전체에 대해 exclusive lock, intension lock 을 설정할 수 없기 때문이다.

이런 사태를 방지하고자 트랜잭션이 락을 걸때 상위 단위 (페이지, 테이블 등에) 에 내가 락을 걸겠다고 알려주는 것이 바로 인텐션 락이다.

인텐션 락때문에 페이지나 테이블에 락을 걸려고 할떄마다
이 인텐션락의 존재유무로 락을 걸지 안걸지를 바로 판단할 수 있음.

## AOP

### Crosscutting concern

공통 관심사. 여러 곳의 코드 부분에 중복되는 동작, 코드. 
동일한 코드가 여러 곳에 흩어져있으면 중복이고 곧 관리가 힘드며 불필요한데, 이를 객체지향으로 커버하기가 힘들다.

### Advice

공통 관심사의 동작 그 자체, 실행하고자 하는 코드.
여러 개의 종류가 있는데

Before, After, After returnning, After throwing 등이 그 것이다.

Spring AOP 에서는
Before, After-Returning (method 실행이 끝난 후 리턴하고 나서), After (메서의 실행결과가 어떻든간에 메서드가 종료되는 시점에),
Around (메서드 실행 전과 후), Throws (메서드에서 Exception 이 터질때), introduction (메서드의 구현을 변경할 수 있음)
등이 있다

Spring AOP 는 AOP Alliance 표준 인터페이스를 사용하기때문에,
Spring AOP 를 위해 만들어진 advice 코드는 다른 구현체에서도 사용이 가능함.

### Joinpoint

Advice 를 적용할 수 있는 후보. 
일반적인 AOP 에서는 method call, method execution, constructor call, field access 등 다양한 지점이 있으나
Spring AOP 에서는 method execution 만 있다.

method call 은 메서드를 호출하는 쪽에서 일어나는 시점이고,
method execution 은 호출되는 메서드에서의 시점이다.

### PointCut

Joinpoint 중에서 실제로 적용할 부분을 정하는 식을 얘기한다.
예를 들면 bread이라는 이름을 가진 메서드를 모두 가리킨다던지,
아니면 특정 패키지 안에 있는 모든 메서드를 가리킨다던지.

### Aspect

advice 와 pointcut 을 하나로 뭉친 모듈이다.

### Weaving

실제 어플리케이션에 짠 AOP 코드를 주입하는 과정.

compile-time weaving 과 runtime weaving 이 있고
AspectJ 는 compile time, Spring AOP 는 runtime 을 제공
이중 AspectJ 는 load-time weaving , 즉 클래스 로더가 클래스를 로딩할때 바이트코드에 aspect 를 삽입하는 기능도 가지고 있다.


### Target Object

aspect 가 적용되는 대상 객체.
인스턴스이다.

### Proxy

JDK Dynamic Proxy
런타임 시간에 해당 클래스를 감싸는 대신하는 객체를 사용함.

CGLIB Proxy
해당 클래스를 상속받는 클래스를 생성하여 동작함

### Introduction

기존 클래스에 메소드나 필드를 동적으로 추가하는 것.

예를 들어 어떤 클래스가 정의될때 Comparable 인터페이스를 구현하지 않는데
런타임 중에 compareTo 구현하게 만들 수 있음.


### Static AOP vs Dynamic AOP

#### static aop

compile time, load-time 에 바이트코드 수정
런타임 성능이 좋음
aspect 변경시 재 컴파일이 필요함
-> AspectJ
#### dynamic aop
런타임에 proxy 객체를 생성해서 advice 를 적용
aspect 변경이 쉽고 재 컴파일이 불필요함
런타임 오버해드 존재 (그러나 점점 개선되는중)
-> Spring AOP

### AOP 의 흐름 

1. crosscutting concern이 있다 (예: 로깅)
    
2. 이걸 advice로 구현한다 (로그 남기는 코드)
    
3. joinpoint는 advice를 끼워 넣을 수 있는 모든 지점이다
    
4. pointcut으로 그중 일부 joinpoint를 선택한다
    
5. advice + pointcut = aspect (모듈화된 관심사)
    
6. weaving으로 aspect를 실제 코드에 엮는다
    
7. target object에 aspect가 적용되어 실행된다

