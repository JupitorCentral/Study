
## Java 에서 라이브러리와 API

API 는 interface, 라이브러리는 구현체

API 는 어떠한 대상에 대한 인터페이스와 명세를 의미하고,
라이브러리는 그 API 의 실제 구현체 - implementation 이다.

API -> List, Set ...
Library -> ArrayList, HashSet ...

표준 라이브러리는 JDK 에 들어간다.

java 의 표준 라이브러리는 크게

- **java.lang**: String, Object, System 등 (import 없이 사용)
    
- **java.util**: Collection Framework, Date, Random 등
    
- **java.io**: 파일 입출력 관련
    
- **java.net**: 네트워크 관련


그리고 java 21 이전에 preview 로 소개되었던 virtual thread 가 java21 에는 
정식으로 java.lang, java.util.concurrent 에 추가되었다. (표준 라이브러리에 포함됨)

자바에는 버전마다 Permanent Features, Preview Features 가 있다.

## Java 21 language updates


https://docs.oracle.com/en/java/javase/21/language/java-language-changes-summary.html#GUID-E69EEA63-E204-41B4-AA7F-D58B26A3B232

Java 21 에는 Record Patterns,  Pattern Matching for switch Expressions and Statements 가 추가되었다.

record pattern 을 설명하기 위해선 Pattern Matching 내용부터 알고 들어가야 한다

### Pattern Matching

#### Pattern Matching for the instanceOf Operator (java 16)

```java
public interface Shape {
    public static double getPerimeter(Shape s) throws IllegalArgumentException {
        if (s instanceof Rectangle) {
            Rectangle r = (Rectangle) s;
            return 2 * r.length() + 2 * r.width();
        } else if (s instanceof Circle) {
            Circle c = (Circle) s;
            return 2 * c.radius() * Math.PI;
        } else {
            throw new IllegalArgumentException("Unrecognized shape");
        }
    }
}

public class Rectangle implements Shape {
    final double length;
    final double width;    
    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }    
    double length() { return length; }
    double width() { return width; }
}

public class Circle implements Shape {
    final double radius;
    public Circle(double radius) {
        this.radius = radius;
    }  
    double radius() { return radius; }
}
```

pattern matching 은 'Conversion' 을 생략할 수 있게 만들어준다.

```java
    public static double getPerimeter(Shape shape) throws IllegalArgumentException {
        if (s instanceof Rectangle r) {     // -> Pattern
            return 2 * r.length() + 2 * r.width();
        } else if (s instanceof Circle c) {   // -> Pattern
            return 2 * c.radius() * Math.PI;
        } else {
            throw new IllegalArgumentException("Unrecognized shape");
        }
    }
```

"Pattern" 이라 함은 'a predicate'  라고 불리는 test 와, 'target' 과
pattern variables 라고 불리는 지역 변수들의 set 과의 조합이다 (test + target + set -> Pattern)

- predicate 
Booolean-valued function with 'one' argument. 하나의 입력값을 갖는 부울값을 리턴하는 함수.

- target
위의 predicate 의 입력값

- pattern variables
predicate 가 true을 반환할때만 값을 저장하는 변수. 위 예시에서는 r 또는 c 가 된다.

pattern variables 는 pattern variables 가 선언되는 곳의 prediacate 가 true 일때만 접근이 가능하고,
이 변수의 scope 는 이 변수가 선언된 곳을 벗어날 수가 있다.

```java
    public static boolean bigEnoughRect(Shape s) {
        if (!(s instanceof Rectangle r)) {
            // You cannot use the pattern variable r here because
            // the predicate s instanceof Rectangle is false.
            return false;
        }
        // You can use r here.
        return r.length() > 5; 
    }
```

그리고 pattern variable 을 선언된 곳에서 재 사용할 수 있다. 이런식으로

```java
        if (shape instanceof Rectangle r && r.length() > 5) {
            // ...
        }
```

conditional-AND operator (&& 연산자)는 short-circuiting 이므로, 우측 predicate 를 접근할 수 있음

- short-circuiting 
연산자의 우측의 predicate 가 false 면 우측 predicate 를 접근하지 않는다는 의미.
즉, 위에서 short-circuiting 이 아니면 왼쪽이 false 여도 우측 pridicate `r.length() > 5` 에 접근한다는 얘기고,
이는 위의 조건을 위반하게 됨.

위 자리에 && 대신 || 쓰면 당연히 에러가 남.

#### Pattern Matching for switch Expressions and Statements (java 21)

이전에는 switch 문의 분기 조건에 해당하는 값(case label)이 반드시 상수여야 했고,
number, String, enum 셋 중에 하나이어야 했다.

```java
switch (number) {
    case 1:  // 여기서 '1'이 Case Label 입니다.
        break;
    case (10): // 괄호를 써도 되지만, 보통은 안 씁니다. 여기서 '(10)'이 Label 역할을 합니다.
        break;
}
```

하지만 이번 부터는 selector expression 이
어떤 reference Type (Integer, Boolean 심지어 custom defined class 까지) 이어도 되고 int 타입 변수여도 됨 (long, float, double, boolean 은 안됨)
그리고 case label 이 pattern 을 가질 수 있게 됨.

결론적으로, switch 문이 그 스위치문의 selector expression 이 pattern과 일치하는지 테스트할 수 있게 됨.


위의 instanceOf operator 에 관한 예시에서

```java
interface Shape { }
record Rectangle(double length, double width) implements Shape { }
record Circle(double radius) implements Shape { }
...
    public static double getPerimeter(Shape s) throws IllegalArgumentException {
        if (s instanceof Rectangle r) {
            return 2 * r.length() + 2 * r.width();
        } else if (s instanceof Circle c) {
            return 2 * c.radius() * Math.PI;
        } else {
            throw new IllegalArgumentException("Unrecognized shape");
        }
    }
```

```java
    public static double getPerimeter(Shape s) throws IllegalArgumentException {
        return switch (s) {
            case Rectangle r -> 2 * r.length() + 2 * r.width();
            case Circle c    -> 2 * c.radius() * Math.PI;
            default          -> throw new IllegalArgumentException("Unrecognized shape");
        };
    }
```

이런식으로 쓸 수 있다.

```java
    public static double getPerimeter(Shape s) throws IllegalArgumentException {
        switch (s) {
            case Rectangle r: return 2 * r.length() + 2 * r.width();
            case Circle c:    return 2 * c.radius() * Math.PI;
            default:          throw new IllegalArgumentException("Unrecognized shape");
        }
    }
```

이건 switch expression 대신에 switch statement 를 사용한 예시.

(switch expression  은 switch 문의 결과값을 리턴하는거고,
switch statement 는 switch 문 안에 리턴이 있다)



아 왤케 존나 하기 싫지



#### Record Patterns




## Record Class - Java 16




## Java 21 Feature


Core Java Library
    
- JEP 431: [Sequenced Collections](https://openjdk.org/jeps/431)
- JEP 442: [Foreign Function & Memory API (Third Preview)](https://openjdk.org/jeps/442)
- JEP 444: [Virtual Threads](https://openjdk.org/jeps/444)
- JEP 446: [Scoped Values (Preview)](https://openjdk.org/jeps/446)
- JEP 448: [Vector API (Sixth Incubator)](https://openjdk.org/jeps/448)
- JEP 453: [Structured Concurrency (Preview)](https://openjdk.org/jeps/453)

 HotSpot

- JEP 439: [Generational ZGC](https://openjdk.org/jeps/439)
- JEP 449: [Deprecate the Windows 32-bit x86 Port for Removal](https://openjdk.org/jeps/449)
- JEP 451: [Prepare to Disallow the Dynamic Loading of Agents](https://openjdk.org/jeps/451)




## intelliJ 2025.3


## 주요 변경 사항 및 UI/UX

- **단일 배포판 (Unified Distribution):** 기존의 커뮤니티(Community)와 얼티밋(Ultimate) 에디션이 하나의 설치 파일로 통합되었습니다. 라이선스 유무에 따라 기능이 활성화되며, 무료 버전에서도 Spring 프로젝트 생성 마법사와 같은 일부 기능이 제공됩니다.​
    
- **Islands 테마:** IDE의 각 영역(프로젝트 창, 에디터 등)을 시각적으로 명확하게 구분해주는 새로운 테마가 기본값으로 적용되었습니다.​
    
- **명령어 자동완성 (Command Completion):** `..` (점 두 개)를 입력하면 현재 문맥에서 사용할 수 있는 리팩토링, 코드 수정, 변수 생성 등의 명령어를 추천해 줍니다. 복잡한 단축키를 암기할 필요 없이 직관적인 코드 조작이 가능합니다.​
    

## Spring Boot 및 프레임워크 지원

Spring Boot 4와 Spring Framework 7에 대한 지원이 대폭 강화되었습니다.

- **API 버저닝 (API Versioning):** `@Controller`에서 헤더나 경로 기반의 API 버전 관리를 할 때 IDE가 이를 인식하고 설정을 도와줍니다. 관련 설정으로 바로 이동하거나 테스트 코드(MockMVC) 작성 시 버전을 누락하면 경고를 표시합니다.​
    
- **HTTP 서비스 클라이언트:** HTTP 인터페이스 클라이언트 정의 시 필요한 보일러플레이트 코드를 줄여주며, 빈(Bean)으로 인식하여 자동 주입 및 메서드 호출을 지원합니다.​
    
- **Spring Data JDBC:**
    
    - **Reverse Engineering:** DB 테이블을 기반으로 엔티티 클래스를 자동 생성하거나, 반대로 엔티티를 기반으로 Flyway 마이그레이션 스크립트를 생성하는 양방향 엔지니어링을 지원합니다.​
        
    - **변경 사항 동기화:** DB에 컬럼이 추가되면 엔티티에 해당 필드를 추가하도록 돕고, 엔티티가 변경되면 마이그레이션 스크립트를 생성해 주는 등 'DB First'와 'Model First' 접근 방식을 모두 지원합니다.​
        
- **Spring Data Repositories AOT 지원:** 런타임에 프록시로 생성되어 디버깅이 어려웠던 리포지토리 메서드(예: `findByISBN`)를 AOT(Ahead-of-Time) 처리를 통해 실제 구현체 코드를 생성하여 디버깅할 수 있게 되었습니다.​
    

## Java 및 AI 기능

- **Java 25 & 26 지원:** Java 25 기능 지원 및 Java 26의 Value Classes(값 객체)와 같은 초기 접근(Early Access) 기능을 사용할 수 있습니다.​
    
- **AI Assistant:**
    
    - **Next Edit Suggestion:** 커서 위치뿐만 아니라 코드의 다른 부분에서 수정이 필요할 것으로 예측되는 지점을 제안합니다.​
        
    - **Claude Agent 통합:** Anthropic의 Claude 모델을 활용한 에이전트 기능이 통합되었으며, 터미널 명령어를 실행하거나 프로젝트를 분석하는 등의 작업이 가능합니다.​
        

## 빌드 도구 (Develocity)

Gradle 빌드(Maven은 추후 지원 예정)에 대해 로컬 환경에서 빌드 성능을 프로파일링할 수 있는 플러그인이 추가되었습니다. 모듈별 빌드 타임라인과 병렬 처리 현황을 시각적으로 확인할 수 있어 빌드 최적화에 유용합니다