
## @TestInstance

JUnit 4, JUnit 5 에서는 각 테스트 메서드를 시행할때마다 해당 메서드가 속한 클래스의 인스턴스를 생성한다.
JUint 5에서는 @TestIntance 를 이용해서 이 테스트 클래스의 인스턴스의 life cycle 을 설정할 수 있게 해준다.

### Default Test LifeCycle

```java
class AdditionTest {

    private int sum = 1;

    @Test
    void addingTwoReturnsThree() {
        sum += 2;
        assertEquals(3, sum);
    }

    @Test
    void addingThreeReturnsFour() {
        sum += 3;
        assertEquals(4, sum);
    }
}
```

기본적으로 각 테스트 메서드가 실행될떄마다 AdditionTest 의 인스턴스가 실행된다.

### @BeforeClass, @BeforeAll

```java
private static String largeContent;

@BeforeClass
public static void setUpFixture() {
    // read the file and store in 'largeContent'
}
```

큰 크기의 테스트파일을 읽어서 테스트를 해야할 경우에는 각 테스트 메서드가 실행될때마다 그걸 불러오는 것보다는
한번에 읽어들이고 그걸 전체 테스트동안 유지하는것이 유리하다.

그래서 @BeforeClass 를 쓸 수 있는데,
이때 이 어노테이션을 적용하는 메서드는 static 으로 선언되어야 한다.

그런데 @BeforeAll 을
instance method (not static method) , instance member 에 쓸 수 있는데,
이 테스트 클래스의 인스턴스의 life cycle 이 per-class 로 바뀌면 가능하다.



### @TestInstance

@TestInstance 어노테이션은 Junit 5 테스트의 life cycle 을 변경할 수 있다.
두가지 모드가 있는데, 하나는 LifeCycle.PER_METHOD - 이게 기본값이고
다른건 Lifecycle.PER_CLASS 가 있다.

Per_CLASS 설정값을 쓰면 테스트 메서드 때마다 테스트 클래스 인스턴스가 생성되는것이 아니라
테스트 클래스의 인스턴스가 하나만 생성되어 테스트 메서드가 실행되어도 클래스에 속해있는 어떤 값이나 상태를 유지할 수 있다.


```java
@TestInstance(Lifecycle.PER_CLASS)
class TweetSerializerUnitTest {

    private String largeContent;

    @BeforeAll
    void setUpFixture() {
        // read the file
    }
}
```

largeContent, setUpFixture 모두 instance member, instance method 인데
@TestInstance 를 통해 PER_CLASS 로 lfecycle 을 변경하면서 사용할 수 있게 된 것
이러면 largeContent는 TweetSerializerUnitTest 테스트 메서드 전반에서 쓸 수 있게 된다



## Use, manage, and build secure and scalable databases with PostgreSQL 16 Chapter 11 

transaction 의 boundaries 를 DBMS 가 자동으로 설정하는 것이 아니라 내가 직접 설정할 수도 있다.

- implicit transaction : db 가 나한테 물어보지 않고 시작하는 transaction
- explicit transaction : 내가 db 한테 시작하라고 요청하는 transaction

어떤 트랜잭션이든 id 를 가지고 있다. (Transaction identifier, xid)
dbms 은 inplicit 든 explicit 든 알아서 값을 설정해줌.

- tuple : table 의 하나의 row, 레코드를 의미한다
각 tuple 에는 헤더가 있다.
그리고 postgresql 은 그 튜플을 생성하거나 수정한 xid 를 그 튜플의 헤더에 저장해둔다.

`txid_current()` 현재 트랜잭션이 뭔지 알려주는 function (by means of : ~ 을 통해서. ~ 라는 수단으로)

![[Screenshot 2025-12-14 at 7.34.16 PM.png|500]]

그리고 select 에 숨겨진 값 xmin 까지 조회하면, 어떤 xid 가 튜플을 만들었는지 알 수 있다.

xmin, xmax, ctid 등 모든 테이블마다 숨겨진 컬럼이 존재함. -> tuple header 라고 불림
그래서 어떤 테이블이든간에 해당 컬럼을 select 할 수 있음.

- xmin : row 를 insert 한 xid
- xmax : row 를 삭제하거나 lock 을 건 xid (delete, lock 을 invalidate 한다. 라고 책에서는 표현한다.)
- cmin : row 를 insert 한 command id
- xmax : row 를 삭제하거나 lock 을 건 command id

- command id ?
postgresql 에서는 하나의 transaction 안에서 실행되는 모든 statement 마다 0 부터 시작해서 번호를 부여한다.


### implicit, explicit transaction 의 비교

postgresql 에서 implcit transaction 을 생성하는 기준은 간단함 : 모든 하나의 statement 는 그 스스로의 transacton boundary 를 갖는다.
(즉 statement 하나당 트랜잭션 하나 생긴다는 얘기)



`The fact that you see instances of xid incremented by a single unit is because, on the machine used for the examples, there is no concurrency, that is, no other database activity is going on.`

-> the fact that you see -> 너가 \~~를 보게 되는 사실은 (뒤에 나오는 내용을 한 덩어리로 묶어서 “그 사실”이라고 부르는 구조)
-> instances of xid : xid 의 여러 경우들 -> 여러 값들
-> incremented by a single unit -> xid 값이 1씩만 증가하는
-> is because -> ~ 때문이다
-> on the machine used for the examples, -> 예제를 실행한 기계에서는,
-> there is no concurrency -> 동시성이 없어서 (동시에 돌아가는 트랜잭션이 없어서)
-> that is, no other database activity is going on -> 즉, 다른 db 작업이 돌아가고 있지 않아서 이다.

`However, you cannot make any predictions about what the next xid will be in a live system, with different concurrent connections and running statements.

-> 그러나, 여러개의 db 연결과 statement 가 실행되는 production 환경에서는 (live system), 다음 xid 가 무엇일지 예측할 수가 없음

`What if we had inserted all the preceding tags in one shot, being sure that if only one of them could not be stored for any reason, all of them would disappear?`

-> 만약 우리가 앞전에 나왔던 모든 tag (예시에 나온 컬럼값들) 을 한방에 넣는다면
-> being sure that -> ~을 확실히 하면서, ~을 보장한 채로

if only one of them -> 그것들 중 단 하나라도
어떤 이유이든간에 저장되지 않게 된다면 
모든 것들이 사라진다면 (모든 것들이 사라진다는 것을 보장한채로)

- what if (주어) had p.p
-> 만약 ~~ 했었다면 ? 과거에 \~~했다면 어땠을까?

-> 만약 하나라도 실패하면 모든 것들이 사라지는 것을 확실하게 한 채로 앞전의 모든 태그들을 한번에 insert 했었었다면 어떠하였겠느냐?
-> 이럴땐 explicit transaction 을 사용할 수 있음


`An explicit transaction is a group of statements with a well-established transaction boundary`
-> well-established : 명확하게 정해진, 분명하게 설정된

`BEGIN` 을 사용해서 transaction 시작
`COMMIT`, `ROLLBACK` 등을 이용해 transaction 을 끝냄

The only way you have to clear the situation is by ending the explicit transaction, and no matter which way you end it (either COMMIT or ROLLBACK), PostgreSQL will throw away your changes, rolling back the current transaction.

The only way you have 랑 to clear the situation 을 따로 생각하면 된다.
너가 상황을 정리할 유일한 방법은 explicit transaction을 끝내는 것이고
그리고 나면 너가 어떻게 transaction 을 끝냈던 간에 postgresql 은 당신이 만들어낸 변화들을 다 날려버리고 현재 transaction 을 되돌릴 것이다.


그리고 이는 implicit transaction 도 마찬가지임.


#### PostgreSQL 에서 transaction 이 abort 되는 경우

![[Screenshot 2025-12-14 at 8.56.40 PM.png|600]]

Explicit transaction을 하는 와중에 실행문 하나가 에러가 나면
그 이후에 해당 트랜잭션에 어떤 실행문을 넣어도 실행되지 않고,
이 상황은 commit 또는 rollback 를 타이핑해서 해당 트랜잭션을 끝내야만 상황을 정리할 수가 있으며,
이 상태는 이미 transaction 이 abort 된 상황이기 때문에
내가 이전에 실행했던 어떤 변화든 간에 postgresql 이 다 날려버린다.

implicit transaction 도 마찬가지임.

(save point 를 사용한다면 돌아가는 메커니즘이 좀 달라진다.)



