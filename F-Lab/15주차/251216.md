## @SpringBootTest vs @WebMvcTest

그렇다면 나의 @Controller 를 TDD 로 개발하기 위해 어떤 어노테이션을 써야 할까?

-> 컨트롤러 단위 테스트 (Unit Test) 를 짤때는 @WebMvcTest 를 쓰는게 정석이다.

### 1. @SpringBootTest: "무거운 통합 테스트"

`@SpringBootTest`는 **애플리케이션 컨텍스트(Application Context)를 통째로 띄운다

- **동작 방식:** 실제 서버를 띄우는 것과 거의 똑같이 모든 빈(Bean)을 다 생성하고 등록한다. (`Controller`, `Service`, `Repository`, `Component` 등등 싹 다)
- **장점:** 실제 환경과 가장 유사하게 테스트할 수 있. (통합 테스트 용도)
    
- **단점 (치명적):**
    1. **너무 느립니다.** 테스트 하나 돌릴 때마다 스프링이 다 뜨느라 세월아 네월아 걸립니다. 
       TDD는 "작성 -> 실행 -> 수정" 사이클이 빨라야 하는데, 이게 느리면 TDD 못 합니다.
        
    2. **단위 테스트가 아닙니다.** 우리는 지금 "컨트롤러의 로직"만 검증하고 싶은데, DB 연결하고 외부 API 찌르고... 불필요한 작업이 다 포함됩니다.
        

### 2. @WebMvcTest: "가벼운 컨트롤러 전용 테스트"

반면에 `@WebMvcTest`는 **오직 웹 계층(Web Layer)과 관련된 빈만 골라서 띄웁니다.**

- **동작 방식:** `@Controller`, `@RestController`, `@ControllerAdvice` 등 웹 관련 빈만 생성합니다. **`@Service`, `@Repository` 같은 비즈니스 로직 빈들은 생성하지 않습니다.**
    
- **장점:**
    1. **엄청 빠릅니다.** 필요한 것만 띄우니까요.
    2. **컨트롤러에만 집중할 수 있습니다.**
    3. 
- **그럼 Service는요?:** 바로 여기서 아까 배운 **`@MockBean`** (Mockito)이 등장합니다! 실제 `Service` 빈 대신 가짜(Mock)를 채워 넣어서 컨트롤러가 동작하게 만듭니다.


| 특징          | @SpringBootTest     | @WebMvcTest               |
| ----------- | ------------------- | ------------------------- |
| **목적**      | 통합 테스트 (E2E, 전체 흐름) | **단위 테스트 (컨트롤러 로직 검증)**   |
| **로딩 범위**   | 모든 Bean (무거움)       | **Web Layer Bean만 (가벼움)** |
| **속도**      | 느림                  | **빠름**                    |
| **의존성 처리**  | 실제 Bean 주입 (주로)     | **`@MockBean`으로 가짜 주입**   |
| **TDD 적합성** | 낮음 (느려서)            | **높음**                    |


## Concurrency Control in PostgreSQL - MVCC, S2PL, OCC (2)



### Inserting, Deleting and Updating Tuples

https://www.interdb.jp/pg/pgsql05/03.html


![[Screenshot 2025-12-15 at 3.40.35 AM.png|700]]


#### Insertion

![[Screenshot 2025-12-15 at 3.40.56 AM.png|700]]

데이터를 insert 할때, 대상이 되는 테이블의 페이지에 바로 새로운 tuple 이 생성된다.
txid 가 99인 트랜잭션에 의해 해당 tuple 이 insert (생성) 된다고 했을때
해당 tuple 의 헤더는 위와같이 생성된다.

t_xmin 에는 해당 튜플을 생성한 transaction 의 id가, 
t_max 에는 0 이 (아직 튜플이 업데이트되거나 삭제되지 않았다는 것을 의미, invalid)
t_cid 에는 0이 (해당 트랜잭션의 첫번째 statement 에서 추가됨을 의미)
t_ctid 에는 (0, 1) 이 설정되는데 이는 자기 스스로를 뜻하고, 이 tuple 이 해당 데이터의 대한 가장 마지막 버전이기때문에 그렇다.
	(0, 1) 의 0과 1이 각각 무엇을 의미하는지는 아직 불명


#### Deletion




## PostgreSQL 의 Table-Level Lock

여기서 row 라는 단어가 들어간다 하더라도 테이블 레벨 락임을 명심해야 함

https://www.postgresql.org/docs/current/explicit-locking.html
https://www.perplexity.ai/search/https-www-postgresql-org-docs-nklBUqytQ2eyuvRPNkRKXQ

### ACCESS SHARE



### ROW SHARE



### ROW EXCLUSIVE


### SHARE UPDATE EXCLUSIVE


### SHARE (ShareLock)


### SHARE ROW EXCLUSIVE


### Exclusive


### Access Exclusive






## PostgreSQL 의 Row-Level Locks


### FOR UPDATE


### FOR NO KEY UPDATE


### FOR SHARE



### FOR KEY SHARE


## Page Level Locks



