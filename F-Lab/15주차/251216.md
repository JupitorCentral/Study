## @SpringBootTest vs @WebMvcTest

그렇다면 나의 @Controller 를 TDD 로 개발하기 위해 어떤 어노테이션을 써야 할까?

-> 컨트롤러 단위 테스트 (Unit Test) 를 짤때는 @WebMvcTest 를 쓰는게 정석이다.

### 1. @SpringBootTest: "무거운 통합 테스트"

`@SpringBootTest`는 **애플리케이션 컨텍스트(Application Context)를 통째로 띄운다

- **동작 방식:** 실제 서버를 띄우는 것과 거의 똑같이 모든 빈(Bean)을 다 생성하고 등록한다. (`Controller`, `Service`, `Repository`, `Component` 등등 싹 다)
- **장점:** 실제 환경과 가장 유사하게 테스트할 수 있. (통합 테스트 용도)
    
- **단점 (치명적):**
    1. **너무 느립니다.** 테스트 하나 돌릴 때마다 스프링이 다 뜨느라 세월아 네월아 걸립니다. 
       TDD는 "작성 -> 실행 -> 수정" 사이클이 빨라야 하는데, 이게 느리면 TDD 못 합니다.
        
    2. **단위 테스트가 아닙니다.** 우리는 지금 "컨트롤러의 로직"만 검증하고 싶은데, DB 연결하고 외부 API 찌르고... 불필요한 작업이 다 포함됩니다.
        

### 2. @WebMvcTest: "가벼운 컨트롤러 전용 테스트"

반면에 `@WebMvcTest`는 **오직 웹 계층(Web Layer)과 관련된 빈만 골라서 띄웁니다.**

- **동작 방식:** `@Controller`, `@RestController`, `@ControllerAdvice` 등 웹 관련 빈만 생성합니다. 
	**`@Service`, `@Repository` 같은 비즈니스 로직 빈들은 생성하지 않습니다.**
    
- **장점:**
    1. **엄청 빠릅니다.** 필요한 것만 띄우니까요.
    2. **컨트롤러에만 집중할 수 있습니다.**

- **그럼 Service는요?:** 바로 여기서 아까 배운 **`@MockBean`** (Mockito)이 등장합니다! 실제 `Service` 빈 대신 가짜(Mock)를 채워 넣어서 컨트롤러가 동작하게 만듭니다.


| 특징          | @SpringBootTest     | @WebMvcTest               |
| ----------- | ------------------- | ------------------------- |
| **목적**      | 통합 테스트 (E2E, 전체 흐름) | **단위 테스트 (컨트롤러 로직 검증)**   |
| **로딩 범위**   | 모든 Bean (무거움)       | **Web Layer Bean만 (가벼움)** |
| **속도**      | 느림                  | **빠름**                    |
| **의존성 처리**  | 실제 Bean 주입 (주로)     | **`@MockBean`으로 가짜 주입**   |
| **TDD 적합성** | 낮음 (느려서)            | **높음**                    |



## Exception 발생시 Controller 에서 어떻게 처리하게 할 것인가 ?


### Error Handling Strategy

 @ExceptionHandler, @RestControllerAdvice 등이 있다.


#### @ExceptionHandler 

```java
@RestController
public class MyController {

    @GetMapping("/test")
    public String test() {
        throw new IllegalArgumentException("잘못된 입력입니다!"); // 예외 발생 시킴
    }

    // 이 컨트롤러 안에서 IllegalArgumentException이 터지면 이 메서드가 실행됨
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException e) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body("에러 발생: " + e.getMessage());
    }
}
```

@ExceptionHandler 안에 처리하고싶은 에러를 적으면 된다.

여러개를 한꺼번에 처리하려면

```java
@ExceptionHandler({NullPointerException.class, ArithmeticException.class})
public ResponseEntity<String> handleMultipleExceptions(Exception e) {
    return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body("서버 내부 오류 발생: " + e.getMessage());
}
```


##### 핵심 규칙

1. **범위**: 이 `@ExceptionHandler`는 **오직 이 메서드가 선언된 컨트롤러 내부**에서 발생한 예외만 잡는다. 
   다른 컨트롤러에서 `IllegalArgumentException`이 터져도 얘는 모른 척한다.
    
2. **우선순위**: 더 구체적인 예외가 먼저 잡힌다. 만약 `Exception.class`를 처리하는 핸들러와 
   `NullPointerException.class`를 처리하는 핸들러를 둘 다 만들었다면, 
   `NullPointerException`이 터졌을 때는 구체적인 `NullPointerException` 핸들러가 작동한다.

##### 모든 예외를 다 잡으려면 ?

```java
// 특정 예외 먼저 처리
@ExceptionHandler(IllegalArgumentException.class)
public ResponseEntity<String> handleBadReq(IllegalArgumentException e) {
    return ResponseEntity.badRequest().body("잘못된 요청");
}

// 위에서 안 잡힌 나머지 모든 예외 처리 (안전망)
@ExceptionHandler(Exception.class)
public ResponseEntity<String> handleAll(Exception e) {
    // 로그는 필수!
    log.error("예기치 못한 에러 발생", e);
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("서버 에러");
}
```

쉽게 말해서 특정 컨트롤러 안에서 발생하는 Exception 을 처리하는 어노테이션이라고 생각하면 된다.

#### @RestControllerAdvice

@ExceptionHandler 를 컨트롤러마다 해야하나 ? 라는 생각이 들 것이다.
이걸 해결하는데 @RestControllerAdvice 이다.

이 어노테이션이 붙은 클래스를 하나 만들어 두면, 프로젝트에 있는
**모든 REST 컨트롤러**(`@RestController`)에서 발생하는 예외를 이 클래스가 가로채서 처리해준다.


먼저, ResponseEntityExceptionHandler 가 나온 이유는 
spring 에서 exception 을 핸들링하는 메커니즘은 
먼저 내가 @ExceptionHandler 로 만든 처리 메서드가 실행되고
그 다음이 전역 처리 메서드 또는 ResponseEntityExceptionHandler 이기 때문이다.

```java
@RestControllerAdvice // 1. 이 클래스는 이제부터 모든 컨트롤러의 예외를 감시한다.
@Slf4j
public class GlobalExceptionHandler {

    // 2. 어떤 컨트롤러에서든 IllegalArgumentException이 터지면 얘가 잡는다.
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgument(IllegalArgumentException e) {
        log.warn("잘못된 요청 감지: {}", e.getMessage());
        return ResponseEntity.badRequest().body("잘못된 요청입니다: " + e.getMessage());
    }

    // 3. 어떤 컨트롤러에서든 NullPointerException이 터지면 얘가 잡는다.
    @ExceptionHandler(NullPointerException.class)
    public ResponseEntity<String> handleNPE(NullPointerException e) {
        log.error("서버 내부 오류(NPE): {}", e.getMessage());
        return ResponseEntity.internalServerError().body("서버에서 문제가 발생했습니다.");
    }
    
    // 4. 나머지 모든 예외 처리
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAll(Exception e) {
        log.error("알 수 없는 오류", e);
        return ResponseEntity.internalServerError().body("알 수 없는 오류가 발생했습니다.");
    }
}
```

기본적으로는 모든 컨트롤러에 적용되지만, 원한다면 특정 패키지나 특정 클래스만 감시하도록 설정할 수도 있다.

```java
// "com.kakaopay.api" 패키지 하위의 컨트롤러만 감시하겠다!
@RestControllerAdvice(basePackages = "com.kakaopay.api")
public class ApiExceptionHandler { ... }
```





### Error Message

-> 위의 필드를 가진 별도의 커스텀 DTO 클래스 를 사용하거나
-> 또는, SpringBoot 3 에서부터 RFC 7807 (Problem Details for HTTP APIs) 사양을 지원하는 ProblemDetail 객체를 사용할 수도 있다.


- FE 에게 건내기 쉬운 return value 형식

```json
{
  "timestamp": "2024-12-16T10:52:00",
  "status": 400,
  "error": "Bad Request",
  "code": "USER_NOT_FOUND",
  "message": "해당 사용자를 찾을 수 없습니다.",
  "path": "/api/users/123"
}
```

FE 에게 뭘 보낼지 표준으로 정해둔게 FC 7807 이고, 이걸 따르는 ProblemDetail 을 쓰면
Custom DTO 와는 다르게 회사의 별도 문서를 볼 필요가 없음.


Custom 응답 DTO Json 예시

```json
{
  "type": "https://api.kakaopay.com/errors/product-not-found",
  "title": "Product Not Found",
  "status": 404,
  "detail": "해당 상품(ID: 999)을 찾을 수 없습니다.",
  "instance": "/products/999",
  "timestamp": "2024-12-16T11:15:00",
  "code": "PRODUCT_001"
}
```

### ProblemDetail - RFC 9457

RFC 9457 은`Problem Details for HTTP APIs` 라는 이름을 가진 IETF(Internet Engineering Task Force) 의 표준 문서이다.
https://www.rfc-editor.org/rfc/rfc9457.html

원래 ProblemDetail 은 `RFC 7807` 에서 정의된건데, 여기서 모호한 표현들이 사라지고 개선된 것이 RFC 9457 이다.
2023 년에 개선되어 2023 년 7월 이후 신규 프로젝트는 RFC 9457 을 권장한다.


- IETF(Internet Engineering Task Force)

-> 인터넷 기술의 국제 표준을 정하는 기구.
-> RFC 9457 에는 HTTP API의 권위자인 **Mark Nottingham** 등이 저자로 참여했음

- RFC 7807과 RFC 9457의 주요 차이점

	- 문제 유형 관리: 7807은 커스텀 URI만 사용 가능, 9457은 IANA 공유 레지스트리 도입
	- 다중 오류 처리: 7807은 HTTP 207 상태 코드 사용 권장, 9457은 단일 문제 유형 내에서 `errors` 배열을 사용해 관련 오류를 그룹화
	- 확장 필드: 7807은 임의 필드 추가 가능, 9457은 문제 유형별 예상 필드 명시적 연관
	- 보안 권고: 7807은 미포함, 9457은 보안 취약점 방지를 위한 명시적 지침 추가
	- JSON 포인터: 7807은 미지원, 9457은 `pointer` 필드 공식 지원

#### 표준 필드

- **`type` (URI)**: 에러의 종류를 식별하는 URI (보통 에러 문서페이지로 연결) (예: `https://example.com/probs/out-of-credit`).
  -> 나는 개인 프로젝트니까 따로 문서가 없어서 `BLANK_TYPE` 을 쓰면 된다
- **`title` (String)**: 사람이 읽을 수 있는 짧은 에러 요약 (예: "잔액 부족").
- **`status` (int)**: HTTP 상태 코드 (예: 403).
- **`detail` (String)**: 이 에러가 발생한 구체적인 설명 (예: "현재 잔액은 30원인데, 1000원을 결제하려고 시도했습니다.").
- **`instance` (URI)**: 에러가 발생한 특정 지점(URI) (예: `/account/12345/msgs/abc`).

그리고 custom 하게 쓰라고 있는게 properties 이다.


#### 사용하는 이유

프로젝트마다 서로 다른 json response 를 줄 경우 의미가 혼동되고 그러다보면 FE 입장에서는 어떤 필드를 어떻게 써야할지 모르고
에러 타입마다 따로따로 처리를 해야 한다. 또 해당 응답을 사용하는 다른 서버도 마찬가지.
포맷이 통일되면 처리 로직을 하나만 만들면 된다.

따라서 표준을 따르는 외부서버와 별도의 문서 없이 소통이 가능하다.


#### 사용법

1. application.properties 수정

```kotlin
spring.mvc.problemdetails.enabled=true
```

이렇게 하면 Spring MVC 가 예외를 처리할때 자동으로 `ProblemDetail` 포맷으로 변환을 시도한다.

2. ResponseEntityExceptionHandler 상속

```java
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    // Spring 표준 예외는 알아서 ProblemDetail로 변환됨
}
```

3. 커스텀 예외 처리 (Custom Exception Handling)

custom Exception 을 처리할때는 ProblemDetail 의 정적 팩토리 메서드를 사용해야 한다.
(forStatus, forStatusAndDetail)


```java
@ExceptionHandler(UserNotFoundException.class)
public ProblemDetail handleUserNotFoundException(UserNotFoundException e) {
    // 1. 기본 객체 생성 (Status와 Detail 필수)
    ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(
        HttpStatus.NOT_FOUND, 
        e.getMessage()
    );
    
    // 2. 표준 필드 설정 (Title, Type, Instance 등)
    problemDetail.setTitle("User Not Found");
    problemDetail.setType(URI.create("https://api.kakaopay.com/errors/user-not-found")); // 에러 명세 문서 링크
    problemDetail.setInstance(URI.create("/api/users/123")); // 에러가 발생한 리소스 식별자
    
    // 3. 비표준(Custom) 필드 추가 (setProperty 사용)
    problemDetail.setProperty("timestamp", Instant.now());
    problemDetail.setProperty("traceId", "abc-123-xyz"); 

    return problemDetail;
}
```


#### Spring MVC Exception Handling Mechanism

스프링 MVC의 에러 처리 메커니즘은 매우 명확한 **우선순위**를 가지고 있습니다.

1. **1순위: 당신이 만든 `@ExceptionHandler`**
    
    - 당신이 `CustomException`에 대해 `@ExceptionHandler`를 만들어 놨다면, 스프링은 무조건 이걸 먼저 실행합니다.
    - 자동 설정(`spring.mvc.problemdetails.enabled=true`)은 이 단계에서 관여하지 않습니다.
        
2. **2순위: `ResponseEntityExceptionHandler` (혹은 전역 처리)**
    
    - 특정 예외를 못 잡았을 때, 부모 클래스나 전역 핸들러가 처리합니다.
        
3. **3순위: 스프링의 자동 처리 (Default Handling)**
    
    - **위 1, 2번에서 아무도 잡지 않은 예외**가 발생했을 때만, 
      비로소 `spring.mvc.problemdetails.enabled=true` 설정이 동작합니다.


#### spring.mvc.problemdetails.enabled=true 적용시 Custom Exception 이 발생한다면 ?

```java
public class UserNotFoundException extends RuntimeException {  
    private final String loginId;  
    private final HttpStatus httpStatus;  
  
    public UserNotFoundException(ReservationRequest request) {  
       super("사용자 조회 안됨 - login Id : " + request.getLoginId());  
       this.loginId = request.getLoginId();  
       this.httpStatus = HttpStatus.NOT_FOUND;  
    }  
}
```

-> 내가 기대한건 404 not found 이겠지만 
실제로는 500 Internal Server Error 가 나간다.
왜냐하면 Custom Exception 에 대한 Handler 가 없는한 자동처리할때 ProblemDetail 이 내가 선언한 필드를 파악할 수 없기 떄문.

(예상되는 결과 -> 확인이 필요하다)
```json
{
  "type": "about:blank",
  "title": "Internal Server Error",
  "status": 500,
  "detail": null,  // 보안상 이유로 기본적으로 메시지는 숨겨짐
  "instance": "/요청한-uri-경로"
}
```

그래서 이런식으로 CostumException 에서 ProblemDetail 을 반환하게 하는게 좋다.

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ProblemDetail;
import org.springframework.web.ErrorResponse;

public class UserNotFoundException extends RuntimeException implements ErrorResponse {

    private final Long userId;

    public UserNotFoundException(Long userId) {
        super("User with ID " + userId + " not found");
        this.userId = userId;
    }

    @Override
    public HttpStatusCode getStatusCode() {
        return HttpStatus.NOT_FOUND;
    }

    @Override
    public ProblemDetail getBody() {
        // 여기서 딱 한 번만 정의하면 된다!
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(getStatusCode(), getMessage());
        problemDetail.setTitle("User Not Found");
        problemDetail.setType(URI.create("https://api.kakaopay.com/errors/user-not-found"));
        problemDetail.setProperty("userId", userId); // 커스텀 필드도 여기서
        return problemDetail;
    }
}
```

```java
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    // ErrorResponse를 구현한 모든 예외를 한방에 처리
    @ExceptionHandler(UserNotFoundException.class) // 혹은 부모 타입
    public ProblemDetail handleErrorResponseException(ErrorResponse ex) {
        return ex.getBody();
    }
}
```





#### spring.mvc.problemdetails.enabled=true 적용시 기존 Exception 은 ?

Custom Exception 과는 완전 다르게 처리된다.

예를 들어, 멘티님이 `GET` 요청만 받는 컨트롤러에 `POST` 요청을 날렸다고 칩시다.

- **발생 예외:** `HttpRequestMethodNotSupportedException`
- **스프링의 판단:** "이건 RFC 표준상 **405 Method Not Allowed**야."
- **나가는 응답 (JSON):**
```json
{
  "type": "about:blank",
  "title": "Method Not Allowed",
  "status": 405,
  "detail": "Supported methods: [GET]",
  "instance": "/api/users"
}
```

- 주요 내장 매핑 표

|발생 예외 (Exception)|자동 매핑되는 상태 (Status)|의미|
|---|---|---|
|`HttpRequestMethodNotSupportedException`|**405** Method Not Allowed|HTTP 메서드 틀림|
|`HttpMediaTypeNotSupportedException`|**415** Unsupported Media Type|Content-Type 틀림 (JSON 보내야 하는데 XML 보냄 등)|
|`NoHandlerFoundException`|**404** Not Found|URL에 매핑된 컨트롤러 없음 (설정 필요)|
|`MethodArgumentNotValidException`|**400** Bad Request|`@Valid` 검증 실패|
|`MissingServletRequestParameterException`|**400** Bad Request|필수 `@RequestParam` 누락|




## Mockito 의 Mock 대신에 @MockBean 을 써야하는 상황? 이유?

일단 Spring Application Context 가 필요하기 때문이다.

그럼 왜 MockBean 을 Context 에 넣어야만 하는가 ? 라는 질문이 필요한데

둘의 가장 큰 차이는 `Spring Container(ApplicationContext) 가 해당 mock 객체를 관리하게 할 것인가 ?` 이다

만약 @Mock 을 사용할 경우, application context, 즉 spring container 가 없이 mock 객체만 생성되는 것이기 때문에
해당 클래스를 의존성으로 가지는 다른 객체들이 의존성 주입을 받지 않게 된다. 즉, DI 가 안이루어진다.

그래서 이때 @InjectMock 으로 의존성을 주입해주어야 하는 것이다.

| 특징                 | @Mock (Mockito)                 | @MockBean (Spring Boot)                            |
| ------------------ | ------------------------------- | -------------------------------------------------- |
| **테스트 종류**         | **Pure Unit Test** (순수 단위 테스트)  | **Integration Test** (통합/슬라이스 테스트)                 |
| **Spring Context** | 실행 안 함 (가볍고 빠름)                 | 실행 함 (무겁고 느림)                                      |
| **주입 방식**          | 수동 주입 (`new Service(mockRepo)`) | 자동 주입 (`@Autowired`)                               |
| **사용 시점**          | 비즈니스 로직(Service)만 검증할 때         | Controller 테스트 (`@WebMvcTest`) 처럼 Spring 환경이 필요할 때 |

그래서 만약 클래스 A 가 있고, 그 클래스가 B, C 에 대해 의존할때, 클래스 A 를 @Mock 으로 
mock  객체를 만들면 해당 객체는 DI 가 전혀 이루어지지 않는다.

그래서 Stubbing 을 하는 것이다.

@MockBean 도 stubbing 이 필요하다. 대신,
다른 의존성들을 주입하기 위해서 쓰는 것이고,

실제 실행을 방지하기 위함이다.

예를 들어 외부 api 를 사용하여 메일을 발송하는 emailService 클래스가 있다고 치자.
테스트시 이 클래스를 가지고 테스트를해야 하는데 실제로 이메일이 발송되면 안된다.
그리고 테스트를 위해 다른 의존성들이 필요하다.

그럴때 @MockBean 을 사용해서 emailService 가 실제로 이메일을 발송하지 않고
이메일을 발송했다고 '치고' 다른 스텝을 테스트하는 것이다.


### 의존성 그래프 완성

의존성 주입 에러 없이 사용하기 위해서.


예를 들어, `OrderService`를 테스트하려는데, 얘가 `UserService`, `PaymentService`, `EmailService` 3개를 필요로 한다고 칩시다.  
Spring Context를 띄우려면 이 3개가 모두 Bean으로 등록되어 있어야 합니다. 하나라도 없으면 "Bean을 찾을 수 없다"며 에러가 나고 테스트가 시작조차 안 됩니다.

이때 `PaymentService`나 `EmailService` 구현체가 복잡하거나 외부 설정이 필요하다면?  
그냥 `@MockBean` 하나 붙여주면 복잡한 설정 없이도 **Spring이 "아, 얘네들은 가짜 Bean으로 채워 넣으면 되는구나" 하고 Context를 무사히 완성**시켜 줍니다.​



### 주의할 점 : Context Recreation

`@MockBean`을 사용하면 Spring은 테스트를 돌릴 때마다 **Context를 새로 띄워야 할 수도 있습니다.**  
Spring은 원래 테스트 속도를 높이기 위해 한번 띄운 Context를 재활용(Caching)하는데, 
`@MockBean`이 선언되면 "어? 기존 Context랑 구성이 다르네?" 하고 Context를 새로 만들어버립니다.​

이로 인해 테스트 코드가 많아질수록 전체 테스트 시간이 **기하급수적으로 느려지는 원흉**이 되기도 합니다.

그러니까 Context Recreation 은 
동일한 @ActiveProfiles 설정으로 같은 application context 를 공유하는 테스트들 사이에서
여러 클래스들에서 동일하게 사용하는 특정 Bean 을 특정 클래스에서 해당 Bean 을 @MockBean 으로 사용할 경우
그 테스트 클래스를 위한 Application Context 가 생성이 되는 것을 말하는 것.

쉽게 말하면 @MockBean 을 잘못사용하면 컨텍스트의 유니크함이 깨져 Context Recreation 이 발생해
테스트 비용이 급격하게 증가한다는 얘기이다.

#### Spring 의 Context Caching 원리

https://rieckpil.de/spring-boot-test-context-caching-the-complete-guide/
https://docs.spring.io/spring-framework/reference/testing/testcontext-framework/ctx-management/caching.html

Spring TestContext Framework는 테스트 속도를 위해 Context를 캐싱(Caching)합니다. 
이때 "Context Key"라는 것을 만들어서 관리하는데, 이 Key는 아래의 요소들에 의해 정해진다.

- **Configuration Sources**: Defined by `@ContextConfiguration`.
- **Context Initializers**: Also via `@ContextConfiguration`.
- **Test-Specific Customizers**: Like `@DynamicPropertySource`, `@MockitoBean/MockBean`, or `@MockitoSpyBean/SpyBean`.
- **Context Loader Type**: Specified in `@ContextConfiguration`.
- **Parent Context**: From `@ContextHierarchy`.
- **Active Profiles**: Set with `@ActiveProfiles("test")`.
- **Test Properties**: Via `@TestPropertySource`.
- **Resource Path**: From `@WebAppConfiguration`.

즉, "이 테스트는 A, B 설정을 쓰고 C 프로파일이야"라는 조건이 같으면 기존에 띄워둔 Context를 재활용한다.


### How to prevent Context Recreation

테스트는 상속이 가능하다. 상속을 하면, 같은 Spring Context 를 공유하게 된다.

모든 테스트가 공통으로 사용할 `@MockBean` 설정을 부모 클래스에 몰아넣어서, 
Spring이 보기에 '어? 얘네 둘은 설정이 똑같네?'라고 인식하게 만드는 방법이 있다.

```java
@SpringBootTest
@ActiveProfiles("test")
public abstract class IntegrationTestSupport {
    
    // 핵심: 여기서 @MockBean을 정의합니다.
    // 이 클래스를 상속받는 모든 자식 테스트는 이 '가짜 EmailService'가 포함된
    // "단 하나의 ApplicationContext"를 공유해서 씁니다.
    @MockBean
    protected EmailService emailService;

    @MockBean
    protected PaymentService paymentService;
}

class UserTest extends IntegrationTestSupport {
    
    @Test
    void 회원가입_테스트() {
        // 부모에 있는 emailService가 이미 Mock으로 주입되어 있음
        // Context 재로딩 없음 (캐시된 것 사용)
    }
}

class OrderTest extends IntegrationTestSupport {

    @Test
    void 주문_테스트() {
        // 부모에 있는 paymentService가 이미 Mock으로 주입되어 있음
        // ★중요: UserTest와 "구성(Bean Definition)"이 100% 일치하므로 Context 재사용!
    }
}
```


별도의 프로파일 (`@ActiveProfiles("test2")`) 를 만들어서 하는 것도 하나의 방법이다.
똑같이 서로다른 Context 가 2개가 생기는 것이기 떄문.




