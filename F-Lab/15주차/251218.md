## MockMvc

https://www.baeldung.com/spring-mockmvc-vs-webmvctest

### Using _MockMvc_

MockMvc 는 Http Request 를 모방하여 MVC 부분을 테스트하는데에 쓰인다 (주로 컨트롤러 쪽)

MockMvc 와 함께 @_SpringBootTest_ 또는 @_WebMvcTest_ 가 쓰이는데, 
@_SpringBootTest_ 의 경우 완전한 applicaton context 를 로딩하기 때문에 서비스 레이어의 빈을 완전히 사용할 수 있다.
_MockMvc_ 를 사용하기 위해선 @_AutoConfigureMockMvc_ 를 추가해야 한다. 이 어노테이션은 _MockMvc_ 의 인스턴스를 생성하고,
_mockMvc_ 에 주입한다. 


```java
@AutoConfigureMockMvc
@SpringBootTest
class SortingControllerIntegrationTest {
    @Autowired
    private MockMvc mockMvc;
}
```

@_WebMvcTest_  를 쓸때는 서비스 레이어에 @_MockBean_ 이 주입되서 서비스 레이어를 실제로 실행시키지 않고 테스트할 수 있다.
그리고 application context 에 서비스 레이어 빈이 추가가 되지 않는다. (애초에 @_WebMvcTest_ 는 web layer bean 만 생성한다)
@_AutoConfigureMockMvc_ 이 어노테이션에 포함되어 있다


```java
@WebMvcTest
class SortingControllerUnitTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private SortingService sortingService;
}
```

- 주의할 점

_webEnvironment=RANDOM_PORT_ 을 @_SpringBootTest_ 와 함께 쓸때 _MockMvc_ 사용을 주의 해야 하는데, 왜냐하면

_webEnvironment=RANDOM_PORT_ 설정은 servlet container 를 불러오려고 할때
_MockMvc_ 는 실행되는 servlet container 가 없음과 web request 를 핸들링하는데에 있어서 무엇이든간에 준비되어 있는 것을 확실하게 하려고 시도하기 때문이다.

그러니까 저 2개의 옵션은 충돌된다.


### What is **Autoconfigured**

@_WebMvcTest_ 을 쓸때, Spriing Boot 는 자동적으로 _MockMvc_ 객체, _DispatcherServlet_, _HandlerMapping_, _HandlerAdapter_, and _ViewResolvers_ 을 생성한다.
그리고 @_Controller_, _@ControllerAdvice_, _@JsonComponent_, _Converter_, _GenericConverter_, _Filter_, _WebMvcConfigurer_, and _HandlerMethodArgumentResolver_ 등을 스캔한다.
-> 한마디로 웹 레이어 빈들을 생성한다. 이제와서 보니 @_ControllerAdvice_ -> error handling component 도 웹 레이어에 포함이 되네.

@_SpringBootTest_ 는 반면에 
@_SpringBootApplication_ 이 하는 모든 것 (SpringBootConfiguration+ EnableAutoConfiguration + ComponentScan) 을 한다.
심지어 _application.properties_ 파일도 로딩하고, 프로파일 관련 정보들도. 그리고 @_Autowired_ 를 이용한 injection 도 가능하게 한다.


### Web Environment During Testing -> using TestRestTemplate

“http://localhost:8080” 을 브라우저에 쳐서 서버에서 처리되는 상황을 재현하려고 해보자.
이러한 상황을 재현하기 위해서 _webEnvironment_ 를 쓴다.
이걸 씀으로써 테스트를 위한 포트를 설정하게 된다.

@_WebMvcTest_ 는 오직 simulated 된 환경만 제공하는 반면에
@_SpringBootTest_ 는  _webEnvironment (WebEnvironment.MOCK)_  또는 실제 환경까지 제공한다.

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SortingControllerWithWebEnvironmentIntegrationTest {
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private ObjectMapper objectMapper;
}

@Test
void whenHelloWorldMethodIsCalled_thenReturnSuccessString() {
    ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:" + port + "/", String.class);
    Assertions.assertEquals(HttpStatus.OK, response.getStatusCode());
    Assertions.assertEquals("Hello, World!", response.getBody());
}

@Test
void whenSortMethodIsCalled_thenReturnSortedArray() throws Exception {
    List<Integer> input = Arrays.asList(5, 3, 8, 1, 9, 2);
    List<Integer> sorted = Arrays.asList(1, 2, 3, 5, 8, 9);

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);

    ResponseEntity<List> response = restTemplate.postForEntity("http://localhost:" + port + "/",
	    new HttpEntity<>(objectMapper.writeValueAsString(input), headers),
	    List.class);

    Assertions.assertEquals(HttpStatus.OK, response.getStatusCode());
    Assertions.assertEquals(sorted, response.getBody());
}
```


### Dependencies -> using MockBean

@_WebMvcTest_ 는 필요한 의존성을 자동으로 생성하지 않기 때문에 mock 을 해야 한다 (서비스 레이어 안불러오니까)

```java
@WebMvcTest
class SortingControllerUnitTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private SortingService sortingService;
}

@Test
void whenSortMethodIsCalled_thenReturnSortedArray() throws Exception {
    List<Integer> input = Arrays.asList(5, 3, 8, 1, 9, 2);
    List<Integer> sorted = Arrays.asList(1, 2, 3, 5, 8, 9);

    when(sortingService.sortArray(input)).thenReturn(sorted);
    mockMvc.perform(post("/").contentType(MediaType.APPLICATION_JSON)
	    .content(objectMapper.writeValueAsString(input)))
	    .andExpect(status().isOk())
	    .andExpect(content().json(objectMapper.writeValueAsString(sorted)));
}
```

### refEq, Any()

둘 다 Mockito 의 MockBean 의 메서드의 파라미터로 객체가 넘어갈때 쓰이는데,

refEq 의 경우
자바의 리플렉션(Reflection) 기능을 이용해 객체의 필드값들을 하나하나 뜯어서 비교하겠다 는 의미이다.

#### 1. `refEq`의 동작 원리 (Why use it?)

보통 자바 객체 비교는 두 가지 방법으로 이루어집니다.

1. \== (주소 비교)**: 완전히 같은 메모리 주소를 가진 객체인가?
2. **`equals()` (내용 비교)**: 개발자가 정의한 논리적인 동등함인가?
    
멘티님의 DTO(`ReservationRequest`)는 `equals()`를 오버라이딩하지 않았기 때문에, Mockito는 기본적으로 **주소 비교(\==)** 
혹은 `Object` 클래스의 기본 `equals()`(역시 주소 비교)를 수행합니다. 그래서 테스트 코드에서 만든 객체와 실제 서비스가 받은 객체가 다르다고 판단한 것이죠.

그리고 request 의 body 에 들어간 객체가 mockbean 의 파라미터 객체와 다르면
Mockito 는 dothrow 같은걸 실행하지 않는다

```java
doThrow(UserNotFoundException.class).when(payManagementService)  
    .payReservation(requestWithNotValidLoginId);
```

하지만 **`refEq`를 쓰면 다음과 같이 동작**합니다:

1. Mockito가 객체의 **모든 필드(멤버 변수)를 리플렉션으로 가져옵니다.    
2. `loginId`, `amount`, `date` 등 필드 값을 하나하나 꺼냅니다.
3. 두 객체의 필드 값이 모두 일치하면 "같은 객체"로 인정해줍니다.
    
즉, **"주소고 뭐고 다 필요 없고, 안에 들어있는 데이터(필드 값)가 같으면 통과시켜!"라고 명령하는 것입니다.

#### 굳이 왜이렇게 설정한 걸까?

결론부터 말씀드리면, **"속도"와 "정확성(엄격함)", 그리고 "자바의 객체 지향 철학 준수"** 때문입니다.

##### 1. 자바의 철학: "명시하지 않으면 남남이다"

자바(Java)에서 객체(Object)는 기본적으로 **'상태(값)'가 같다고 해서 같은 객체로 보지 않습니다.**

- 내가 만든 `사람` 객체 (이름: 홍길동)
- 멘티님이 만든 `사람` 객체 (이름: 홍길동)

현실 세계에선 동명이인이면 다른 사람이죠? 자바도 마찬가지입니다. 개발자가 `equals()`를 통해 "이 두 사람은 주민번호가 같으니 같은 사람으로 쳐줘!"라고 **명시적으로 규칙을 정해주지 않는 한**, 자바는 둘을 엄격하게 다른 존재로 취급합니다.

Mockito는 자바 라이브러리이기 때문에 이 자바의 기본 철학을 그대로 따릅니다. "개발자가 `equals`를 안 만들었다면, 다른 객체로 보는 게 맞다"라고 판단하는 거죠.

##### 2. 테스트의 정확성: "우연히 통과하는 테스트 방지"

만약 Mockito가 기본적으로 모든 필드를 다 비교(refEq)한다고 가정해 봅시다.

- **상황:** 테스트 중에 `User` 객체의 `password` 필드가 우연히 `null`로 들어왔는데, 비교 대상 객체도 `password`가 `null`이었습니다.
- **결과:** Mockito가 "어? 똑같네?" 하고 통과시킵니다.
- **문제:** 사실은 비밀번호가 암호화되어야 했는데, 둘 다 `null`이라서 버그를 놓치게 됩니다.

엄격한 비교(`eq`)는 이런 "우연의 일치"를 방지합니다. 
개발자가 "나는 이 객체와 정확히 일치하는(혹은 동등한) 녀석만 허용하겠어"라고 의도를 명확히 드러내야 테스트가 통과되도록 설계된 것입니다.

##### 3. 성능 문제: "리플렉션은 비싸다"

아까 말씀드린 `refEq`는 **리플렉션(Reflection)** 기술을 씁니다.
- **일반 비교(`equals`):** 그냥 메모리 주소만 쓱 보거나, 정의된 로직만 실행. (매우 빠름)
- **리플렉션 비교(`refEq`):** 런타임에 클래스 정보를 뜯고, 필드 목록 가져오고, private 접근 제어 풀고, 값 하나하나 꺼내서 비교. (상대적으로 느림)

Mockito는 전 세계 수많은 프로젝트에서 수천, 수만 번 실행되는 라이브러리입니다. 기본 동작을 무거운 리플렉션 방식으로 해두면 전체 테스트 속도가 현저히 느려질 수 있습니다. 그래서 **"가볍고 빠른 방식(equals)"을 기본값(Default)으로 두고, 무거운 방식(refEq)은 "필요하면 갖다 써라"는 옵션으로 뺀 것**입니다.


#### 2. 비교: `eq()` vs `refEq()` vs `any()`

| Matcher            | 설명        | 동작 방식                               | 언제 쓰는가?                                                       |
| ------------------ | --------- | ----------------------------------- | ------------------------------------------------------------- |
| **`eq(value)`**    | **기본값**   | 객체의 `equals()` 메서드를 호출해서 비교함.       | DTO에 `equals()`가 잘 구현되어 있을 때.                                 |
| **`refEq(value)`** | **필드 비교** | `equals()` 무시. 리플렉션으로 필드 값을 전수 조사함. | **DTO에 `equals()`가 없고**, 특정 데이터가 들어왔는지 **검증은 하고 싶을 때**.       |
| **`any(Class)`**   | **타입 비교** | 값은 안 봄. 해당 클래스 타입이기만 하면 통과함.        | 값 검증이 귀찮거나, **무엇이 들어오든 예외를 던지는 시나리오**일 때 (아까 제가 추천드린 1순위 방법). |

#### 3. 코드 예시로 보는 차이

```java
// 상황: DTO에 equals()가 없음
ReservationRequest req1 = new ReservationRequest("user1");
ReservationRequest req2 = new ReservationRequest("user1");

// 1. 일반적인 Mockito 설정 (실패함)
// req1.equals(req2)는 false이므로 매칭 안 됨 -> null 리턴 -> 테스트 실패
when(service.pay(req1)).thenReturn(...); 

// 2. refEq 사용 (성공함!)
// req1과 req2의 "loginId" 필드 값이 "user1"으로 같으므로 매칭 성공!
when(service.pay(refEq(req1))).thenReturn(...);

```

근데 여전히 잘 모르곘다. 이 부분은 복습이 필요할 듯하다.



### WrongTestCase - Exception throws

```java
@Test  
@DisplayName("결제를 하는데 없는 사용자 id 일 경우 UserNotFound Exception 을 ProblemDetail 형식으로 리턴")  
public void throws_UserNotFoundException_when_userIdIsWrong() throws Exception {  
    final String notValidLoginId = "notValidLoginId";  
  
    ReservationRequest requestWithNotValidLoginId = createValidReservationRequest();  
    requestWithNotValidLoginId.setLoginId(notValidLoginId);  
  
    doThrow(UserNotFoundException.class).when(payManagementService)  
       .payReservation(requestWithNotValidLoginId);          // -> 문제의 부분
  
    mockMvc  
       .perform(  
          post("/api/reservation/pay")  
             .contentType(MediaType.APPLICATION_JSON)  
             .content(objectMapper.writeValueAsString(requestWithNotValidLoginId)))  
       .andExpect(status().isNotFound())  
       .andExpect(jsonPath("$.statusCode").value(HttpStatus.NOT_FOUND.value()))  
       .andExpect(jsonPath("$.title").value("존재하지 않는 사용자"))  
       .andExpect(jsonPath("$.detail").value(String.format("%s id 를 가진 사용자가 없음", notValidLoginId)));  
}
```

이상하게 여기서 컨트롤러가 200을 리턴하는데, 
그러니까 에러가 발생하지 않는다. 

먼저

```java
doThrow(UserNotFoundException.class).when(payManagementService)  
       .payReservation(requestWithNotValidLoginId);
```

여기서 문제이다. 

`doThrow(...).when(service).payReservation(requestWithNotValidLoginId)` 형태입니다. 
여기서 Mockito는 `payReservation`이 호출될 때, 인자로 들어온 객체가 `requestWithNotValidLoginId`와 **정확히 일치할 때만** 예외를 던지도록 설정됩니다.

하지만 실제 실행 과정은 다음과 같습니다:

1. 테스트 코드에서 `MockMvc`가 JSON 문자열을 전송합니다.
2. 컨트롤러는 Jackson 라이브러리를 통해 이 JSON을 **새로운 Request 객체**로 변환합니다.
3. 컨트롤러가 서비스의 `payReservation(newRequest)`를 호출합니다.
4. Mockito는 설정해둔 `requestWithNotValidLoginId`와 `newRequest`를 비교합니다.
5. 두 객체는 내용은 같지만 서로 다른 인스턴스이므로, **일치하지 않는다고 판단**합니다.​
6. 결과적으로 `doThrow`는 실행되지 않고, 서비스 메서드는 아무 일도 하지 않은 채(Void라면) 종료되거나 `null`을 리턴합니다.
7. 컨트롤러는 예외가 발생하지 않았으므로 정상 흐름을 타고 200 OK를 리턴합니다.

즉 doThrow 를 사용할때 메서드의 argument 에 request 의 body 에 들어간 객체와 맞지 않으면
Mockito 는 doThrow 를 실행되지 않는다는 얘기이다. 참 왜 이렇게 만든건지 잘 모르곘다.

그래서 해결책은, refEq 를 사용하거나 Any() 를 사용하는 것이다.

```java
doThrow(UserNotFoundException.class).when(payManagementService)  
       .payReservation(requestWithNotValidLoginId);
```

그러니까, 정리하자면

```java
mockMvc  
    .perform(  
       post("/api/reservation/pay")  
          .contentType(MediaType.APPLICATION_JSON)  
          .content(objectMapper.writeValueAsString(requestWithNotValidLoginId)))
```

에서 request 에 내가 위에서 정의한 `equestWithNotValidLoginId` 객체를 가지고 Jsckson 이 직렬화해서
http request body 에 집어 넣는다.

이후 컨트롤러에서 해당 데이터를 @RequestBody 를 통해 파라미터에 집어넣는다.
그런데 내 코드에서는 

```java
doThrow(UserNotFoundException.class).when(payManagementService)  
    .payReservation(requestWithNotValidLoginId);
```
을 집어넣는데,
이때 컨트롤러에 자동으로 들어간 ReservationRequest 타입의 request 객체와 
(이 객체는 request 의 body 를 보고 역직렬화해서 새로 생성된다)
내가 정의한 `requestWithNotValidLoginId` 는 값은 같아도 메모리 주소값이 다른 엄연히 다른 객체이다.

Mockito 는 이걸 문제 삼는다.

그래서 다르면, Mockito 의 기능 (doThrow, when 등) 을 실행하지 않는다.

#### 도대체 무슨 일이 벌어지는가 ?


일단 지금 Mockito 의 행동 메커니즘을 보면

```java
doThrow(UserNotFoundException.class).when(payManagementService)  
    .payReservation(requestWithNotValidLoginId);
```

이 코드가 의미하는 바는 내가 이전에 정의해두었던
`requestWithNotValidLoginId` 객체가 해당 메서드의 파라미터로 들어가면
`UserNotFoundException` 에러를 발생시켜라 이다.

그런데 _mockMvc.perform_ 을 이용해서 request 를 보낼때
이 객체 - request 의 http body 에 있는 값을 가지고 자동으로 생성된 객체
(`requestWithNotValidLoginId`) 가 payManagementService 의 payReservation 의 파라미터로 넘어갈때의
행동이 정의되어 있지 않기 때문에 (`requestWithNotValidLoginId` 가 넘어갈때는 정의되어 있지만)

Mockito 의 일반적인 방침에 따라 doThrow 가 실행되지 않는 것이다.


#### 그래서? 만약 두 객체가 다르면 무슨 문제가 생기는데 ?

아니 같은 필드값을 가지는 두 객체가 둘이 서비스의 메서드의 파라미터로 들어가도
동작은 동일하게 할 것 아닌가?

근데 왜 스프링부트팀에서는 Mockito 의 동작을 이렇게 하게끔 설정을 해두었을까?
메모리가 다를때 말이다.

문제가 발생할 케이스가 있으니까 이러는거 아니겠는가 ?

스프링 부트의 철학때문이다.


##### 1. "대충 비슷하면 통과" vs "정확히 이거여야 통과"

Mockito는 테스트 프레임워크입니다. 테스트는 **'엄격함'**이 생명입니다.

- **느슨한 비교 (Equality):** "내용물만 같으면 OK 해줄게."
    
- **엄격한 비교 (Identity):** "아니, 내가 지정한 **바로 그 객체**여야 해."
    

만약 Mockito가 기본적으로 `equals()`(내용 비교)를 사용한다고 가정해 봅시다.

##### [위험 시나리오]

멘티님이 `updateUser(User user)` 메서드를 테스트한다고 칩시다.

- `User A` (ID: 1, 이름: "철수", **나이: 20**)
    
- `User B` (ID: 1, 이름: "철수", **나이: 99**)

그런데 `User` 객체의 `equals()`가 **ID만 비교**하도록 구현되어 있다면?  
Mockito는 `User A`와 `User B`를 **같은 객체**로 착각하게 됩니다.  
테스트는 통과하겠지만, 실제로는 **나이가 20살이어야 하는데 99살로 업데이트되는 버그**를 놓치게 됩니다.

**이런 '의도치 않은 통과'를 막기 위해, Mockito는 가장 보수적이고 안전한 '주소값 비교(Identity)'를 기본값으로 채택한 것입니다.**

메모리 주소값만 같으면, 일단 기본적으로 개발자가 
equals 를 잘못설정하더라도 같음을 판단할 수 있고,
메모리 주소가 같으면 그 객체를 이루는 필드의 값이 모두 같을 것이기 떄문이다.

---

##### 2. "개발자가 직접 선택해라" (Explicit is better than Implicit)

스프링과 Mockito 개발자들의 철학은 **"마법(Magic)을 부리지 말라"**는 것입니다.

- 기본적으로는 가장 엄격하게(주소값 비교) 동작합니다.
    
- 만약 개발자가 "나는 내용만 같으면 돼"라고 판단했다면, **명시적으로** `any()`나 `refEq()`를 써서 의도를 드러내라는 것입니다.
    

> "네가 `any()`를 썼다는 건, 객체가 달라도 된다는 걸 **알고** 썼다는 뜻이지? 그럼 OK."

이렇게 코드를 짜야, 나중에 다른 개발자가 테스트 코드를 봤을 때 **"아, 여기서는 객체 내용만 중요하구나"**라고 명확하게 이해할 수 있습니다.

##### 3. 성능 문제 (Performance)

모든 메서드 호출마다 `equals()`를 실행하거나, `Reflection`으로 필드를 하나하나 비교하는 비용은 생각보다 큽니다.  
테스트가 수천 개, 수만 개 돌아가는 환경에서 **단순 주소 비교(\=\=)는 압도적으로 빠릅니다.

그러니까 메모리 주소만 비교하면 성능이 좋기 때문이라고 볼 수 있다.



#### 좋아. 그럼 해결책은 ? -> ArgumentCaptor

##### 1. 왜 `ArgumentCaptor`를 쓰는가?

멘티님 말씀대로 **비용 문제**도 있지만, 더 큰 이유는 **"검증의 유연성"과 "디테일한 확인"** 때문입니다.

- **`refEq` / `equals`:** "얘랑 쟤랑 똑같아?" (Yes/No) -> **단순 비교**
- **`ArgumentCaptor`:** "아까 걔가 던진 공(객체) 좀 가져와 봐. 내가 직접 뜯어볼게." -> **정밀 분석**

Mockito가 "주소가 달라서 모르겠는데요?"라고 시치미를 떼면, 캡처를 써서 **"시끄럽고, 
아까 걔가 넘긴 객체 압수해!"** 라고 해서 가져온 다음, 
**내 눈으로 직접(Assertion) 까보는 방식**입니다. 이게 훨씬 직관적이고 강력합니다.

---

##### 2. `ArgumentCaptor` 사용법 (실전 코드)

상황: `Controller`가 `Service.payReservation(request)`를 호출할 때 넘긴 `request` 객체를 잡아서 확인하고 싶음.

###### \[단계별 적용]

**Step 1: 캡처할 도구(Captor) 준비**  
테스트 클래스 안에 선언합니다.

```java
@Captor 
ArgumentCaptor<PayReservationRequest> requestCaptor; // (1) 캡처 도구 선언
```

_(또는 테스트 메서드 안에서 `ArgumentCaptor.forClass(PayReservationRequest.class)`로 직접 만들어도 됨)_

**Step 2: Mockito에게 "일단 아무거나 받아"라고 지시 (Stubbing)**  
Mock은 엄격하니까, 일단 `any()`로 문을 열어줍니다.

```java
// "아무거나 들어오면 일단 내가 원하는 예외 던져줘" (그래야 컨트롤러 로직이 진행되니까)
doThrow(new UserNotFoundException()).when(payManagementService)
    .payReservation(any()); // (2) any() 사용

```

**Step 3: 테스트 실행 (Act)**

```java
mockMvc.perform(...) ... // (3) API 호출
```

**Step 4: "아까 걔가 넘긴 거 가져와!" (Verify & Capture)**  
테스트가 끝난 뒤, Mock 객체에게 가서 따집니다.

```java
// "payReservation 호출됐지? 그때 들어온 파라미터(request) 내놔."
verify(payManagementService).payReservation(requestCaptor.capture()); // (4) 포획!
PayReservationRequest capturedRequest = requestCaptor.getValue(); // (5) 꺼내기
```

**Step 5: 정밀 검증 (Assert)**  
이제 꺼낸 객체(`capturedRequest`)가 내가 보낸 값과 같은지 하나하나 확인합니다.

```java
// "자, 이제 알맹이를 까보자."
assertThat(capturedRequest.getLoginId()).isEqualTo("invalidUser");
assertThat(capturedRequest.getAmount()).isEqualTo(10000);
```

---

#### 근데 난 모든 필드를 비교해야하는데, equals 보다 비용이 더 나가는거 아닌가?


비용 1. **컴퓨터가 일하는 비용 (Runtime Performance):** 사실 이건 무시해도 됩니다. 
테스트 단계에서 필드 몇 개 더 비교한다고 컴퓨터가 힘들어하지 않습니다.

비용 2. **개발자가 코드를 짜는 비용 (Maintenance/Development Cost):** 
**이게 핵심입니다.** 멘티님 말씀대로 필드가 10개인데 `assertThat`을 10줄 쓰고 있으면 그건 **낭비**가 맞습니다. 

만약 equals 를 쓰려면 모든 객체에다가 equals 코드를 작성해야 한다.

- `usingRecursiveComparison`

AssertJ 라이브러리(스프링 부트 기본 포함)에는 **"객체의 주소 말고, 
안에 있는 필드 값을 재귀적으로 다 비교해줘"라는 기능이 있습니다.

```java
assertThat(capturedRequest) 
	.usingRecursiveComparison() // "주소 말고 필드값 비교해!" 
	.ignoringFields("createdAt") // (선택) "생성 시간은 다를 수 있으니까 봐줘" 
	.isEqualTo(expectedRequest);
```

####  verify.usingRecursiveAssertion 의 순서 문제

```java
@Test  
@DisplayName("결제를 하는데 없는 사용자 id 일 경우 UserNotFound Exception 을 ProblemDetail 형식으로 리턴")  
public void throw_UserNotFoundException_when_userIdIsWrong() throws Exception {  
    final String notValidLoginId = "notValidLoginId";  
  
    ReservationRequest requestWithNotValidLoginId = createValidReservationRequest();  
    requestWithNotValidLoginId.setLoginId(notValidLoginId);  
  
    doThrow(UserNotFoundException.class).when(payManagementService)  
       .payReservation(any());  
  
    verify(payManagementService).payReservation(requestCaptor.capture());  
    ReservationRequest capturedRequest = requestCaptor.capture();  
    assertThat(capturedRequest)  
       .usingRecursiveAssertion()  
       .isEqualTo(requestWithNotValidLoginId);  
  
    mockMvc  
       .perform(  
          post("/api/reservation/pay")  
             .contentType(MediaType.APPLICATION_JSON)  
             .content(objectMapper.writeValueAsString(requestWithNotValidLoginId)))  
       .andExpect(status().isNotFound())  
       .andExpect(jsonPath("$.statusCode").value(HttpStatus.NOT_FOUND.value()))  
       .andExpect(jsonPath("$.title").value("존재하지 않는 사용자"))  
       .andExpect(jsonPath("$.detail").value(String.format("%s id 를 가진 사용자가 없음", notValidLoginId)));  
}
```

그런데 이번엔 이런 오류가 터진다.

![[Screenshot 2025-12-18 at 8.33.18 PM.png]]

이건 또 뭔소리야?

->  "전화 자체가 안 왔음"

`Actually, there were zero interactions with this mock.`

이 문장이 범인입니다.  
멘티님이 짠 코드는 **"서비스가 호출되었는지 확인(`verify`)하고, 그때 넘긴 파라미터를 낚아채라(`capture`)"**는 뜻입니다.

그런데 Mockito가 말하길:

> "아니, `verify`고 `capture`고 나발이고, **`payManagementService.payReservation()` 메서드 자체가 호출된 적이 없는데?** (Zero interactions)"

라고 하는 겁니다. 서비스가 호출조차 안 됐으니 낚아챌(Capture) 파라미터도 없는 것이죠.

---


아니 근데 나는 실제로 저 메서드가 실행되는 걸 보는게 아니라,
해당 메서드에 내가 원하는 값의 파라미터가 진짜로 가는지를 확인하려고 하는 것이다.

실행이 되면 안된다!

근데 여기서 내가 착각하는게, 실행인데
우리가 @_MockBean_ 으로 mock 한 _PayManagementService_ 객체의 메서드의
실제 로직은 실행이 안되는건 맞으나

메서드가 실행자체는 되어야 한다. 
그래야 메서드가 실행될때 넘어간 값을 캡처를 하던말던 할 것이 아닌가. 
그러니까 순서를 바꾸면 된다.

```java

@Test  
@DisplayName("결제를 하는데 없는 사용자 id 일 경우 UserNotFound Exception 을 ProblemDetail 형식으로 리턴")  
public void throw_UserNotFoundException_when_userIdIsWrong() throws Exception {  
    final String notValidLoginId = "notValidLoginId";  
  
    ReservationRequest requestWithNotValidLoginId = createValidReservationRequest();  
    requestWithNotValidLoginId.setLoginId(notValidLoginId);  
  
    doThrow(UserNotFoundException.class).when(payManagementService)  
       .payReservation(any());  
  
    mockMvc  
       .perform(  
          post("/api/reservation/pay")  
             .contentType(MediaType.APPLICATION_JSON)  
             .content(objectMapper.writeValueAsString(requestWithNotValidLoginId)))  
       .andExpect(status().isNotFound())  
       .andExpect(jsonPath("$.statusCode").value(HttpStatus.NOT_FOUND.value()))  
       .andExpect(jsonPath("$.title").value("존재하지 않는 사용자"))  
       .andExpect(jsonPath("$.detail").value(String.format("%s id 를 가진 사용자가 없음", notValidLoginId)));  
      
    verify(payManagementService).payReservation(requestCaptor.capture());  
    ReservationRequest capturedRequest = requestCaptor.getValue();  
    assertThat(capturedRequest)  
       .usingRecursiveAssertion()  
       .isEqualTo(requestWithNotValidLoginId);  
  
}
```

mockMvc 가 perform 해야지만 비로소 서비스가 실행이 되는거니까.

#### wrong usage of Custom Handler (signature is wrong with parameter)


근데 이제는 UserNotFoundException 이 터져서 테스트가 실패했다.
분명 내가 이전에 선언한 GlobalExceptionHanlder 에서 해당 익셉션을 잡아야할텐데??

![[Screenshot 2025-12-18 at 8.47.27 PM.png]]

일단 handler 가 제대로 작동을 하지 않는다.

```java
@RestControllerAdvice  
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {  
  
    @ExceptionHandler(RuntimeException.class)  
    public ResponseEntity<Object> customExceptionHandler(Exception ex, @Nullable Object body, HttpHeaders headers,  
       HttpStatusCode statusCode, WebRequest request) {  
  
       if (ex instanceof ErrorResponse errorResponse) {  
          ProblemDetail detail = errorResponse.getBody();  
  
          if (request instanceof ServletWebRequest servletWebRequest) {  
             detail.setInstance(URI.create(servletWebRequest.getRequest().getRequestURI()));  
          }  
  
          return handleExceptionInternal(  
             ex,  
             detail,  
             errorResponse.getHeaders(),  
             errorResponse.getStatusCode(),  
             request  
          );  
       }  
  
       return super.handleExceptionInternal(ex, body, headers, statusCode, request);  
    }  
}
```

여기서 `customExceptionHandler` 의 파라미터가 문제가 된다.

내가 custom Exception handler 의 사용법을 잘못 알았나보다.

공식 문서 (https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ExceptionHandler.html)

에는 이렇게 되어있다.

Handler methods which are annotated with this annotation are allowed to have very flexible signatures. They may have parameters of the following types, in arbitrary order:

- An exception argument: declared as a general Exception or as a more specific exception. This also serves as a mapping hint if the annotation itself does not narrow the exception types through its [`value()`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ExceptionHandler.html#value\(\)). You may refer to a top-level exception being propagated or to a nested cause within a wrapper exception. Any cause level is exposed.
- Request and/or response objects (typically from the Servlet API). You may choose any specific request/response type, for example, `ServletRequest` / `HttpServletRequest`.
- Session object: typically `HttpSession`. An argument of this type will enforce the presence of a corresponding session. As a consequence, such an argument will never be `null`. _Note that session access may not be thread-safe, in particular in a Servlet environment: Consider switching the [`"synchronizeOnSession"`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.html#setSynchronizeOnSession\(boolean\)) flag to "true" if multiple requests are allowed to access a session concurrently._
- [`WebRequest`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/request/WebRequest.html "interface in org.springframework.web.context.request") or [`NativeWebRequest`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/request/NativeWebRequest.html "interface in org.springframework.web.context.request"). Allows for generic request parameter access as well as request/session attribute access, without ties to the native Servlet API.
- [`Locale`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Locale.html "class or interface in java.util") for the current request locale (determined by the most specific locale resolver available, i.e. the configured [`LocaleResolver`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/LocaleResolver.html "interface in org.springframework.web.servlet") in a Servlet environment).
- [`InputStream`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/InputStream.html "class or interface in java.io") / [`Reader`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Reader.html "class or interface in java.io") for access to the request's content. This will be the raw InputStream/Reader as exposed by the Servlet API.
- [`OutputStream`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/OutputStream.html "class or interface in java.io") / [`Writer`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Writer.html "class or interface in java.io") for generating the response's content. This will be the raw OutputStream/Writer as exposed by the Servlet API.
- [`Model`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/ui/Model.html "interface in org.springframework.ui") as an alternative to returning a model map from the handler method. Note that the provided model is not pre-populated with regular model attributes and therefore always empty, as a convenience for preparing the model for an exception-specific view.

그러니까 시그니처가 잘못되어서 스프링이 핸들러로 인지를 못하는 것.



```java
@RestControllerAdvice  
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {  
  
    @ExceptionHandler(RuntimeException.class)  
    public ResponseEntity<Object> customExceptionHandler(Exception ex, WebRequest request) throws Exception {  
  
       if (ex instanceof ErrorResponse errorResponse) {  
          ProblemDetail detail = errorResponse.getBody();  
  
          if (request instanceof ServletWebRequest servletWebRequest) {  
             detail.setInstance(URI.create(servletWebRequest.getRequest().getRequestURI()));  
          }  
  
          return handleExceptionInternal(  
             ex,  
             detail,  
             errorResponse.getHeaders(),  
             errorResponse.getStatusCode(),  
             request  
          );  
       }  
  
       return super.handleException(ex, request);  
    }  
}
```

이렇게 수정하니 핸들러가 캐치하게 되었다.


#### doThrow(CustomException.class) 에서의 주의할 점



이번에는 UserNotFoundException 의 getBody 시 HttpStatusCode 가 null 인게 문제가 된다.


![[Screenshot 2025-12-18 at 9.10.35 PM.png]]

이게 왜이러냐면,  class 로 호출하면 생성자가 호출이 안되기 때문이다.

```java
  
public class UserNotFoundException extends RuntimeException implements ErrorResponse {  
    private final String loginId;  
    private final HttpStatus httpStatus;  
  
    public UserNotFoundException(ReservationRequest request) {  
       super("사용자 조회 안됨 - login Id : " + request.getLoginId());  
       this.loginId = request.getLoginId();  
       this.httpStatus = HttpStatus.NOT_FOUND;  
    }  
  
    @Override  
    @NonNull    public HttpStatusCode getStatusCode() {  
       return this.httpStatus;  
    }  
  
    @Override  
    @NonNull    public ProblemDetail getBody() {  
       ProblemDetail detail = ProblemDetail.forStatusAndDetail(this.httpStatus,  
          String.format("%s id 를 가진 사용자가 없음", this.loginId));  
       detail.setTitle("존재하지 않는 사용자");  
  
       return detail;  
    }  
}
```

내 코드에서 생성자가 호출되어야 httpStatus 가 설정되는데, 
그냥 저기서 doThrow(UserNotFoundException.class) 를 하면
생성자가 호출이 제대로 안될테니 httpStatus 필드가 설정이 안되고
그러니까 getBody 에서 httpStatus 코드가 정해지지 않는 것이다.

그래서 이렇게 수정하니 되었다.

```java
doThrow(new UserNotFoundException(requestWithNotValidLoginId)).when(payManagementService)  
    .payReservation(any());
```

그리고 드디어 에러가 리턴되었다. 

그리고 드디어 ProblemDetail 에 해당하는 리턴 json 의 값이 잘들어갔다.

```java
mockMvc  
    .perform(  
       post("/api/reservation/pay")  
          .contentType(MediaType.APPLICATION_JSON)  
          .content(objectMapper.writeValueAsString(requestWithNotValidLoginId)))  
    .andExpect(status().isNotFound())  
    .andExpect(jsonPath("$.status").value(HttpStatus.NOT_FOUND.value()))  
    .andExpect(jsonPath("$.title").value("존재하지 않는 사용자"))  
    .andExpect(jsonPath("$.detail").value(String.format("%s id 를 가진 사용자가 없음", notValidLoginId)));
```

![[Screenshot 2025-12-18 at 9.24.19 PM.png]]


근데 이번에는 또 캡처하는데에서 ReservationRequest 의 메모리가 달라서 AssertThat 이 실패한다.

```java
ReservationRequest capturedRequest = requestCaptor.getValue();  
assertThat(capturedRequest)  
    .usingRecursiveAssertion()  
    .isEqualTo(requestWithNotValidLoginId);
```

메모리 주소가 같을 필요가 없는데... 근데 분명 나는 usingRecursiveAssertion 이걸로 값비교만 한댔는데...

알고보니 `usingRecursiveAssertion` 은 비교적 최신에 추가된 기능이며
객체 타입에 따라 재귀적으로 equals 를 호출해버리는 경우가 있다고 한다.

그래서 순전히 필드값만 비교하려고 한다면 `usingRecursiveComparison` 를 쓰면 된다.

그리고 드디어 테스트에 통과하였다.


## Concurrency Control in PostgreSQL - MVCC, S2PL, OCC (2)



### Inserting, Deleting and Updating Tuples

https://www.interdb.jp/pg/pgsql05/03.html


![[Screenshot 2025-12-15 at 3.40.35 AM.png|700]]


#### Insertion

![[Screenshot 2025-12-15 at 3.40.56 AM.png|700]]

데이터를 insert 할때, 대상이 되는 테이블의 페이지에 바로 새로운 tuple 이 생성된다.
txid 가 99인 트랜잭션에 의해 해당 tuple 이 insert (생성) 된다고 했을때
해당 tuple 의 헤더는 위와같이 생성된다.

t_xmin 에는 해당 튜플을 생성한 transaction 의 id가, 
t_max 에는 0 이 (아직 튜플이 업데이트되거나 삭제되지 않았다는 것을 의미, invalid)
t_cid 에는 0이 (해당 트랜잭션의 첫번째 statement 에서 추가됨을 의미)
t_ctid 에는 (0, 1) 이 설정되는데 이는 자기 스스로를 뜻하고, 이 tuple 이 해당 데이터의 대한 가장 마지막 버전이기때문에 그렇다.
	(0, 1) 의 0과 1이 각각 무엇을 의미하는지는 아직 불명


#### Deletion




## PostgreSQL 의 Table-Level Lock

여기서 row 라는 단어가 들어간다 하더라도 테이블 레벨 락임을 명심해야 함

https://www.postgresql.org/docs/current/explicit-locking.html
https://www.perplexity.ai/search/https-www-postgresql-org-docs-nklBUqytQ2eyuvRPNkRKXQ

### ACCESS SHARE



### ROW SHARE



### ROW EXCLUSIVE


### SHARE UPDATE EXCLUSIVE


### SHARE (ShareLock)


### SHARE ROW EXCLUSIVE


### Exclusive


### Access Exclusive






## PostgreSQL 의 Row-Level Locks


### FOR UPDATE


### FOR NO KEY UPDATE


### FOR SHARE



### FOR KEY SHARE


## Page Level Locks


