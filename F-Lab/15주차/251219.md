## Consumer, BiConsumer

- 이게 나오게 된 이유

내 테스트 코드에서 이게 중복이 된다.

```java
// 이게 중복이 된다!
verify(payManagementService).payReservation(requestCaptor.capture());  
verifyValuesAreEqual(requestCaptor.getValue(), requestWithNotValidLoginId);

public <T> void verifyValuesAreEqual(T capturedObject, T targetObject) {  
    assertThat(capturedObject)  
       .usingRecursiveComparison()  
       .isEqualTo(targetObject);  
}
```

이걸 한 문장으로 줄일 순 없을까? 가 발단이다.

해답은 다음과 같다.

```java
public <T, E> void assertMethodParameterEquals(T mockClass, BiConsumer<T, E> targetMethod,  
    ArgumentCaptor<E> captor, E targetObject) {  
    targetMethod.accept(verify(mockClass), captor.capture());  
  
    assertThat(captor.getValue())  
       .usingRecursiveComparison()  
       .isEqualTo(targetObject);  
}
```

근데 이게 정리가 필요하다. 항상 BiConsumer 가 내가 원하는 방향대로 동작하지 않는다.

그리고 나의 목표는 이것이다.

> BiConsumer 는 리턴값이 없는 경우인데, 리턴값이 있는 경우도 포함시키려면?
> 애초에 나는 파라미터가 같은지만 관심이 있고 호출이 되는지 안되는지, 그 리턴값에는 전혀 관심이 없기 때문이다.

이걸 위해서 _Statement Expression_ 과 _Void Compatibility_ 를 알아야 한다고 한다.

일단 Consumer 와 BiConsumer 에 대해 먼저 정리가 필요하다.


### Consumer, BiConsumer, BiFunction, Predicate

```java
Consumer<Thread> myMethod = ?;

myMethod.accept(A)
// -> A.myMethod() 
```

Consumer 는 리턴값이 없는, accept 의 단일 파라미터가 주체가 되면서 실행되게끔 하는 Functional Interafce 이다.

- Functional Interface ?

Java 에서는 객체 밖에 없고 Function 이라는 타입 자체가 없다.
그래서 Function 을 객체처럼 다루기 위한 interface 이다.

함수를 담기때문에 @FunctionalInterface 가 적용된 인터페이스는 
메서드가 하나밖에 없다. (함수 그 자체이기 때문이다)

BiConsumer 는 리턴값이 void 이고 파라미터가 2개이다.

```java
...

assertMethodParameterEquals(payManagementService, PayManagementService::payReservation, requestCaptor,  
       requestWithNotValidLoginId);  
}  
  
public <T, E> void assertMethodParameterEquals(T mockClass, BiConsumer<T, E> targetMethod,  
    ArgumentCaptor<E> captor, E targetObject) {  
    targetMethod.accept(verify(mockClass), captor.capture());  
  
    assertThat(captor.getValue())  
       .usingRecursiveComparison()  
       .isEqualTo(targetObject);  
}
```

여기서 verify(MockClass) 는 mock 객체를 리턴한다. 
우리가 verify 를 사용할때

```java
verify(MockClass).methodOfMockClass (captor..capture())
```

이런 식으로 사용하기 때문에 targetMethod.accpet 를 사용하게 된다.
첫번째 파라미터가 메서드를 실행하는 주체이다. 나머지는 메서드의 파라미터이다.

BiFunction 은 BiConsumer 와 같이 파라미터가 2개인데 리턴값이 있는 경우다.

```java
BiFunction<String, String, Boolean> equalMethod = String::equals;  
print(equalMethod.apply("hello", "hello"));
```
BiFunction 은 accept 대신에 apply 를 사용한다.

그리고 @FunctionalInterface 는 함수를 담는 그릇이기 떄문에
Lambda Excpression 으로 정의가 가능하다.

```java
BiFunction<Integer, Integer, Integer> myAdd = (a, b) -> {  
    return a + b;  
};
```


Predicate 도 있는데 이건 입력하나를 받으면 Boolean 을 리턴하는 함수 인터페이스이다.
```java
Predicate<Integer> isGreaterThan10 = (a) -> {  
    return a > 10;  
};
```

| 인터페이스            | 입력      | 출력      | 언제 쓰나?                                                                                                                                 |
| ---------------- | ------- | ------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| Predicate<T>     | T 하나    | boolean | "이게 맞아? (Yes/No)" – 필터링 [](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)​                               |
| Consumer<T>      | T 하나    | void    | "이걸 처리해(먹고 끝)" – print, add [](https://dzone.com/articles/be-more-functional-javas-functional-interfaces)​                             |
| Function<T,R>    | T 하나    | R       | "이걸 바꿔줘(변환)" – map [](https://dzone.com/articles/be-more-functional-javas-functional-interfaces)​                                      |
| BiPredicate<T,U> | T,U 두 개 | boolean | "A와 B 비교해? (Yes/No)" – 2개 조건 [](http://adnjavainterview.blogspot.com/2019/05/java-8-biconsumer-bifunction-bipredicate-interface.html)​ |


자, 그래서, 내 문제로 돌아오면....

### BiConsumer, BiConsumer 모두를 포함시키고 싶은데.

```java
public <T, E> void assertMethodParameterEquals(T mockClass, BiConsumer<T, E> targetMethod,  
    ArgumentCaptor<E> captor, E targetObject) {  
    targetMethod.accept(verify(mockClass), captor.capture());  
  
    assertThat(captor.getValue())  
       .usingRecursiveComparison()  
       .isEqualTo(targetObject);  
}
```

나의 코드에선느 targetMethod 가 리턴값이 없어야 대입할 수 있다.
그런데 하다보면 리턴값이 존재하는 메서드를 테스트해야 할 수도 있다.

이때 오버로딩을 쓰면 되겠지만, 이걸 합치는 방법은 없을까?
어차피 내 테스트에서는 넘어간 파라미터가 제대로 넘어갔는지만 중요하지
메서드의 리턴값이 void 든 어떤 값이든 아무 상관 없기 때문이다.

이 문제를 해결하기 위해 2가지 내용을 공부해야 한다고 한다.

1. Functional Interface Hierarchy
2. Mockito's Verification with Return Values


#### void-compatible, value compatible

**JLS 21 (Java Language Specification, Java SE 21 Edition)** §15.27.2. Lambda Body 에서
 
``` java
// A block lambda body is void-compatible if every return statement in the block has the form return;. 

// A block lambda body is value-compatible if it cannot complete normally (§14.22) and every return statement in the block has the form return Expression;. 
// It is a compile-time error if a block lambda body is neither void-compatible nor value-compatible. 

// In a value-compatible block lambda body, the result expressions are any expressions that may produce an invocation's value. 

// Specifically, for each statement of the form return Expression ; contained by the body, the Expression is a result expression. 

// The following lambda bodies are void-compatible: 
	() -> {};
	() -> { 
		System.out.println("done"); 
	} 
// These are value-compatible: 
	() -> {  
	    return "done";  
	}  
	() -> {  
	    if (...)  return 1;  
		else  return 0;  
	}
 // These are both: 
	 () -> { 
		 throw new RuntimeException(); 
	 } 
	 () -> { 
		 while (true); 
	 } 
 // This is neither: 
	 () -> {
		  if (...) return "done"; 
		  System.out.println("done"); 
	  }
```












## Concurrency Control in PostgreSQL - MVCC, S2PL, OCC (2)



### Inserting, Deleting and Updating Tuples

https://www.interdb.jp/pg/pgsql05/03.html


![[Screenshot 2025-12-15 at 3.40.35 AM.png|700]]

tuple 이 업데이트 되거나 insert 될때 FSM (Free Space Map) 이라는 공간을 사용하게 된다.
FSM 은 페이지해서 + tuple pointer 의 배열의 가장 마지막 주소~tuple의 가장 첫번째 주소 이 사이 공간이다.


#### Insertion

![[Screenshot 2025-12-15 at 3.40.56 AM.png|700]]

데이터를 insert 할때, 대상이 되는 테이블의 페이지에 바로 새로운 tuple 이 생성된다.
txid 가 99인 트랜잭션에 의해 해당 tuple 이 insert (생성) 된다고 했을때
해당 tuple 의 헤더는 위와같이 생성된다.

t_xmin 에는 해당 튜플을 생성한 transaction 의 id가, 
t_max 에는 0 이 (아직 튜플이 업데이트되거나 삭제되지 않았다는 것을 의미, invalid)
t_cid 에는 0이 (해당 트랜잭션의 첫번째 statement 에서 추가됨을 의미)
t_ctid 에는 (0, 1) 이 설정되는데 이는 자기 스스로를 뜻하고, 이 tuple 이 해당 데이터의 대한 가장 마지막 버전이기때문에 그렇다.
	(0, 1) 의 0과 1이 각각 무엇을 의미하는지는 아직 불명 -> 다음 버전의 tuple 을 가리키는데 쓰인다


#### Deletion

![[Screenshot 2025-12-19 at 6.43.00 PM.png|700]]

delete operation 에서는 delete 가 logically  하게 일어난다 (not phisically. 그러니까 바로 page 에서 물리적으로 안날라간다는 소리다)

tuple이 delete 되면 t_max 에 txid (트랜잭션의 아이디) 로 업데이트 되고 이 tuple 은 unneeded tuple 로 간주되며 
이러한 tuple 들을 dead tuples 라고 한다.

dead tuples 은 VACCUM 이라는 작업을 통해 페이지에서 지워진다.


#### Update

![[Screenshot 2025-12-19 at 6.46.55 PM.png|700]]

얘도 마찬가지로 logically 하게 실행된다.
일단 logically 하게 latedt tuple, 특정 데이터의 가장 마지막 tuple 이 logically 하게 지워지고 (t_max 에 txid 가 대입됨) 
새로운 tuple 이 페이지에 insert 된다.

위 예시대로 'A' 라는 데이터가 들어가 있는 tuple 을 100 의 txid 를 가진 트랜잭션이 2번 업데이트 된다고 가정해보자.

첫번째 update 가 발생하면 'A' 가 들어가있던 첫번째 tuple 의 t_xmax 에 100 이 업데이트 되고 (update 하는 트랜잭션의 txid)
2번쨰 tuple 이 insert 된다. 

정리하면

- Tuple_1:
    
    - **t_xmax** is set to 100.
    - **t_ctid** is rewritten from (0, 1) to (0, 2).
- Tuple_2:
    
    - **t_xmin** is set to 100.
    - **t_xmax** is set to 0.
    - **t_cid** is set to 0.
    - **t_ctid** is set to (0,2).

2번째로 update 가 되면 세번째 tuple 이 insert 되고

- Tuple_2:
    
    - **t_xmax** is set to 100.
    - **t_ctid** is rewritten from (0, 2) to (0, 3).

- Tuple_3:
    
    - **t_xmin** is set to 100.
    - **t_xmax** is set to 0.
    - **t_cid** is set to 1.
    - **t_ctid** is set to (0,3).

txid 100 이 commit 되고 나면 첫번째 tuple 과 두번째 tuple 이 dead tuple 이 된다.
만약 위 트랜잭션 - txid 100 의 2번 업데이트 하는 트랜잭션이 aborted 된다면
두번쨰 튜플과 3번째 튜플이 dead tuple 이 된다.

여기서 알아두어야 할 점은 t_ctid 의 뒤 번호가 해당 데이터의 버전이 아니라는 것이다.
t_ctid 는 (block, offset) 이다.
맨처음에 tuple 이 insert 될때 (0, 1) 로 등록된다면
0 -> tuple 이 삽입된 페이지의 블럭의 번호 이고, 1 이라 함은 해당 블록에서 몇번째 인지 알려주는 offset 이다.

그래서 t_max 가 0일때는 t_ctid 는 (0,1) 그냥 맨처음의 데이터가 존재하는 위치가 된다.
이떄 t_max 가 업데이트 되면 이전 tuple 이 t_ctid 는 새로 생성된 block + offset 의 값으로 업데이트 된다.

이런식으로 버전을 추적하는 것이다.




## PostgreSQL 의 Table-Level Lock

여기서 row 라는 단어가 들어간다 하더라도 테이블 레벨 락임을 명심해야 함

https://www.postgresql.org/docs/current/explicit-locking.html
https://www.perplexity.ai/search/https-www-postgresql-org-docs-nklBUqytQ2eyuvRPNkRKXQ

### ACCESS SHARE

Conflicts with the `ACCESS EXCLUSIVE` lock mode only.

The `SELECT` command acquires a lock of this mode on referenced tables. 
In general, any query that only _reads_ a table and does not modify it will acquire this lock mode.


이게 도대체 뭔소리야 ??

postgreSQL 에서 insert, delete, update 가 어떻게 되는지 알면 이해할 수 있을줄 알았는데 여전히 모르겠다.

일단 내가 이해한 바로는 일반적으로 어떤 테이블에 ACCESS SHARE LOCK 을 걸면 
다른 트랜잭션이 해당 테이블에 대해서 읽을때
그 테이블을 수정하지 않고 읽기만 하는 트랜잭션은 이 ACCESS SHARE LOCK 을 얻을 수 있다고 이해했다.


### ROW SHARE

Conflicts with the `EXCLUSIVE` and `ACCESS EXCLUSIVE` lock modes.

The `SELECT` command acquires a lock of this mode on all tables on which one of the `FOR UPDATE`, `FOR NO KEY UPDATE`, `FOR SHARE`, or `FOR KEY SHARE` options is specified (in addition to `ACCESS SHARE` locks on any other tables that are referenced without any explicit `FOR ...` locking option).


### ROW EXCLUSIVE

Conflicts with the `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes.

The commands `UPDATE`, `DELETE`, `INSERT`, and `MERGE` acquire this lock mode on the target table (in addition to `ACCESS SHARE` locks on any other referenced tables). In general, this lock mode will be acquired by any command that _modifies data_ in a table.


### SHARE UPDATE EXCLUSIVE

Conflicts with the `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode protects a table against concurrent schema changes and `VACUUM` runs.

Acquired by `VACUUM` (without `FULL`), `ANALYZE`, `CREATE INDEX CONCURRENTLY`, `CREATE STATISTICS`, `COMMENT ON`, `REINDEX CONCURRENTLY`, and certain [`ALTER INDEX`](https://www.postgresql.org/docs/current/sql-alterindex.html "ALTER INDEX") and [`ALTER TABLE`](https://www.postgresql.org/docs/current/sql-altertable.html "ALTER TABLE") variants (for full details see the documentation of these commands).


### SHARE (ShareLock)

Conflicts with the `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode protects a table against concurrent data changes.

Acquired by `CREATE INDEX` (without `CONCURRENTLY`).


### SHARE ROW EXCLUSIVE

Conflicts with the `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode protects a table against concurrent data changes, and is self-exclusive so that only one session can hold it at a time.

Acquired by `CREATE TRIGGER` and some forms of [`ALTER TABLE`](https://www.postgresql.org/docs/current/sql-altertable.html "ALTER TABLE").


### Exclusive

Conflicts with the `ROW SHARE`, `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode allows only concurrent `ACCESS SHARE` locks, i.e., only reads from the table can proceed in parallel with a transaction holding this lock mode.

Acquired by `REFRESH MATERIALIZED VIEW CONCURRENTLY`.


### Access Exclusive

Conflicts with locks of all modes (`ACCESS SHARE`, `ROW SHARE`, `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE`). This mode guarantees that the holder is the only transaction accessing the table in any way.

Acquired by the `DROP TABLE`, `TRUNCATE`, `REINDEX`, `CLUSTER`, `VACUUM FULL`, and `REFRESH MATERIALIZED VIEW` (without `CONCURRENTLY`) commands. Many forms of `ALTER INDEX` and `ALTER TABLE` also acquire a lock at this level. This is also the default lock mode for `LOCK TABLE` statements that do not specify a mode explicitly.

### Conflicting Lock Modes

|Requested Lock Mode|Existing Lock Mode|   |   |   |   |   |   |   |
|---|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|`ACCESS SHARE`|`ROW SHARE`|`ROW EXCL.`|`SHARE UPDATE EXCL.`|`SHARE`|`SHARE ROW EXCL.`|`EXCL.`|`ACCESS EXCL.`|
|---|---|---|---|---|---|---|---|
|`ACCESS SHARE`||||||||X|
|`ROW SHARE`|||||||X|X|
|`ROW EXCL.`|||||X|X|X|X|
|`SHARE UPDATE EXCL.`||||X|X|X|X|X|
|`SHARE`|||X|X||X|X|X|
|`SHARE ROW EXCL.`|||X|X|X|X|X|X|
|`EXCL.`||X|X|X|X|X|X|X|
|`ACCESS EXCL.`|X|X|X|X|X|X|X|X|


## PostgreSQL 의 Row-Level Locks


### FOR UPDATE


### FOR NO KEY UPDATE


### FOR SHARE



### FOR KEY SHARE


## Page Level Locks


