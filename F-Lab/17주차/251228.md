# Hexagonal Architecture


## poor domain model vs Hexagonal architecture

### poor domain model

```java
// JPA 엔티티 = 도메인 같이 쓰는 방식
@Entity
@Table(name = "orders")
public class OrderEntity {

    @Id @GeneratedValue
    private Long id;

    @Enumerated(EnumType.STRING)
    private OrderStatus status;

    private boolean shippingStarted;

    private BigDecimal totalAmount;

    private BigDecimal couponDiscount;

    // getter/setter만 있는 전형적인 구조
}

@Service
public class OrderService {

    private final OrderRepository orderRepository;  // Spring Data JPA
    private final PaymentClient paymentClient;
    private final EventPublisher eventPublisher;

    @Transactional
    public void cancelOrder(Long orderId) {
        OrderEntity order = orderRepository.findById(orderId)
                .orElseThrow(() -> new IllegalArgumentException("not found"));

        // 상태/규칙이 서비스에 잔뜩
        if (order.getStatus() != OrderStatus.PAID) {
            throw new IllegalStateException("not paid");
        }
        if (order.isShippingStarted()) {
            throw new IllegalStateException("already shipped");
        }

        BigDecimal refundAmount =
                order.getTotalAmount().subtract(order.getCouponDiscount()); // 단순 예

        paymentClient.refund(order.getId(), refundAmount);

        order.setStatus(OrderStatus.CANCELLED);

        eventPublisher.publish(
                new OrderCancelledEvent(order.getId(), refundAmount)
        );
    }
}
```


### DDD

```java
// 도메인 모델 (JPA 모름)
public class Order {

    private final OrderId id;
    private OrderStatus status;
    private boolean shippingStarted;
    private Money totalAmount;
    private Money couponDiscount;

    // 생성 시에도 규칙을 넣을 수 있음
    public Order(OrderId id,
                 OrderStatus status,
                 boolean shippingStarted,
                 Money totalAmount,
                 Money couponDiscount) {
        this.id = id;
        this.status = status;
        this.shippingStarted = shippingStarted;
        this.totalAmount = totalAmount;
        this.couponDiscount = couponDiscount;
    }

    public OrderId getId() { return id; }

    public boolean canBeCancelled() {
        if (status != OrderStatus.PAID) {
            return false;
        }
        if (shippingStarted) {
            return false;
        }
        return true;
    }

    public Money calculateRefundAmount(Clock clock) {
        // 예: 특정 시간 이후에는 수수료 차감, 쿠폰 처리 등
        Money base = totalAmount.minus(couponDiscount);
        // 시간/정책에 따라 더 복잡한 로직 가능
        return base;
    }

    public OrderCancelled cancel(Clock clock) {
        if (!canBeCancelled()) {
            throw new IllegalStateException("Order cannot be cancelled");
        }
        Money refund = calculateRefundAmount(clock);
        this.status = OrderStatus.CANCELLED;
        return new OrderCancelled(this.id, refund);
    }
}

// 도메인 이벤트
public record OrderCancelled(OrderId orderId, Money refundAmount) {}

// 애플리케이션 서비스 (유즈케이스)
public class CancelOrderService {

    private final OrderRepository orderRepository;      // 도메인 기준 포트
    private final PaymentPort paymentPort;              // 외부 결제 시스템 포트
    private final DomainEventPublisher eventPublisher;  // 이벤트 포트
    private final Clock clock;

    public CancelOrderService(OrderRepository orderRepository,
                              PaymentPort paymentPort,
                              DomainEventPublisher eventPublisher,
                              Clock clock) {
        this.orderRepository = orderRepository;
        this.paymentPort = paymentPort;
        this.eventPublisher = eventPublisher;
        this.clock = clock;
    }

    @Transactional
    public void cancelOrder(OrderId orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new IllegalArgumentException("not found"));

        OrderCancelled event = order.cancel(clock); // 도메인 로직 + 이벤트 생성

        paymentPort.refund(order.getId(), event.refundAmount());

        orderRepository.save(order);

        eventPublisher.publish(event);
    }
}



```


여기서 핵심 차이:

- 상태 전이 규칙(canBeCancelled, cancel)이 모두 Order 안에 모여 있음.
- 환불 금액 계산, 시간 의존 로직이 도메인에서 한 군데에 모여 있음.
- 서비스는 “유즈케이스 흐름 조립 + 포트 호출” 정도만 담당.

그리고 JPA는 이 도메인을 저장하기 위한 별도 엔티티/어댑터에서만 사용:


```java
// JPA 엔티티 (테이블 매핑용)
@Entity
@Table(name = "orders")
public class OrderEntity {

    @Id @GeneratedValue
    private Long id;

    @Enumerated(EnumType.STRING)
    private OrderStatus status;

    private boolean shippingStarted;

    private BigDecimal totalAmount;

    private BigDecimal couponDiscount;

    // JPA 기본 생성자 + getter/setter
}

// 매퍼
class OrderMapper {

    Order toDomain(OrderEntity entity) {
        return new Order(
                new OrderId(entity.getId()),
                entity.getStatus(),
                entity.isShippingStarted(),
                Money.of(entity.getTotalAmount()),
                Money.of(entity.getCouponDiscount())
        );
    }

    OrderEntity toEntity(Order order) {
        OrderEntity entity = new OrderEntity();
        entity.setId(order.getId().value());
        entity.setStatus(order.getStatus());
        entity.setShippingStarted(order.isShippingStarted());
        entity.setTotalAmount(order.getTotalAmount().toBigDecimal());
        entity.setCouponDiscount(order.getCouponDiscount().toBigDecimal());
        return entity;
    }
}

// 영속성 어댑터 (포트 구현)
@Component
public class OrderPersistenceAdapter implements OrderRepository {

    private final SpringDataOrderRepository jpaRepository;
    private final OrderMapper mapper;

    @Override
    public Optional<Order> findById(OrderId id) {
        return jpaRepository.findById(id.value())
                .map(mapper::toDomain);
    }

    @Override
    public void save(Order order) {
        jpaRepository.save(mapper.toEntity(order));
    }
}
```


## DDD vs Hexagonal Architecture

- DDD (Domain-Driven Design): **"무엇(What)"**을 만들 것인가? (비즈니스 문제 해결, 도메인 모델링)
- Hexagonal Architecture: "어떻게(How)" 구조를 짤 것인가? (기술적 격리, 코드 배치 전략)

멘티님이 헷갈려하는 이유는, 이 둘이 실무에서 거의 항상 세트 메뉴처럼 같이 쓰이기 때문입니다. DDD를 제대로 하려다 보니 Hexagonal 구조가 필요해지는 것이죠.

1. DDD (도메인 주도 설계)
"개발자가 아니라, 비즈니스 전문가의 언어로 코드를 짜는 것"

DDD는 아키텍처라기보다는 소프트웨어 개발 철학에 가깝습니다. 
복잡한 비즈니스 로직을 소프트웨어로 풀어내기 위해, 기획자나 현업 담당자가 쓰는 용어(Ubiquitous Language)를 코드에 그대로 녹여내는 과정입니다.
​

핵심: 코드가 비즈니스 현실을 그대로 반영해야 한다.

목표: 복잡한 비즈니스 로직을 명확하게 모델링하는 것.

주요 개념: Bounded Context(경계 설정), Entity, Aggregate, Ubiquitous Language.

멘토의 한마디: "쇼핑몰을 만드는데 OrderService 안에서 SQL 쿼리 짜느라 머리 싸매고 있다면 그건 DDD가 아닙니다. DDD는 '주문 취소 시 쿠폰은 어떻게 반환할지' 같은 비즈니스 규칙에 집중하는 것입니다."

2. Hexagonal Architecture (헥사고날 아키텍처)
"비즈니스 로직을 외부 기술(DB, 웹, UI)로부터 철저히 격리시키는 기술적 구조"

다른 말로 Ports and Adapters 패턴이라고도 합니다. 핵심은 "내부(도메인)"는 "외부(인프라)"를 몰라야 한다는 것입니다. 데이터베이스가 MySQL이든 Oracle이든, 웹 요청이 REST API로 오든 CLI로 오든, 핵심 비즈니스 로직은 전혀 영향을 받지 않도록 만드는 구조적 패턴입니다.
​

핵심: 의존성의 방향이 무조건 외부 → 내부로 향해야 한다. (내부가 외부를 import 하면 안 됨)

목표: 테스트 용이성 확보, 외부 기술 교체의 유연성.

주요 개념: Port(인터페이스), Adapter(구현체).

멘토의 한마디: "DB를 바꿨다고 비즈니스 로직 코드를 수정해야 한다면, 그건 구조를 잘못 짠 겁니다. 헥사고날은 이런 불상사를 막기 위한 안전장치입니다."

3. 둘은 어떤 관계인가요? (Why Together?)
DDD의 핵심인 **'순수한 도메인 모델'**을 지키기 위해 헥사고날 아키텍처라는 방패가 필요합니다.

| 구분      | DDD (도메인 주도 설계)           | Hexagonal Architecture           |
| ------- | ------------------------- | -------------------------------- |
| **관심사** | **비즈니스 문제** (주문, 결제 로직 등) | **기술적 구조** (의존성 분리, 계층화)         |
| **질문**  | "이 비즈니스 규칙이 코드에 잘 반영되었나?" | "DB를 바꿔도 코어 로직이 안전한가?"           |
| **역할**  | **왕 (King)**: 시스템의 핵심 가치  | **성벽 (Castle)**: 왕을 외부 침입으로부터 보호 |

보통 실무에서는 DDD로 도메인 모델을 정의하고, 이 모델이 DB나 웹 프레임워크에 오염되지 않도록 헥사고날 아키텍처로 감싸서 보호합니다


## Aggregate


