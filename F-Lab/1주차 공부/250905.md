

## 자바 자료구조 크게 4가지

- list
- queue
- map
- set



## 객체란 무엇인가

==new==

클래스 그 자체로는 아무것도 할 수 없음.
객체는 클래스의 생성자로부터 생성되며, 클래스가 가지고 있는 상태와 행동을 그대로 이어받음.
같은 클래스에서 나온 객체라도 서로다른 상태와 행동을 가질 수 있음.

==생성자==

예를들어 Car 라는 클래스가 있을때, 벤츠도 있고 BMW 도 있을것.
이럴때 벤츠 클래스, BMW 클래스 따로 만들어야 하는가?

공통된 속성과 행동을 Car 라는 클래스에 정의, 객체를 생성할때 차의 종류를 상태에 선언해주면 될 일.

```java
Car dogCar = new Car();
// dogCar --> Car@9807454
```

>9807454 는 객체 id 일까 ?
>	
>	>그렇다면 다른 쓰레드끼리는 충돌이 안나나 ? 어떻게 관리하지 ?





## 클래스란 무엇인가



자바에서 모든 메소드들은 어딘가에 '속해' 있어야 함.
-> ==class==

==클래스의 조건== -> ==상태== (status) 와 ==행동== (behavior) -> 둘 다 반드시 있어야 하는 것은 아님.

==생성자==





## 메소드란 무엇인가

> 메소드에 대한 소개가 '왜' 나왔을까 책에서?

컴퓨터를 사용하는 이유 -> 어떠한 동작을 우리대신 수행하게 하기 위함. -> 프로그래밍

'프로그램' -> 어떠한 값을 넣으면 어떠한 결과값을 내는 무언가.
이를 위해 언어가 필요함. 시켜야 하니까.
그런데 사람이 자연어로 컴퓨터한테 지시할 수 없음 (지금은 ai 때문에 어느정도는 가능하지만, 원래는)
->  Programming Language

'입력 -> 동작 -> 결과'

이를 java 에서 표현하는 것이 ==method==

입력하는 값 : parameter
모든값에는 ==type== 이 있다.



> [!tip] 메소드의 구성요소 
> 제어자 (modifer) + 리턴타입 + 메소드 이름 + 파라미터 리스트 + 예외 목록 + 메소드 내용

==\===
==;==
==indent==

==예약어==


## 자바의 컴파일 단계

자바 소스코드 -> 바이트 코드 (.class, 바이너리) -> JVM -> 기계어


## 변수

==정보를 담을 공간==

### 변수의 4가지 종류

- 메소드를 사용하기 위한 -> 파라미터
- 코드 블록 내에서만 사용하기 위한
	- -> 코드 블록 내에서만 사용하게 되면 다른 공간에서 변수명이 같아도 달리 쓸 수 있음 (이름의 재사용성 가능)
	- -> 메모리 낭비를 줄일 수 있음
	- nested code block 에서는 안됨 (재정의 불가), 같은 레벨에서의 서로 다른 code block 에서만 재선언가능.
	- -> 지역 변수
- 객체의 상태로써 사용하기 위한 클래스 내 메서드 밖에 선언되어 있는 -> 인스턴스 변수
- 클래스가 존재하는 한 사용하기 위한, 클래스 내 메서드 밖에 선언되어 있는 -> 클래스 변수


### 초기화

지역변수는 사용하기 전에 무조건 초기화가 필요함 -> 인스턴스 변수는 안해도 컴파일 에러가 안남.

인스턴스 변수 초기화 없이 사용 -> 0, 0.0 , false 등등이 기본값

지역변수, 정적변수, 인스턴스 변수 모두 선언과 동시에 초기화 가능, 파라미터는 없음

```java
public class Example {
    private int count = 10;           // 가능
    private String name = "Java";     // 가능
    private List<String> list = new ArrayList<>(); // 가능
}

public class Example {
    private static int staticCount = 100;        // 가능
    private static final String CONSTANT = "값"; // 가능
    private static List<String> staticList = new ArrayList<>(); // 가능
}

public void method() {
    int localVar = 20;              // 가능
    String localName = "지역변수";   // 가능
}

// Java는 기본 매개변수를 지원하지 않습니다!
public void method(int value = 10) {  // 컴파일 에러!
    // 불가능
}

```



## 자바의 자료형

- 기본 자료형 <- -> 참조 자료형

변수 ==초기화== 시에 new 의 사용유무. (예외 : String)

### 기본 자료형 | primitive

#### 정수형

- byte : 1바이트 (8bit)
- short : 2바이트
		byte 로 표현하기엔 너무 수가 크고,  int 로 쓰기엔 값이 너무 작을때 (공간 효율을 위함)
- int : 4바이트
- long : 8 바이트

byte, short, int, long 은 음수 포함 (signed) : (-2^(n bit-1) ~ 2^(n bit -1) - 1)


- char : 2바이트
char 는 음수 없음 : 0 ~ 2^(n bit) - 1

2 바이트 -> unicode
\u 다음에는 16진수 4개가 와야함
그리고 음수가 들어갈 수 없음
그리고 \u로시작하지 않으면 두개 이상의 문자가 대입될 수 없음

#### 소수점 값

- float 4 바이트
- double 4바이트

-> 민감한 숫자 (돈 계산 등) 일때 사용해선 안됨
-> java.math.BigDecimal

> float : single-precision 32-bit IEEE 754 floating point 
> double : double-precision 64-bit IEEE 754 floating point


##### floating point ?

값의 따라 소수점 자리의 위치가 바뀌는 것을 의미.

고정 소수점 : 정수부, 소수부를 나타내는 비트가 정해져 있음.
부동 소수점 : 부호 + 가수 + 지수

예를들어, 123.45 의 경우
고정 소수점 : 123 + 0.45
부동소수점 : $(-1)^0$ + $1.2345$ + $10^2$

##### single, double precision ?

싱글은 그냥 double (64비트) 의 절반이라 싱글이라고 부르는것.

##### IEEE 754 ?

국제표준


#### 나머지

- boolean - true/ false , 대부분의 경우 1바이트



## 연산자

-> 참조 자료형은 +, -, /, * 사용 불가 
-> 예외, String 은 + 사용 가능

#### 논리 부정 연산자 (logical complement operator)
-> only boolean

#### 배타 연산자 (xor)
^

##### 그리고 비트 반전 연산자가 있었던 거 같은데... 
-> '~' : 틸드 



#### 계산하는 순서

단항 > 산술 (곱하기나누기 > 더하기 빼기)

우선순위가 높은 순위대로 오른쪽에서부터 왼쪽으로

##### 근데 ++, -- (마이너스x2)  가 어디에 위치하느냐에 따라서 다르다. 


#### 논리 연산자

&& -> AND
|| -> OR


#### 삼항 연산자 : ?

expression ? if expression is true : if expression is false

instanceof 도 연산자. -> 10장에서.
비트 연산을 하는 7개의 연산자.

#### 형변환 (Casting)

- 안되는 경우
	- boolean
	- 기본 -> 참조, 참조 -> 기본 (그러나 방법이 없는것은 아님. 단지 Casting 으로는 안될 뿐)

##### bsil fd ?


##### 1의 보수, 2의 보수 


##### & , | , ^

숫자일 경우 : 비트연산
boolean 일 경우 : 논리 연산

^ : xor -> true ^ false = true, true & true | false & false = false

##### && 와 & 의 차이

&& 의 경우, 좌측 항의 결과가 false 면 우측 항을 계산하지 않음. (어차피 false 이기 때문) 
하지만 & 은 좌 우 모두 비교해야 하므로 양쪽 항이 모두 계산됨.



- [x] baekjoon 27866 ✅ 2025-09-06






---
