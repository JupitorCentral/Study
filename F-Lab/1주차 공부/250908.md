
## 배열

##### 배열 선언

```java
int[] arr = new int[size];
```


##### 배열의 값을 초기화 하지 않을 경우

-> 인스턴스 변수를 초기화 하지 않고 사용할 경우와 값이 같음.
-> 참조 자료형은? -> null


##### 배열을 그냥 출력할 경우

```java
int[] arr = new int[7];  
println(arr);  
  
Integer[] arr2 = new Integer[3];  
println(arr2);
```

```java
> Task :Main.main()
[I@2b2fa4f7
[Ljava.lang.Integer;@1dbd16a6
```

-> \[  : '배열' 이라는 의미, 'I' -> int, 'L' -> 참조자료형 (char\[] 는 또 'C' 다.)
 
##### 배열 선언 2

```java
int[] arr = {1, 2, 3, 4, 5};
```


### 2차원 배열

```java
int[][] arr = {  
	{1,2,3,4,5},  
	{6,7,8,9,10}  
};  // arr[2][5]  
  
int[][] arr2 = new int[2][3];

int[][] arr3 = new int[][3];       // -> ERROR  
int[][] arr4 = new int[][];       // -> ERROR  

int[][] arr5 = new int[3][];     // -> OKAY
```

#### 2차원 배열의 column 의 사이즈

```java
int[][] arr = new int[3][5];  
println(arr[1].length);
```


##### Simpler for loop

```java
  
int[][] arr = new int[3][5];  
  
for (int[] first : arr) {  
    for (int second : first) {           
    }  
}

int firstCount = 0;  
for (int[] first : arr){  
    int secondCount = 0;  
    for (int second : first) {  
        secondCount++;  
    }  
    firstCount++;  
}
```


##### main 의 args
```java
for (String arg: args) {  
    println(arg);  
}
```

```
java ./src/Main.java a b c d e
a
b
c
d
e
```




## 참조 자료형


-  기본 생성자 
	  -> 아무런 생성자가 없을 경우. 클래스명()


### this
-> 객체의 변수 (인스턴스 변수, 클래스 변수) 와 매개변수를 구분하기 위함


### Method Overloading

- 생성자 : 이름은 같게, 매개변수는 다르게
  -> 메소드도 가능

하나의 메소드 이름으로, 파라미터의 타입이 바뀌어도 동일한 목적의 일을 하는 메소드를 생성할 수 있음.


### 메소드에 값 넘겨주기

- 메소드가 종료되는 조건
  -> end of block, return, exception

- unreachable statement

- java method 에서 return type 은 무조건 하나
  -> 여러개의 값을 return 해주고 싶다면 ?
  -> DTO (VO 를 포함)

- DTO - Data Transfer Object 
  -> VO (Value Object) 를 포함. 데이터를 '넘겨주기 위한' 용도로 쓰이는 객체를 말함.

- 메소드에서 더이상 코드를 실행하고 싶지 않다면 ? 
  -> return 호출


### Differance between static method and non-static method

-> 일반 메소드는, 객체를 생성해주어야 호출 가능.
그러나, static method 는 객체를 생성하지 않아도 클래스만 loading 되면 호출이 가능하다.

그리고 static method 는 static variable 만 사용가능. 
-> 근데 이게 헷갈릴 수가 있다. '객체' 의 non-static variable 은 사용가능하다.

```java
public class Main {  
  
    int number;  
    static int staticNumber;
  
    public static void main(String[] args) throws Exception {  
        Main obj = new Main();  
        obj.number = 5;  
        println(obj.number);  
        
		println(number);     ->>> 이건 'Error'
		
		obj.nonStaticMethod(staticNumber);   ->>> 가능
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
    
    public void nonStaticMethod (Object obj) {  
	    return;  
	}
}
```

근데 일반 method 에서 static variable 호출은 가능.


##### static variable
-> 동일한 클래스의 모든 '객체' 에서 하나의 variable 을 바라보게 된다.


#### static block
-> 어떤 클래스의 객체가 생성되면서 딱 '한번만' 불려야 하는 코드가 있다면 ?

```java
public class Main {  
  
    int number;  
    static int staticNumber;  
  
    static {  
        println("static block");  
    }  
  
    public static void main(String[] args) throws Exception {  
        Main obj = new Main();  
        Main obj2 = new Main();  
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}
```

```
> Task :Main.main()
static block
```

-> 즉 해당 클래스의 맨처음 객체가 생성될때만 호출된다.

- static block 안에서는, static 한 것들만 호출 가능
  -> 사실 당연한 얘기다. static 한 것들은 클래스가 memory 에 loading 되면 생기고, 
	  아닌 것들은 객체가 생성되어야만 생기기 때문.


### Pass by Value, Pass By Reference

- Pass by Value
  -> 값'만' 전달한다. 변수 자체가 전달되지 않는다.
  -> Primitive type 은 다 pass by value
  -> 원래 변수의 값은 변하지 않는데

- Pass by Reference
  -> 변수 자체를 전달한다. 사실 정확히는, 변수를 가리키는 '주소' 를 전달한다.
  -> 즉, 객체에 대한 '참조' (Reference) 가 넘어가는 것.


```java

public class Main {  
  
    int number;  
    static int staticNumber;  
  
    class CustomType {  
        int num;  
        CustomType (int value) {  
            this.num = value;  
        }  
    }  
  
    public static void main(String[] args) throws Exception {  
        String str = "old";  
        Integer num = 1;  
  
        Main obj = new Main();  
        CustomType custom = obj.new CustomType(4);  
  
        println("old str : " + str);  
        println("old num : " + num);  
        println("old custom : " + custom.num);  
  
        changeValue(str, num, custom);  
  
        println("after str : " + str);  
        println("after num : " + num);  
        println("after custom : " + custom.num);  
    }  
  
    public static void changeValue (String str, Integer num, CustomType custom) {  
        str = "new";  
        num = 5;  
        custom.num = 15;  
        println("new str : " + str);  
        println("new num : " + num);  
        println("new custom : " + custom.num);  
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
  
}

```

```
> Task :Main.main()
old str : old
old num : 1
old custom : 4
new str : new
new num : 5
new custom : 15
after str : old
after num : 1
after custom : 15

```

> [!info] primitive type + 자바에서 기본으로 선언된 reference type  -> Call by Value, 그 외에 자료형은 Call by Reference



### 임의 개수의 매개변수


배열도 가능하나, 그러면 모든 값을 무조건 배열로 넣고 보내줘야 한다는 단점.

```java
public void function (int ... numbers) -> 점 3개

public void function2 (int ... numbers, String str)  -> 'compile ERROR'
```

> [!Warning] 이 방법을 사용할때는, 임의 매개 변수의 선언은 가장 마지막에 와야 한다.
> 왜냐하면 임의 배개 변수 선언 뒤에는 메소드의 선언을 닫는 소괄호 ')' 가 와야하기 때문





## Package & Modifier - 패키지와 접근제어자

-> for [[250906#^e1ac87|'this' error]] and [[250906#^7ef0b5|'clone' error]]


### Package

-> 패키지는 단순히 '폴더' 의 개념이 아니다.

- Package 를 사용하기 위한 조건
	- First line
	- only one package per source file
	- same folder name to package name
	- 'java' as package name

- package name list
	- java
		- 자바 기본 패키지 (java vendor 에서 개발)
	- javax
		- 자바 확장 패키지 (java vendor 에서 개발)
	- org
		- 일반적으로 비 영리단체(오픈소스) 의 패키지
	- com
		- 일반적으로 영리단체(회사)의 패키지

- 유의할점
	- package name must be written in lower case
	- don't use java keyword (예약어)

상위 패키지 이름 -> 하위 패키지 이름 (io, lang, nio, text, util ...)

#### import
-> 다른 패키지에 접근한다.

src/Main.java
src/subPackage/SubMain.java


```java
'Main.java'

import subPackage.SubMain;  
  
public class Main {  
  
    public static void main(String[] args) throws Exception {  
        SubMain.main(null);  
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
  
}
```

```java
package subPackage;  
  
public class SubMain {  
    public static void main (String[] args) {  
        println("SubMain");  
    }  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}
```

```
> Task :Main.main()
SubMain

BUILD SUCCESSFUL in 82ms
```




##### import static (since jdk 5)

```java
package subPackage;  
  
public class SubMain {  
    public static String ClASS_NAME = "CLASS_NAME";  
  
    public static void main (String[] args) {  
        println("SubMain");  
    }  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
    public static void SubStaticMethod () {  
        println("SubStaticMethod is called");  
    }  
}
```

```java
import subPackage.SubMain;  
import static subPackage.SubMain.SubStaticMethod;  
import static subPackage.SubMain.ClASS_NAME;  
  
public class Main {  
  
    public static void main(String[] args) throws Exception {  
        SubMain.main(null);  
        SubStaticMethod();  
        println(ClASS_NAME);  
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}
```

마치 Main 에서 선언된 메서드 / 변수마냥 쓸 수 있음.
만약 중복되면, 현재 클래스의 메서드 / 변수가 우선됨.


### Access Modifier 접근 제어자

#### public
	누구나 접근 가능

#### protected
	같은 패키지 내에 있거나 상속받은 경우에만

#### package-private
	아무런 접근제어자를 적지 않을때. 같은 패키지 내에서만 접근 가능

같은 패키지에서는, 상속받은 클래스여도 접근 가능하나,
패키지가 다르면, 불가능함.

```java
package subPackage;  
  
public class SubMain {  
    public static String ClASS_NAME = "CLASS_NAME";  
    int package_protected_val = 5;  
  
    public static void main (String[] args) {  
        println("SubMain");  
    }  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
    public static void SubStaticMethod () {  
        println("SubStaticMethod is called");  
    }  
}
```

이건 가능한데 (같은 패키지라)
```java
package subPackage;  
  
public class AnotherSub extends SubMain {  
    public static void main (String[] args) {  
        AnotherSub obj = new AnotherSub();  
        SubMain.println(obj.package_protected_val);  
    }  
}
```

이건 안됨
```java
package subPackage.subsub;  
import subPackage.SubMain;  
  
public class SubMainSub extends SubMain {  
    public static void main (String[] args) {  
        SubMainSub obj = new SubMainSub();  
        SubMain.println(obj.package_protected_val);   ->> ERROR ''package_protected_val' is not public in 'subPackage.SubMain'. Cannot be accessed from outside package'
    }  
}
```


##### class variable

^6801f4

그리고 상속받고 나서, 부모클래스의 static method 를 사용할때는

```java
SubMain.println("");
```

보통 이런식으로 사용하지, 

```java
obj.println(obj.package_protected_val);
```

이런식으로 사용하는걸 추천하지는 않는듯. 컴파일은 잘된다.

왜냐하면, 상속받으면, 인스턴스 변수와 메서드는 상속받기 때문.

그럼... static 변수는 ?


#### private
	해당 클래스 내에서만 가능.


---
private -> package-private -> protected -> public
해당 클래스 안에서 -> 같은 패키지에서 -> 상속받은 클래스에서 -> import 한 클래스에서



#### 클래스에 접근제어자 사용시 유의점

클래스를 선언할때는 반드시 파일 이름에 해당하는 클래스가 반드시 존재해야함.

```java

package subPackage;  
  
public class SubMain {  
    public static String ClASS_NAME = "CLASS_NAME";  
    int package_protected_val = 5;  
  
    public static void main (String[] args) {  
        println("SubMain");  
    }  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
    public static void SubStaticMethod () {  
        println("SubStaticMethod is called");  
    }  
}  
  
class SubMainExtends extends SubMain {  
      
}

```

하나의 파일 안에 여러개의 클래스가 존재할 수 있지만,
public 클래스는 무조건 한개.

그리고 그 public 클래스는, 파일명과 다르면 안된다.



## 상속 - inheritance


#### 부모 클래스의 메소드, 변수

상속을 받으면, 부모 클래스의 public, protected 한 (같은 패키지면 package-protected 까지) 
변수, 메소드들은 모두 사용 가능.

#### 생성자

-> 자식 클래스에서 객체를 생성하면,
부모 클래스의 no-args 한 생성자를 호출.

-> 만약 no-args 한 생성자가 없으면 ? 

```java
public class SubMain {  
    public static String ClASS_NAME = "CLASS_NAME";  
    int package_protected_val = 5;  
  
    SubMain(int val) {  
        package_protected_val = val;  
    }
}
```

```java
public class SubMainSub extends SubMain {    ->> 오류 : There is no no-arg constructor available in 'subPackage.SubMain'
    public static void main (String[] args) {  
        SubMainSub obj = new SubMainSub();  
    }  
}
```

해결방법 2가지

- create no-args constructor
- call super (parent class constructor) with parameters at child class

##### super()

-> 부모클래스의 생성자.

따라서 위의 경우, 이렇게 해주면된다.

```java
package subPackage;  
  
public class SubMain {  
    public static String ClASS_NAME = "CLASS_NAME";  
    int package_protected_val = 5;  
  
    SubMain(int val) {  
        this.package_protected_val = val;  
    }  
    public static void main (String[] args) {  
        println("SubMain");  
    }  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}  
  
class SubMainExtends extends SubMain {  
    SubMainExtends () {  
        super(10);  
    }  
}
```

만약 null 을 super의 파라미터로 넘길 경우

```java
package subPackage;  
  
class SimpleVO {  
    String str;  
}  
  
public class SubMain {  
    public String ClASS_NAME = "CLASS_NAME";  
    int package_protected_val = 5;  
  
    SubMain(int val) {  
        this.package_protected_val = val;  
    }  
  
    SubMain (String str) {  
        this.ClASS_NAME = str;  
    }  
  
    SubMain (SimpleVO vo) {  
  
    }  
  
  
    public static void main (String[] args) {  
        println("SubMain");  
    }  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}  
  
class SubMainExtends extends SubMain {  
    SubMainExtends () {  
        super(null);  
    }  
}
```

```
SubMain.java:34: error: reference to SubMain is ambiguous
        super(null);
        ^
  both constructor SubMain(String) in SubMain and constructor SubMain(SimpleVO) in SubMain match
```

이렇게 된다. String 으로 갈지 SimpleVO 로 갈지 정할 수 없으므로.



#### Method Overriding

parent class 에 있는 method 를 child class 에서 재선언하여 그 동작을 바꿀 수 있음. (override -> 덮어 쓰다)

##### 같아야 하는 조건

- 접근 제어자
- 리턴 타입
- 메소드 명
- 파라미터 타입



##### 파라미터 타입

```java
public class SubMain {  
    public String ClASS_NAME = "CLASS_NAME";  
    int package_protected_val = 5;  
  
    public static void main (String[] args) {  
        println("SubMain");  
    }  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}  
  
class SubMainExtends extends SubMain {  
    public static <T> String println (T obj) {    ->> 'println(T)' in 'SubMainExtends' clashes with 'println(T)' in 'SubMain'; incompatible return type
        return "SubMainExtends_println";  
    }  
}
```

즉 자식 클래스의 println 이 부모 클래스의 메소드와 리턴타입이 달라서 불가능.



그럼 해당 리턴타입을 가지는 메소드를 또 선언하면 안되는건가 ? (method overloading)

```java
(1)
public static <T> void println (T obj) {  
    System.out.println(obj);  
}  
  
(2)
public static <T> String println (T obj) {       ->>> 'println(T)' is already defined in 'subPackage.SubMain'
    System.out.println(obj);  
}

(3)
public static <T, S> String println (T obj, S obj2) {      ->>> 얘는 된다. 파라미터 타입이 다르기때문에 Overloading.
    System.out.println(obj);  
    return "yes";  
}

(4)
public static <S, T> String println (S obj) {         ->>> 'println(T)' clashes with 'println(S)'; both methods have same erasure 
    System.out.println(obj);                               ->>> 얘는 뭔소리인지 모르겠다. erasure ??
    return "yes";  
}

(5)
public static String println (String obj) {          ->>> 요건 또 된다. 아마 제너릭이랑 달라서 그런듯.
    System.out.println(obj);                            ->>> 그런데 parameter 에 String 을 넘기면, (1) 와 같아지는거 아닌가 ?
    return obj;  
}
```

안된다. 그러니까 method overloading 할 수 있는 조건은, 파라미터 타입.


맨 마지막건 되니까, 그래서 이렇게 선언하면

```java

class SubMainExtends extends SubMain {  
    public static String println (String obj) {  
	    return "SubMainExtends_println";  
	}
}
```

된다.


##### 접근제어자

```java
public class SubMain {  
    public static void println (String obj) {  
        System.out.println(obj);  
    }  
}  
  
class SubMainExtends extends SubMain {  
    private static void println (String obj) {  
        System.out.println("inherited println");  
    }  
}
```

권한이 public -> private 로 권한이 축소되었는데, 이러면

```java
'println(String)' in 'subPackage.SubMainExtends' clashes with 'println(String)' in 'subPackage.SubMain'; attempting to assign weaker access privileges ('private'); was 'public'
```

그 반대는 된다.

```java
public class SubMain {  
    private static void println (String obj) {  
        System.out.println(obj);  
    }  
}  
  
class SubMainExtends extends SubMain {  
    public static void println (String obj) {  
        System.out.println("inherited println");  
    }  
}
```

그래서 부모 클래스의 메소드의 접근제어자가 private 면, overriding 시에는 private 부터 package-private, protected, public 다 된다.


#### calling constructor from other package


```java
package subPackage;  
  
public class AnotherSub extends SubMain {  
  
    AnotherSub() {  
        println("Another Sub");  
    }  
  
    private static void println (String obj) {  
        System.out.println(obj);  
    }  
}
```

```java
import subPackage.AnotherSub;  
import subPackage.SubMain;  
  
public class Main {  
  
    public static class Sub {  
        static int val;  
    }  
  
    public static void main(String[] args) throws Exception {  
        SubMain subMain = new AnotherSub();  
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}
```


```java
'AnotherSub()' is not public in 'subPackage.AnotherSub'. Cannot be accessed from outside package
```

그래서 public  으로 AnotherSub 생성자를 바꿔주면 문제 없음


### 참조 자료형의 형변환


```java

public static void main(String[] args) throws Exception {  
    SubMain subMain = new AnotherSub();  
    AnotherSub anotherSub = new SubMain();   ->>> 'error: incompatible types: SubMain cannot be converted to AnotherSub'
}
```

왜 자식 -> 부모 클래스 는 되는데 반대는 안되는지 ?

잘 생각해보면, 자식클래스가 생성될때는 부모클래스의 생성자도 호출된다. 그래서 부모클래스로 변환할 수 있지만,
부모 클래스의 생성자에는 자식클래스의 생성자가 없다. 즉 자식클래스가 생성되지 않는다. 그래서 변환이 안되는 것.


```java
public class Main {  
  
    public static void main(String[] args) throws Exception {  
        SubMain subMain = new SubMain();  
        AnotherSub anotherSub = new AnotherSub();  
  
        AnotherSub anotherSub2 = (AnotherSub) subMain;   ->>> ERROR 'class subPackage.SubMain cannot be cast to class subPackage.AnotherSub'
		 
		(3) 
        SubMain subMain2 = anotherSub;  
        AnotherSub anotherSub3 = (AnotherSub) subMain2;  ->>> 얘는 가능
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
}
```

(3) 은 가능한데, 왜냐하면 subMain2 는 원래 AnotherSub 의 인스턴스이기 때문이다.
그러니까, 부모클래스로 형변환은 해도, 자식클래스의 정보는 남아있다는 얘기.

그럼 SubMain\[] array 라는 게 있어서, 어떤 공간에는 AnotherSub, 어떤 공간에는 SubMain 을 집어넣으면, 이 둘을 어떻게 판별할까 ?

##### instance of

```java
public static void main(String[] args) throws Exception {  
    SubMain[] arr = new SubMain[3];  
    arr[0] = new AnotherSub();  
    arr[1] = new SubMain();  
    arr[2] = new AnotherSub();  
  
	  (1)
    for (int i=0; i<3; i++) {  
        String type = arr[i] instanceof AnotherSub ? "AnotherSub" : "SubMain";  
        println("instance of arr[" + i + "] : " + type);  
    }  
	  (2)
    for (int i=0; i<3; i++) {  
        String type = arr[i] instanceof SubMain ? "SubMain" : "AnotherSub";  
        println("instance of arr[" + i + "] : " + type);  
    }  
}
```

```
(1)
instance of arr[0] : AnotherSub
instance of arr[1] : SubMain
instance of arr[2] : AnotherSub

(2)
instance of arr[0] : SubMain
instance of arr[1] : SubMain
instance of arr[2] : SubMain
```

신기하게, instanceof 를 자식 클래스인지 판단하게 만들어야 자식 클래스인지 아닌지를 판별한다는 것.
사실 생각해보면 당연하긴 하다. 
AnotherSub 이던, SubMain 이던 결국에 맨처음에 SubMain 이냐를 판단하면, 무조건 true 이기 때문.
(AnotherSub 는 SubMain 의 자식 클래스이므로, SubMain 도 되기 때문)


### Polymorphism


```java
public class Main {  
  
    public static void main(String[] args) throws Exception {  
        Main[] arr = new Main[3];  
        arr[0] = new SubMain1();  
        arr[1] = new SubMain2();  
        arr[2] = new SubMain3();  
  
        for (int i=0; i<3; i++) {  
            println("printSelf of arr[" + i + "] : " + arr[i].printSelf());  
        }  
    }  
  
    public static <T> void println (T obj) {  
        System.out.println(obj);  
    }  
  
    public String printSelf () {  
        return this.toString();  
    }  
}  
  
class SubMain1 extends Main {}  
class SubMain2 extends Main {}  
class SubMain3 extends Main {}
```

```java
> Task :Main.main()
printSelf of arr[0] : SubMain1@251a69d7
printSelf of arr[1] : SubMain2@7e9e5f8a
printSelf of arr[2] : SubMain3@8bcc55f
```




## Interface, Abstraction and enum

^5a6436

### 개요 

클래스만 .class 파일을 만들 수 있는 것이 아니다.
interface, abstract class 도 가능.

##### interface, abstract 의 장점

interface 는 개발하기 전 좋은 밑거름이 된다.
-> 설계단계에서 어떤 클래스, 메소드, 변수를 쓸지 정리하는 작업도 함. 이때 쓸 수 있음
	-> 개발할때 기능을 구현하는데에만 신경을 쓸 수 있다
-> 개발자간 네이밍센스의 간극을 줄일 수 있음
-> 선언과 구현이 구분가능하다.
	-> 이게 무슨 장점이 있지 ?

### Interface

MemberManager -> interface

```java
MemberManagerImpl implements MemberManager {
	public boolean addMember();
}
```

```java
MamberManager member = new MemberManager();  ->> 당연히 interface 라 안됨.

MamberManager member = new MemberManagerImpl();  ->> 이게 가능함.
member.addMember(new Member("John")); 
...
```

- static, final 
- How to use at other class
- inheritence

### Abstract

```java
abstract class MemberManagerAbstract {  
	int num;
	
    public abstract boolean addMember();  
    public void printLog(String data) {  
        System.out.println("Data="+data);  
    }  
}
```

- abstract 개수
- static, final
- How to use at other class
- inheritence

-> partial interface


### final

-> to class, variable, method

#### class

- inheritence

#### method


```java
public class SubMain {  
    private final void println (String obj) {  
        System.out.println(obj);  
    }  
    private final void println (int value) {              ->>> 이건 가능
        System.out.println(value);  
    }  
}
```

- overriding

#### variable

- variable <---> method

- local variable
- paramter


```java
public class SubMain {  
    private final void println (String obj) {  
	    final int finalValue;  
		finalValue = 3;  
		finalValue = 5;                                   ->>> ERROR
		
        System.out.println(obj);  
    }  
    private final void println (final short value) {  
        System.out.println(value);  
    }  
    private final void println (final int value) {  
        value = 3;                                                     ->>> ERROR
        System.out.println(value);  
    }  
}
```

- DTO and its instance variables


### enum

#### basic
```java
public enum OverTimeValues {  
    THREE_HOUR,  
    FIVE_HOUR,  
    WEEKEND_FOUR_HOUR,  
    WEEKEND_EIGHT_HOUR  
}  
  
public static void main(String[] args) throws Exception {  
    OverTimeValues enum1 = OverTimeValues.FIVE_HOUR;  
    println(enum1);  
}
  
public static <T> void println (T obj) {  
    System.out.println(obj);  
}

---

> Task :Main.main()
FIVE_HOUR

```

- constructor ?
- result and 'String' ?


#### with certaim value
```java
public enum OverTimeValues {  
    THREE_HOUR(18000),  
    FIVE_HOUR(30000),  
    WEEKEND_FOUR_HOUR(40000),  
    WEEKEND_EIGHT_HOUR(60000);  
  
    private final int amount;  
    OverTimeValues(int value) {  
        this.amount = value;  
    }  
    public int getAmount() {  
        return this.amount;  
    }  
}

public static void main(String[] args) throws Exception {  
    OverTimeValues enum1 = OverTimeValues.FIVE_HOUR;  
    println(enum1.amount);  
}

----

> Task :Main.main()
30000
```

-> access modifier for constructor ?



#### parent of enum

##### constructor of Enum
  -> name, ordinal 

##### 'overriding' blocked methods inherited from Object at Enum Class
- availabe methods


##### method declared at Enum
- compareTo(E e)
	- bigger -> later
```java
public static void main(String[] args) throws Exception {  

	OverTimeValues o1 = OverTimeValues.THREE_HOUR;  
	OverTimeValues o2 = OverTimeValues.FIVE_HOUR; 
	  
	println(o1.compareTo(o2));  
}

-----
> Task :Main.main()
-1
```

- getDeclaringClass()
- name()
- ordinal()
- valueOf(Class\<T> enumType, String name)
- values()






## Exception

### try - catch

#### order of codes when exception occured

##### try
##### catch

#### local variable inside try and catch

### finally

#### Relation to try and catch

##### when exception occured
##### when exception not occured


### mutiple catch


##### importance of order of exceptions
##### Parent class of all exception class


### Types of Exception

-> checked, error, runtime or unchecked

#### error

##### what is it - hardware
##### where

##### How to determind whether this is error or exception

##### difference between error and exception

##### To what these things affect 


#### runtime 

##### what is it - timing

##### Diagram of Error and Exceptions


![[Screenshot 2025-09-08 at 8.04.12 PM.png|500]]


### Throwable

- Which class can be used for caught Exceptions (as parameter of catch keyword)

#### constructors of Throwable

- getMessage
- toString
- printStackTrace

#### throws

-> use on method


#### create my own Exception


### Strategy To deal with Exceptions



