## Nested Class


##### static
- inner class <- -> static nested class

##### nameless
- inner class -> local inner class, anonymous inner class

#### nested class 의 사용이유

##### logical

한 곳에서만 쓰이는 클래스를 논리적으로 묶어야 할때

##### encapsulation

어떤 한 클래스의 private 변수에 접근하는 클래스 B 가 있고, 이 클래스를 외부에 노출시키고 싶지 않을때

##### readability

가독성과 유지보수성을 위해


### static nested class

##### access range of inner class
외부 클래스의 어떤 변수도 접근 가능 (private 까지)
-> static 은 불가능 ㅋㅋ (뭐, instance 화가 안되어있으니 해당 객체가 메모리에 할당이 안되어 있을테니 말이다)


##### compile ...?
```java
public class Main {  
  
    static class innerStaticClass {  
        private int value;  
        public int getValue() {  
            return this.value;  
        }  
        public void setValue(int value) {  
            this.value = value;  
        }  
    }  
    public static void main(String[] args) throws Exception {  
    }   
}
------------------

-> 이러면 컴파일 후에 Main.class, Main$StaticNested.class 파일이 생성된다!
```

##### how to create a instance of static nested class

```java
Main.StaticInnerClass staticInnerClass = new Main.StaticInnerClass();
---> 근데 "Main." 안써도 되던데 ,,,? 자바 버전이 달라서 그런가 ? 
```


### inner class & anonymous class


#### inner class
##### instantiate

```java
Main.InnerClass innerClass = new Main.InnerClass(); 
-->  ㅋㅋ 이거 안된다. static 이 아니면, Main 의 객체가 생성되지 않는한 InnerClass 의 생성자의 함수가 메모리에 할당되지 않기 때문

Main mainObj = new Main();  
Main.InnerClass innerClass = mainObj.new InnerClass();
----> 이래야 가능
```

##### GUI

내부 클래스는 외부에서 쓸일이 전혀 없는 경우에 씀.
주로 GUI 관련 프로그램을 개발할때 쓴다.


#### Anonymous class

```java
public class Main {  
  
    public interface EvenListener {  
        public void onClick();  
    }  
  
    class MagicButton {  
        private EvenListener listener;  
  
        public void setListener(EvenListener listener) {  
            this.listener = listener;  
        }  
        public void onClickProcess () {  
            if(this.listener != null) {  
                this.listener.onClick();  
            }  
        }  
    }  
  
    class showMyNameClickListener implements EvenListener {  
        @Override  
        public void onClick() {  
            println("This is my Name : Eric");  
        }  
    }  
  
    public static void main(String[] args) throws Exception {  
        Main mainObj = new Main();  
        MagicButton magicButton = mainObj.new MagicButton();  
        magicButton.setListener(mainObj.new showMyNameClickListener());  
        magicButton.onClickProcess();  
  
        magicButton.setListener(new EvenListener() {  
            @Override  
            public void onClick() {  
                println("This is my Name : John");  
            }  
        });  
        magicButton.onClickProcess();  
    }  
}
```

Anonymous 클래스를 쓰면, 한번만 쓸 것 같은 클래스에 대해서는 이렇게 즉석으로 만들 수 있음.
그리고 클래스를 저장하는데에 메모리도 안쓰게 되고. 
(보통 클래스를 정의하면, 정의자체가 메모리 용량을 쓰는 것이기 때문에.)


### Characteristics of Nested class

##### Which variable static inner class can access among parent class's variables

-> 당연히 static 하게 정의된 것만 참조 가능.

```java
static int privateInt = 5;  
int normalInt = 3;  
  
static class StaticInnerClass {  
    int value;  
    public static void showValue (int value) {  
        println(value);  
    }  
}  
  
public static void main(String[] args) throws Exception {  
    Main mainObj = new Main();  
  
    StaticInnerClass.showValue(privateInt);  
    StaticInnerClass.showValue(normalInt);    --->>> "ERROR" 
    StaticInnerClass.showValue(mainObj.normalInt);      ---->> 대신 이건  "ERROR" 가 아니다. 왜냐하면, normalInt 에 대한 메모리가 mainObj 가 할당되면서 할당되었기 떄문.
}
```


##### vice versa

당연히 외부 클래스로도 내부 클래스의 변수 참조 가능



## Annotation


### Purpose

#### information

컴파일러한테 정보를 알려주거나

#### task

컴파일 할떄와 deployment 시 작업을 지정

#### when execution

실행시 별도 처리를 위해


### 정해져 있는 Annotation

#### @Override

Override 의 명시적선언.
-> 오버라이딩때 개발자가 실수로 뭐하나 뺴뜨릴 수 있는데, 그럴때 컴파일러한테 알려달라고 하는 용도

#### @Deprecated

더이상 사용하지 않을 것이라는 것을 누군가에게 경고해주길 컴파일러에게 요청

#### @SurpressWarnings

해당 어노테이션이 사용된 메소드의 warning 메시지를 빌드시 미출력하게 함

@SurpressWarnings("deprecation")  -> Deprecated warning 을 없앤다.

### Meta Annotation - For defining my own Annotation

#### @Target

어노테이션을 어떤 곳에 쓸 것인가 ?
```java
@Target(ElementType.Method)
```

- CONSTRUCTOR 생성자 선언시
- FIELD
- LOCAL_VARIABLE 지역변수 선언시
- METHOD
- PACKAGE
- PARAMETER
- TYPE - 클래스, 인터페이스, enum 등 선언시

#### @Retention

얼마나 정보가 유지되는가 ?

```java
@Retention(RetentionPolicy.RUNTIME)
```

- SOURCE -> 컴파일시 사라짐
- CLASS -> 클래스 파일에 있는 어노테이션 정보가 컴파일러에 의해서 참조 가능. JVM 에서는 사라짐.
- RUNTIME -> 실행시 JVM 에 의해서 참조 가능


#### @Documented

해당 어노테이션에 대한 정보가 Javadocs (API) 문서에 포함된다는 것을 선언
-> 뭔소리야 ?

#### @Inherited

모든 자식 클래스에서 부모클래스의 어노테이션을 사용가능하다 -> 또 뭔소리야 ?

#### @interface
-> 어노테이션을 선언할 때 사용


### Defining an Annotation

```java
@Target(ElementType.METHOD)  
@Retention(RetentionPolicy.RUNTIME)  
public @interface UserAnnotation {  
    public int number();  
    public String text() default "This is first annotation";  
}
```

-> 얘도 클래스 비슷하게, 한 파일의 public  클래스와 같은 레벨에서 선언이 안된다. 

-> 그런데 어노테이션에 값 선언이 가능하네 ... ?

### Checking variables defined inside Annotation

```java
import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
import java.lang.reflect.Array;  
import java.lang.reflect.Method;  
import java.util.ArrayList;  
  
public class Main {  
  
    @Target(ElementType.METHOD)  
    @Retention(RetentionPolicy.RUNTIME)  
    public @interface UserAnnotation {  
        public int number();  
        public String text() default "This is first annotation";  
    }  
  
    @UserAnnotation(number=1)  
    public void method1 () {  
    }  
    @UserAnnotation(number=2, text = "Second")  
    public void method2 () {  
  
    }  
    @UserAnnotation(number=3, text = "Third")  
    public void method3 () {  
  
    }  
  
    public static void main(String[] args) throws Exception {  
        Main mainObj = new Main();  
        mainObj.checkAnnotations(Main.class);  
    }  
  
    public void checkAnnotations (Class useClass) {  
        Method[] methods = useClass.getDeclaredMethods();  
        for (Method method : methods) {  
            UserAnnotation annotation = method.getAnnotation(UserAnnotation.class);  
            if (annotation != null) {  
                int number = annotation.number();  
                String text = annotation.text();  
                println(method.getName() + " - number : " + number + ", text : " + text);  
            } else {  
                println(method.getName() + " - annotation is empty");  
            }  
        }  
    }  
  
    public static void printf (String string, Object... args) { System.out.printf (string, args); }  
    public static <T> void print (T obj) { System.out.print(obj + " "); }  
    public static <T> void println (T obj) { System.out.println(obj); }  
    public static void println() { System.out.println(); }  
}
------------------

> Task :Main.main()
println - annotation is empty
println - annotation is empty
main - annotation is empty
print - annotation is empty
printf - annotation is empty
checkAnnotations - annotation is empty
method1 - number : 1, text : This is first annotation
method2 - number : 2, text : Second
method3 - number : 3, text : Third
```

-> java.lang.reflect 사용
reflextion api ?

### Inheritence of Annotation

상속 불가능. (enum 처럼)



