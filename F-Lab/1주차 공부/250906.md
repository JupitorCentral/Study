

 > [!tip] Object 를 알려면
 >	Object -> 상속 -> 객체 -> 클래스 -> 메서드 -> 프로그래밍
 >									-> 타입 		



## Object

- Object 가 무엇인가

모든 클래스의 부모 클래스

- Object 의 메소드들

-> 객체라면 이정도는 해야 한다

크게 2가지 - 객체 처리, 쓰레드 처리

### 객체 처리
clone
equals
finalize
getClass
hashCode
==toString==


#### toString

자동 호출
-> parameter, 더하기 연산

```java
public void toStringMethod2() {
	System.out.println(this)
	System.out.println(toString())
}
```

(클래스 패키지 이름 + 클래스 이름) + '@" + Integer.toHexString(hashCode())


##### 'this' error

^e1ac87

```java
public class Main {  
  
    public class MyClass {  
    }  
  
    public static void main(String[] args) throws Exception {  
        MyClass obj2 = new MyClass();  
		this.clone();
    }  
}
```

> [!warning] MyClass obj2 = new MyClass();   -> 'Main.this' cannot be referenced from a static context

> [!warning] this.clone();   -> 'Main.this' cannot be referenced from a static context

why this happens ??

여기서 Main.this 는 무엇인가 ?
-> Main class 그 자체.



##### 'clone' error 

^7ef0b5

```java
public class Main {  
      
    public static class MyClass {  
        Integer var2;  
    }  
  
    public static void main(String[] args) throws Exception {  
	    Object ob = new Object();  
		ob.clone();  // error
		  
		Main obj3 = new Main();  
		obj3.clone();  // no error
		  
		MyClass obj2 = new MyClass();  
		obj2.clone(); // error
    }  
}
```

>[!warning]  obj2.clone(); -> 'clone()' has protected access in 'java.lang.Object'



#### equals

참조자료형에서 == -> '주소값'
기본 equals -> hashCode

'값'을 비교하기 위해 -> override equals

> 근데 String.equals 는 값을 비교해주던데 ?

```java
public boolean equals(Object anObject) {  
    if (this == anObject) {   // 주소값이 같으면
        return true;  
    }  
    return (anObject instanceof String aString)  // String aString ??
            && (!COMPACT_STRINGS || this.coder == aString.coder)  // COMPACT_STRINGS ?  coder ?
            && StringLatin1.equals(value, aString.value);  
}
```
-> override 되어있음.

그러니, class 를 임의로 생성했을때, equals 는 hashCode 를 비교.

##### instanceof String aString ?
-> aString 은 어디서 튀어나오는거야?

##### COMPACT_STRINGS ?

##### coder ?

private final byte coder;

##### StringLatin1 ?

java.lang 의 클래스. public modifier 가 없으므로 외부에서 사용 불가능. 
java String 에서 byte 를 인코딩하는 방법중 하나. 다른 하나는 UTF16

##### value
-> String 객체의 인스턴스 변수


##### equals 구현시 따라야 하는 조건

reflexive
symmetric
transitive
consistent
null

---

##### equals -> hashCode

java rule : equals 에 의해 같은 두 객체는 hashCode() 리턴값도 같아야 함.
equals 에 의해 서로 다른 두 객체는 hashCode() 의 리턴값이 다를 필요는 없지만, 
다르면 hashMap 성능에 도움을 줄 수 있음.

#### String equals

```java
public boolean equals(Object anObject) {  
    if (this == anObject) {  
        return true;  
    }  
    return (anObject instanceof String aString)  
            && (!COMPACT_STRINGS || this.coder == aString.coder)  
            && StringLatin1.equals(value, aString.value);  
}
```

##### instance of 

\[Old way]
```java
void processObject(Object obj) {
    if (obj instanceof String) {
        String str = (String) obj; // explicit cast is required
        System.out.println(str.toUpperCase());
    }
}
```

\[New Way - Java 14 and later]
```java
void processObject(Object obj) {
    if (obj instanceof String str) { // 'str' is a pattern variable
        System.out.println(str.toUpperCase()); // no explicit cast needed
    }
}
```


##### String hashcode question


근데 equals 의 보통 목적은 '문자열 비교' 아닌가 ? 그럼 당연히 hashCode (객체의메모리 주소) 는 다를 수 밖에 없는것 아닌가? 같을 순 있지만.
왜 hasoCode 도 override 해야 하는지 모르겠음.


```java

String str = "string";  
String str2 = "string";  
  
System.out.println(str.equals(str2));  
System.out.println(str.hashCode());  
System.out.println(str2.hashCode());

```

> 	true
	-891985903
	-891985903

-> 어어 ??? 같은 객체라고 ? HashCode 는 객체의 메모리 주소 아닌가 ?
-> 그렇지 않다. Object 일때만 hashCode는 객체의 메모리 주소가 되고
	String 은 override 해놨음 -> value, 즉 String 의 내용 (byte\[]) 을 가지고 hash 한 값을 hash로 저장, hashCode() 로 리턴함.


```java

public int hashCode() {  
    if (h == 0 && !hashIsZero) {  
        h = isLatin1() ? StringLatin1.hashCode(value)  
				   : StringUTF16.hashCode(value);      // 요게 곧 hashcode 값이 됨.
        if (h == 0) {  
            hashIsZero = true;  
        } else {  
            hash = h;  
        }  
    }  
    return h;  
}
```

###### UTF16 일 경우

```java
// StringUTF16 class
public static int hashCode(byte[] value) {  
    return ArraysSupport.hashCodeOfUTF16(value, 0, value.length >> 1, 0);  
}
```

```java
// ArraySupport
public static int hashCodeOfUTF16(byte[] a, int fromIndex, int length, int initialValue) {  
    return switch (length) {  
        case 0 -> initialValue;  
        case 1 -> 31 * initialValue + JLA.getUTF16Char(a, fromIndex);  
        default -> vectorizedHashCode(a, fromIndex, length, initialValue, T_CHAR);  
    };  
}
```

```java
/**  
 * Get the char at index in a byte[] in internal UTF-16 representation, * with no bounds checks. * * @param bytes the UTF-16 encoded bytes  
 * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)  
 * @return the char value  
 */
 char getUTF16Char(byte[] bytes, int index);
```

얘는 잘 모르겠음.

###### Latin1 일 경우

```java
// StringLatin1
public static int hashCode(byte[] value) {  
    return ArraysSupport.hashCodeOfUnsigned(value, 0, value.length, 0);  
}
```

```java
// ArraySupport
public static int hashCodeOfUnsigned(byte[] a, int fromIndex, int length, int initialValue) {  
    return switch (length) {  
        case 0 -> initialValue;  
        case 1 -> 31 * initialValue + Byte.toUnsignedInt(a[fromIndex]);  
        default -> vectorizedHashCode(a, fromIndex, length, initialValue, T_BOOLEAN);  
    };  
}
// By.toUnsignedInt 로 간다
```

```java
public static int toUnsignedInt(byte x) { 
    return ((int) x) & 0xff;  
}
```
int -> 4byte
0xff -> 1byte

그러니까 하위 1byte 만 살려서 vectorizedHashCode 로 hash 계산




### Modifier
-> for [[250906#^e1ac87|'this' error]] and [[250906#^7ef0b5|'clone' error]]

#### public


#### private


#### final





### 쓰레드 처리
notify
nofityAll
wait
wait(long timeout)
wait(long timeout, int nanos)


#### Notify
-> 이 객체의 모니터에 대기하고 있는 단일 쓰레드를 꺠운다.

##### 모니터 ?


##### 쓰레드 ? 


##### 단일 쓰레드 ?


## 상속 - java 에서 상속은 어떻게 이루어지는가

- 상속을 하면 무슨 일이 벌어지는가

상속을 알려면, 객체를 알아야 하고 객체를 알려면 클래스를 알아야 한다.

자바에선 상속이 한개밖에 안됨 -> 인터페이스는 여러개되지 않나?





## ArrayList

다른 컬렉션 공부를 다 하면 1권을 못나가니까 일단 질문에 대해서만.

>  질문 : Arraylist 가 꽉 차면 새로운 공간을 만들고 기존 값을 복사한다. 이럴때의 Big O 는 ?

ArrayList 가 무엇인가


ArrayList 의 메소드들은 무엇이 있는가 -> 일단 Object 로 가자 왜나하면 모든 클래스들은 Object 를 최상단으로 상속받음.

ArrayList 가 꽉차면 어떤 일이 벌어지는가


