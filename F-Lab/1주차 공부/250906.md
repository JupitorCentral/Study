

 > [!tip] Object 를 알려면
 >	Object -> 상속 -> 객체 -> 클래스 -> 메서드 -> 프로그래밍
 >									-> 타입 		



## Object

- Object 가 무엇인가

모든 클래스의 부모 클래스

- Object 의 메소드들

-> 객체라면 이정도는 해야 한다

크게 2가지 - 객체 처리, 쓰레드 처리

### 객체 처리
clone
equals
finalize
getClass
hashCode
==toString==


#### toString

자동 호출
-> parameter, 더하기 연산

```java
public void toStringMethod2() {
	System.out.println(this)
	System.out.println(toString())
}
```

(클래스 패키지 이름 + 클래스 이름) + '@" + Integer.toHexString(hashCode())


##### 'this' error

^e1ac87

```java
public class Main {  
  
    public class MyClass {  
    }  
  
    public static void main(String[] args) throws Exception {  
        MyClass obj2 = new MyClass();  
		this.clone();
    }  
}
```

> [!warning] MyClass obj2 = new MyClass();   -> 'Main.this' cannot be referenced from a static context

> [!warning] this.clone();   -> 'Main.this' cannot be referenced from a static context

why this happens ??

여기서 Main.this 는 무엇인가 ?
-> Main class 그 자체.



##### 'clone' error 

^7ef0b5

```java
public class Main {  
      
    public static class MyClass {  
        Integer var2;  
    }  
  
    public static void main(String[] args) throws Exception {  
	    Object ob = new Object();  
		ob.clone();  // error
		  
		Main obj3 = new Main();  
		obj3.clone();  // no error
		  
		MyClass obj2 = new MyClass();  
		obj2.clone(); // error
    }  
}
```

>[!warning]  obj2.clone(); -> 'clone()' has protected access in 'java.lang.Object'



#### equals

참조자료형에서 == -> '주소값'
기본 equals -> hashCode

'값'을 비교하기 위해 -> override equals

> 근데 String.equals 는 값을 비교해주던데 ?

```java
public boolean equals(Object anObject) {  
    if (this == anObject) {   // 주소값이 같으면
        return true;  
    }  
    return (anObject instanceof String aString)  // String aString ??
            && (!COMPACT_STRINGS || this.coder == aString.coder)  // COMPACT_STRINGS ?  coder ?
            && StringLatin1.equals(value, aString.value);  
}
```
-> override 되어있음.

그러니, class 를 임의로 생성했을때, equals 는 hashCode 를 비교.

##### instanceof String aString ?
-> [[#^d25882|aString 은 어디서 튀어나오는거야?]]


##### COMPACT_STRINGS ?

##### coder ?

private final byte coder;

##### StringLatin1 ?

java.lang 의 클래스. public modifier 가 없으므로 외부에서 사용 불가능. 
java String 에서 byte 를 인코딩하는 방법중 하나. 다른 하나는 UTF16

##### value
-> String 객체의 인스턴스 변수


##### equals 구현시 따라야 하는 조건

reflexive
symmetric
transitive
consistent
null

---

##### equals -> hashCode

java rule : equals 에 의해 같은 두 객체는 hashCode() 리턴값도 같아야 함.
equals 에 의해 서로 다른 두 객체는 hashCode() 의 리턴값이 다를 필요는 없지만, 
다르면 hashMap 성능에 도움을 줄 수 있음.

#### String equals

```java
public boolean equals(Object anObject) {  
    if (this == anObject) {  
        return true;  
    }  
    return (anObject instanceof String aString)  
            && (!COMPACT_STRINGS || this.coder == aString.coder)  
            && StringLatin1.equals(value, aString.value);  
}
```

##### instance of 

^d25882

\[Old way]
```java
void processObject(Object obj) {
    if (obj instanceof String) {
        String str = (String) obj; // explicit cast is required
        System.out.println(str.toUpperCase());
    }
}
```

\[New Way - Java 14 and later]
```java
void processObject(Object obj) {
    if (obj instanceof String str) { // 'str' is a pattern variable
        System.out.println(str.toUpperCase()); // no explicit cast needed
    }
}
```


##### String hashcode question


근데 equals 의 보통 목적은 '문자열 비교' 아닌가 ? 그럼 당연히 hashCode (객체의메모리 주소) 는 다를 수 밖에 없는것 아닌가? 같을 순 있지만.
왜 hasoCode 도 override 해야 하는지 모르겠음.


```java

String str = "string";  
String str2 = "string";  
  
System.out.println(str.equals(str2));  
System.out.println(str.hashCode());  
System.out.println(str2.hashCode());

```

> 	true
	-891985903
	-891985903

-> 어어 ??? 같은 객체라고 ? HashCode 는 객체의 메모리 주소 아닌가 ?
-> 그렇지 않다. Object 일때만 hashCode는 객체의 메모리 주소가 되고
	String 은 override 해놨음 -> value, 즉 String 의 내용 (byte\[]) 을 가지고 hash 한 값을 hash로 저장, hashCode() 로 리턴함.


```java

public int hashCode() {  
    if (h == 0 && !hashIsZero) {  
        h = isLatin1() ? StringLatin1.hashCode(value)  
				   : StringUTF16.hashCode(value);      // 요게 곧 hashcode 값이 됨.
        if (h == 0) {  
            hashIsZero = true;  
        } else {  
            hash = h;  
        }  
    }  
    return h;  
}
```

###### UTF16 일 경우

```java
// StringUTF16 class
public static int hashCode(byte[] value) {  
    return ArraysSupport.hashCodeOfUTF16(value, 0, value.length >> 1, 0);  
}
```

```java
// ArraySupport
public static int hashCodeOfUTF16(byte[] a, int fromIndex, int length, int initialValue) {  
    return switch (length) {  
        case 0 -> initialValue;  
        case 1 -> 31 * initialValue + JLA.getUTF16Char(a, fromIndex);  
        default -> vectorizedHashCode(a, fromIndex, length, initialValue, T_CHAR);  
    };  
}
```

```java
/**  
 * Get the char at index in a byte[] in internal UTF-16 representation, * with no bounds checks. * * @param bytes the UTF-16 encoded bytes  
 * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)  
 * @return the char value  
 */
 char getUTF16Char(byte[] bytes, int index);
```

얘는 잘 모르겠음.

###### Latin1 일 경우

```java
// StringLatin1
public static int hashCode(byte[] value) {  
    return ArraysSupport.hashCodeOfUnsigned(value, 0, value.length, 0);  
}
```

```java
// ArraySupport
public static int hashCodeOfUnsigned(byte[] a, int fromIndex, int length, int initialValue) {  
    return switch (length) {  
        case 0 -> initialValue;  
        case 1 -> 31 * initialValue + Byte.toUnsignedInt(a[fromIndex]);  
        default -> vectorizedHashCode(a, fromIndex, length, initialValue, T_BOOLEAN);  
    };  
}
// By.toUnsignedInt 로 간다
```

```java
public static int toUnsignedInt(byte x) { 
    return ((int) x) & 0xff;  
}
```
int -> 4byte
0xff -> 1byte

그러니까 하위 1byte 만 살려서 vectorizedHashCode 로 hash 계산




### Modifier
-> for [[250906#^e1ac87|'this' error]] and [[250906#^7ef0b5|'clone' error]]

#### public


#### private


#### final





### 쓰레드 처리
notify
nofityAll
wait
wait(long timeout)
wait(long timeout, int nanos)


#### Notify
-> 이 객체의 모니터에 대기하고 있는 단일 쓰레드를 꺠운다.

모니터 ? 쓰레드 ? 단일 쓰레드 ?


## Thread

프로그램 -> 코드의 집합. 이를 메모리에 옮기면 실행이 가능해지며, 이를 '프로세스' 라고 한다.
하나의 '프로세스' 내부에서 자원을 공유하는 더 작은 실행단위를 만들 수 있는데 이를 '쓰레드' 라고 함.

JVM -> 32MB ~ 64MB
쓰레드 하나 추가 -> 1MB 
그래서 쓰레드를 경량 프로세스 (lightweight) 라고도 함

### Thread 를 구현하는 2가지 방법

Runnable interface, Thread class 

Thread class 는 Runnable interface 를 구현한 것.
Java 에서는 상속을 1가지 클래스밖에 받지 못하는데, 
만약에 상속받으려고 하는 부모 클래스가 Thread 를 상속받지 않고 있다면 ?
이때 Runnable interface 를 사용하면 되는 것.
Thread class 를 상속받지 않고도 Thread 를 사용할 수 있게끔 하기 위한 장치.

- run
  -> 쓰레드가 시작될때 수행되는 동작을 선언하는 코드
  
  *Thread 는 run 코드가 실행을 끝마치기 전까진 끝나지 않음*
  
- start 
  -> 쓰레드를 실제로 실행시키는 코드

### Thread 생성자

(Runnable) target, (String) name, (ThreadGroup) group, (long) stackSize

target -> Runnable 을 구현한 클래스의 객체
name -> 생성하고자 하는 Thread 의 이름
ThreadGroup -> 쓰레드를 묶을 수 있는데, 묶고 나면 이 ThreadGroup 을 통해 이 그룹에 묶인 쓰레드들에 대한 여러 정보를 확인할 수 있음
stackSize -> 스택의 크기. 경우에따라 무시될 수 있음

> [!note] 여기서 말하는 Stack 은 Collection 의 Stack 과 전혀 상관 없음
> 
> Java process 시작 -> Runtime data area 구성. 그 중 하나가 스택. 쓰레드 생성시 별도의 스택이 할당됨.
> Java Language Speicification, http://docs.oracle.com/javase/specs 참조.


### sleep

Thread 의 static method -> 보통 해당 메소드를 위함이 아님.
예외 -> sleep

Try-Catch

> [!warning] main 메소드가 끝나더라도, main 또는 다른 메소드에서 시작한 쓰레드가 끝나지 않으면 자바 프로세스는 종료되지 않음
> 
>  daemon 쓰레드는 예외


### Thread 의 주요 메서드들

속성 확인, 지정 

id, name, priority, daemon, stacktrace, state, threadGroup

상태 통제

state, join, interrupt
### What is Daemon Thread ?

보통 Thread 는 실행이 끝날때까지 JVM 종료되지 않음
Daemon Thread 는 실행이 안끝나도 JVM 이 종료될 수 있음. (단, start 로 실행되기전에 daemon 으로 설정되어야 함)



### Synchronized

for Thread safety, we need to use 'synchronized'

여러개의 쓰레드가, 단일 객체의 인스턴스 변수를 바꾸는 메소드에 접근할때 문제가 발생할 수 있음.\

#### 사용방법
메소드 자체, 특정 코드만

#### 선언되면 ?
-> 한번에 하나의 쓰레드만 해당 메소드 / 코드에 접근/실행 할 수 있다.

#### 성능이슈
메소드 전체를 synchronized 처리하면, 성능상 이슈가 발생할 수 있음
-> Thread safety 하지 않아도 되는 코드들 까지도 쓰레드가 기다려야 함.


#### lock 객체 

```java
Object lock = new Object();   // 보통 이렇게 잠금처리를 위한 object 를 선언 -> '문지기'

public void plus (int value) {
	synchronized(lock) {
		amount += value;
	}
}

public void minus (int value) {
	synchronized(lock) {
		amount -= value;
	}
}
```

lock 객체가 한 개의 쓰레드만 이용하게 허락함

그런데 lock 역할을 하는 객체를 여러개 선언해야 할 때도 있음

method1, method2 가 모두 synchronized 기능이 필요한데, 동일한 lock 객체를 사용하게 되면, 
method1 이 락이 걸릴때 method2도 락이 걸려버림.


#### 실수

```java

// 합리적인 사용
CommonCalculate calc = new CommonCalculate();
ModifyAmountThread thread1 = new ModifyAmountThread(calc, true)
ModifyAmountThread thread2 = new ModifyAmountThread(calc, true)


// synchronized 가 필요없음 -> 단일 객체의 메소드에 접근하는 것이 아니기 때문.
CommonCalculate calc1 = new CommonCalculate();
ModifyAmountThread thread1 = new ModifyAmountThread(calc1, true)

CommonCalculate calc2 = new CommonCalculate();
ModifyAmountThread thread2 = new ModifyAmountThread(calc2, true)

```


### Thread 를 통제하는 메소드

getState, join (milllis, nanos), interrupt


#### Join

```java
thread1.start();  
thread2.start();  
  
try {  
    thread1.join();  
    thread2.join();  
    System.out.println("Final Value is " + calc.getAmount());  
}
```

> [!info] 여기서, ==기본 main thread== 가 thread1, thread2 를 start 시키고, 그 쓰레드 자체가 thread1, thread2 를 Timed Waiting 상태로 변경시키는것.

#### State enum class
new, 

runnable -> Ready , Running

Ready -> (thread is selected by scheduler) -> Running
scheduler 는 어떤 CPU 가 어떤 코드를 실행할지 결정한다. (CPU 에 할당함)

Runnig -> (stopped by scheduler) -> Ready
또한, 알고리즘에 따라 scheduler 는 해당 코드의 실행을 그만두고, (CPU 에 다른 코드를 할당함) Ready 상태로 변환

timed_waiting
waiting
blocked

terminated 

![[Pasted image 20250906205131.png|700]]


#### interrupt

-> InterruptedException 을 발생시키면서 중단시킴.
-> sleep, join (-> Timed Waiting)

-> 쓰레드가 시작하기전 또는 terminated 된 상태라면 ?


join (500) -> 0.5 초 기다림

만약 sleep(2000) 을 run 하고, thread 를 start 시킨다음, join(500) 을 하면, 
1.5초 후에 join 다음의 코드가 실행된다.
이때 해당 thread.interrupt 를 실행시키면, InterruptedException 오류 발생 


#### Object 에서의 thread 관련 메소드

^dd13d0

wait -> 대기
notify -> 대기 해제
notifyAll

##### wait & notify 

wait ()
wait (int timeout)

timeout 이 없으면 무한정 대기 (Waiting, not TimedWaiting)
-> 해당 쓰레드의 monitor (lock 을 담당하는 instance variable) 이 notify, notifyAll 을 해주어야만 Runnable 로 상태가 바뀐다

notify 는 Timed Waiting 상태도 깨운다


```java

Thread.sleep(100)  // -> main thread 겠지 ? 정체가 필요하다

synchronized(monitor) {
	monitor.notify()
}
```

##### 여기서, synchronized 가 필요한 이유는 무엇일까 ?

^a7bfed











## 상속 - java 에서 상속은 어떻게 이루어지는가

- 상속을 하면 무슨 일이 벌어지는가

상속을 알려면, 객체를 알아야 하고 객체를 알려면 클래스를 알아야 한다.

자바에선 상속이 한개밖에 안됨 -> 인터페이스는 여러개 가능.

Q. 상속과 파라미터.
```java
Thread(Runnable target)
```
이때, target 은 Runnable 을 implement 한 클래스의 객체일 것이다.
즉, Runnable 인터페이스의 객체가 아니다. (애초에 인터페이스의 객체는 존재할 수 없지만.) 하지만 저게 가능하다.

이를 어떻게 이해해야 하는지.






## ArrayList

다른 컬렉션 공부를 다 하면 1권을 못나가니까 일단 질문에 대해서만.

>  질문 : Arraylist 가 꽉 차면 새로운 공간을 만들고 기존 값을 복사한다. 이럴때의 Big O 는 ?

ArrayList 가 무엇인가


ArrayList 의 메소드들은 무엇이 있는가 -> 일단 Object 로 가자 왜나하면 모든 클래스들은 Object 를 최상단으로 상속받음.

ArrayList 가 꽉차면 어떤 일이 벌어지는가


