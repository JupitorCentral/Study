## Test

### JUnit

테스트를 위한 다양한 어노테이션 지원

#### @Test
-> 메서드에 이게 붙어야 테스트 실행이 됨

#### BeforeEach (JUnit 5), Before (JUnit 4)

@BeforeEach -> 각 테스트 메서드 실행 전 호출되는 메서드
@BeforeAll -> 모든 테스트 시작전 실행되는 메서드 

그러니까 실행흐름이 테스트 메서트가 test1, test2, test3 이리 있으면

BeforeAll -> BeforeEach -> test1 -> BeforeEach -> test2 -> BeforeEach -> test3

이 외에 @AfterEach, @BeforeAll, @AfterAll 있음
-> 하나의 클래스 내가 범위.

#### 특정 메서드에만 BeforeEach 를 사용하려면

#####  Nested Class

JUnit 5의 Nested annotation을 사용하면 특정 테스트 메서드 그룹에만 BeforeEach를 적용할 수 있음. 
Nested 클래스 내부에 BeforeEach를 선언하면 해당 클래스 내부의 테스트에만 실행됨

```java
import org.junit.jupiter.api.*;

class UserServiceTest {
    
    @Test
    void testWithoutSetup() {
        // 이 테스트는 특별한 setup 없이 실행됨
        System.out.println("Test without setup");
    }
    
    @Nested
    class DatabaseTests {
        
        @BeforeEach
        void initDatabase() {
            // 이 setup은 DatabaseTests 클래스 내부의 테스트에만 실행됨
            System.out.println("Database initialized");
        }
        
        @Test
        void testDatabaseQuery() {
            System.out.println("Testing database query");
        }
        
        @Test
        void testDatabaseInsert() {
            System.out.println("Testing database insert");
        }
    }
    
    @Nested
    class CacheTests {
        
        @BeforeEach
        void initCache() {
            // 이 setup은 CacheTests 클래스 내부의 테스트에만 실행됨
            System.out.println("Cache initialized");
        }
        
        @Test
        void testCacheHit() {
            System.out.println("Testing cache hit");
        }
    }
}

== 실행 흐름 ==
Test without setup
Database initialized
Testing database query
Database initialized
Testing database insert
Cache initialized
Testing cache hit
```

##### ## Private Helper 메서드 사용

특정 테스트에만 필요한 setup 로직은 private helper 메서드로 만들어서 명시적으로 호출할 수 있음. 
이 방법은 setup 로직이 간단하거나 소수의 테스트에만 필요할 때 유용함.

```java
import org.junit.jupiter.api.Test;

class PaymentServiceTest {
    
    @Test
    void testNormalPayment() {
        // 일반 결제는 특별한 setup 필요 없음
        System.out.println("Testing normal payment");
    }
    
    @Test
    void testInternationalPayment() {
        setupInternationalPayment(); // helper 메서드 직접 호출
        System.out.println("Testing international payment");
    }
    
    @Test
    void testCryptoCurrencyPayment() {
        setupCryptoPayment(); // 다른 helper 메서드 호출
        System.out.println("Testing crypto payment");
    }
    
	// Private Helper 메서드
    private void setupInternationalPayment() {
        System.out.println("Setting up currency converter");
        System.out.println("Setting up exchange rate API");
    }
    
    // Private Helper 메서드
    private void setupCryptoPayment() {
        System.out.println("Setting up blockchain connection");
        System.out.println("Setting up wallet");
    }
}
```


##### ## Tag와 BeforeEach 조합

JUnit 5의 Tag annotation을 사용해서 테스트를 그룹화하고, BeforeEach 내부에서 조건부로 setup을 실행할 수 있음. 
TestInfo parameter를 사용하면 현재 실행 중인 테스트의 tag 정보를 확인할 수 있음

```java
import org.junit.jupiter.api.*;

class OrderServiceTest {
    
    @BeforeEach
    void conditionalSetup(TestInfo testInfo) {
        if (testInfo.getTags().contains("database")) {
            System.out.println("Database setup executed");
            // 데이터베이스 초기화 로직
        }
        
        if (testInfo.getTags().contains("external-api")) {
            System.out.println("External API setup executed");
            // 외부 API mock 설정
        }
    }
    
    @Test
    @Tag("database")
    void testOrderCreation() {
        System.out.println("Testing order creation");
    }
    
    @Test
    @Tag("database")
    @Tag("external-api")
    void testOrderWithShipping() {
        System.out.println("Testing order with shipping");
    }
    
    @Test
    void testOrderValidation() {
        // tag가 없으므로 조건부 setup이 실행 안 됨
        System.out.println("Testing order validation");
    }
}
```

##### ## Custom Extension 사용 (고급)

JUnit 5의 Extension API를 사용하면 custom annotation을 만들어서 특정 조건에서만 setup을 실행할 수 있음. 이 방법은 복잡하지만 재사용성이 높음.

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.*;
import java.lang.annotation.*;

// Custom annotation 정의
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(DatabaseSetupExtension.class)
@interface WithDatabaseSetup {
}

// Extension 구현
class DatabaseSetupExtension implements BeforeEachCallback {
    
    @Override
    public void beforeEach(ExtensionContext context) {
        System.out.println("Custom database setup for: " 
            + context.getDisplayName());
        // 데이터베이스 setup 로직
    }
}

// 사용 예시
class ProductServiceTest {
    
    @Test
    void testProductValidation() {
        // setup 없이 실행됨
        System.out.println("Testing product validation");
    }
    
    @Test
    @WithDatabaseSetup
    void testProductCreation() {
        // DatabaseSetupExtension이 자동 실행됨
        System.out.println("Testing product creation");
    }
    
    @Test
    @WithDatabaseSetup
    void testProductUpdate() {
        // DatabaseSetupExtension이 자동 실행됨
        System.out.println("Testing product update");
    }
}
```

커스텀 어노테이션에 속성이 있는 경우

```java
import org.junit.jupiter.api.Test;
import java.lang.annotation.*;
import java.lang.reflect.Method;

// 1. Annotation 정의
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface TestData {
    String username();
    String password();
    String expectedResult() default "success";
}
// 참고로 interface 는 일반 필드 (instance variable 을 가질 수 없음), 상수는 가질 수 있음

// 2. 테스트 클래스
class LoginTest {
    
    @Test
    @TestData(username = "admin", password = "admin123")
    void testAdminLogin() throws Exception {
        // 현재 실행 중인 메서드 찾기
        Method method = this.getClass()
            .getMethod("testAdminLogin");
        
        // annotation 가져오기
        TestData data = method.getAnnotation(TestData.class);
        
        // 값 읽기 (메서드 호출)
        String username = data.username();        // "admin"
        String password = data.password();        // "admin123"
        String expected = data.expectedResult();  // "success" (기본값)
        
        // 테스트 로직
        String result = login(username, password);
        
        assert result.equals(expected);
    }
    
    @Test
    @TestData(username = "user", password = "user123", expectedResult = "login successful")
    void testUserLogin() throws Exception {
        Method method = this.getClass()
            .getMethod("testUserLogin");
        TestData data = method.getAnnotation(TestData.class);
        
        String result = login(data.username(), data.password());
        
        assert result.equals(data.expectedResult());
    }
    
    private String login(String username, String password) {
        if ("admin".equals(username) && "admin123".equals(password)) {
            return "success";
        } else if ("user".equals(username) && "user123".equals(password)) {
            return "login successful";
        }
        return "failed";
    }
}

```

interface 는 상수는 가질수 있기때문에

```java
@interface TestData {
    // ✅ 가능 - static final 상수
    String DEFAULT_USERNAME = "admin";
    int MAX_RETRY = 3;
    
    // ✅ 가능 - 메서드 (속성)
    String username() default DEFAULT_USERNAME;
    String password();
}

@TestData(username = TestData.DEFAULT_USERNAME, password = "123")
void test() { }

// 또는 다른 곳에서도 재사용
String user = TestData.DEFAULT_USERNAME;
```






####  특정 환경, 조건에 대해서만 테스트

	운영체제 기반 (OS-based)​
		EnabledOnOs: 특정 운영체제에서만 실행
		DisabledOnOs: 특정 운영체제에서 실행 안 함
	Java 버전 기반 (JRE-based)​
		EnabledOnJre: 특정 Java 버전에서만 실행
		DisabledOnJre: 특정 Java 버전에서 실행 안 함
		EnabledForJreRange: Java 버전 범위 지정
	시스템 속성 기반 (System Property)​
		EnabledIfSystemProperty: 시스템 속성이 특정 값과 일치하면 실행
		DisabledIfSystemProperty: 시스템 속성이 특정 값과 일치하면 실행 안 함
	등등...

- Spring 전용 Annotation
	Spring Test에서는 추가로 다음 annotation들을 제공함:​
		EnabledIf (Spring): SpEL expression을 사용한 조건부 실행
		DisabledIf (Spring): SpEL expression을 사용한 조건부 비활성화

```java
import org.springframework.test.context.junit.jupiter.EnabledIf;
import org.springframework.test.context.junit.jupiter.DisabledIf;

class SpringConditionalTests {
    
    @Test
    @EnabledIf(expression = "#{systemProperties['os.name'].toLowerCase().contains('windows')}", 
               loadContext = true)
    void testOnlyOnWindows() {
        // SpEL expression으로 조건 판단
    }
    
    @Test
    @DisabledIf("#{environment['spring.profiles.active'] == 'prod'}")
    void skipInProduction() {
        // production 환경에서는 실행 안 함
    }
}
```


#### @DisplayName 

테스트 이름을 개발자 친화적인 테스트 이름으로 정할 수 있음

```java
@Test
@DisplayName("사용자 등록 성공 테스트")
void testUserRegistration() {
    assertTrue(3 > 0);
}
```


#### Assertions

Assertions는 테스트의 예상 결과와 실제 결과를 비교하여 검증하는 메서드들이다.

##### assert의 의미

assert는 ‘단언하다’ 또는 ‘확신하다’라는 뜻을 가짐. 프로그래밍에서는 **assert문**이 프로그램의 특정 지점에서 "이 조건은 반드시 참이어야 한다"고 주장하는 역할을 함.​

예시를 들어 쉽게 설명하면,  
“이 시점에서 값이 null이면 안 돼!” 라는 자신의 믿음을 코드로 표현하는 것임.

실제로 코드에서 assert가 나오면, 아래처럼 동작함:

- assert 뒤 조건이 참(true)이면 아무 일도 일어나지 않음.
- 거짓(false)이면 즉시 오류(AssertionError 등)를 던짐.​
- 이것은 디버깅, 테스트, 내부 상태 확인에 사용됨.

##### 여러 assertion 들

`assertEquals(expected, actual)` 두 값이 같은지 검증한다.​

```java
@Test
public void testUserName() {
    String expected = "John";
    String actual = "John";
    assertEquals(expected, actual);
}
```

`assertNotNull(object)` 객체가 null이 아닌지 검증한다.​

```java
@Test
public void testFindUser() {
    User user = userService.findById(1L);
    assertNotNull(user);
}
```

`assertTrue(condition)` 조건이 참인지 검증한다.

```java
@Test
public void testAge() {
    int age = 25;
    assertTrue(age > 18);
}
```

`assertThrows(exception, executable)` 특정 예외가 발생하는지 검증한다.

```java
@Test
public void testInvalidInput() {
    assertThrows(IllegalArgumentException.class, () -> {
        Integer.parseInt("abc");
    });
}
```

`assertThrows(IllegalArgumentException.class, () -> { Integer.parseInt("abc"); });`  
이렇게 작성하면, 아래와 같은 규칙이 적용됨.

- Integer.parseInt("abc");는 "abc"가 숫자가 아니기 때문에 실행하면 반드시 예외가 발생함.
    
- 첫 번째 인자인 IllegalArgumentException.class는, "이 코드에서 IllegalArgumentException이 반드시 발생해야 성공"이란 뜻임.
    
- 만약 Integer.parseInt("abc")에서 다른 예외가 발생하거나, 예외가 아예 발생하지 않으면 테스트는 실패함.
    

즉, "코드 실행 시 IllegalArgumentException이 발생하면 테스트 성공, 그렇지 않으면 실패함."  
이 구조임.


`assertThat()` AssertJ 라이브러리와 함께 사용되며, 더 읽기 쉬운 assertion을 작성할 수 있다.

```java
@Test
public void testString() {
    String message = "Hello World";
    assertThat(message).isEqualTo("Hello World");
}
```

#### ## 테스트 자동화

JUnit의 가장 큰 장점 중 하나는 테스트 자동화다. 코드 변경 후 기존 기능이 정상적으로 작동하는지 빠르게 검증할 수 있다

빌드 도구 통합 Maven, Gradle과 같은 빌드 도구에 통합되어 빌드 시 자동으로 테스트를 실행할 수 있다.

CI/CD 파이프라인 통합 Jenkins, GitHub Actions 등의 CI/CD 도구와 연동하여 코드 커밋 시마다 자동으로 테스트를 실행할 수 있다


#### Spring Boot 테스팅 통합

Spring Boot는 JUnit과의 통합을 쉽게 만들어주는 여러 기능을 제공한다.​

`@SpringBootTest` Spring Boot 애플리케이션 컨텍스트를 로드하여 통합 테스트를 수행할 수 있다.​
-> 내가 실행하는 이 테스트가 가능한 실제 어플리케이션 환경과 거의 똑같이 작동하길 원한다라고 명시하느 ㄴ것

`TestRestTemplate` REST API 엔드포인트를 테스트할 수 있는 편리한 클래스를 제공한다.​

`@Autowired` 테스트에 필요한 Spring Bean을 주입받을 수 있다

- 예를 들어, `seat.reserve()` 같은 메서드 호출 후 JPA가 내부적으로 변경을 감지해서 DB에 반영하는 트랜잭션 처리 부분을 진짜로 검증하려면 전체 스프링 컨텍스트가 실제로 다 돌아가야 합니다.
    
- 그래서 테스트를 실행하는 시점에 애플리케이션에서 사용하는 모든 빈과 설정, 데이터베이스 연동 상태까지 실제로 잡아서 테스트해야만 검증할 수 있는 것이죠.

#### 생성자 주입(Constructor Injection)이 테스트하기 좋은 이유

##### ## Setter Injection 사용 시 (테스트하기 어려움)

```java
// 프로덕션 코드
public class TransferService {
    private AccountRepository accountRepository;
    
    @Autowired
    public void setAccountRepository(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }
    
    public void transfer(Account from, Account to, Money amount) {
        accountRepository.save(from);
        accountRepository.save(to);
    }
}

// 테스트 코드 - Spring Container가 필요
@SpringBootTest
public class TransferServiceTest {
    @Autowired
    private TransferService transferService;
    
    @Test
    void testTransfer() {
        // Spring이 의존성을 주입해야만 테스트 가능
    }
}
```


##### Constructor Injection 사용 시 (테스트하기 쉬움)

```java
// 프로덕션 코드
public class TransferService {
    private final AccountRepository accountRepository;
    
    public TransferService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }
    
    public void transfer(Account from, Account to, Money amount) {
        accountRepository.save(from);
        accountRepository.save(to);
    }
}

// 테스트 코드 - Spring Container 불필요
public class TransferServiceTest {
    @Test
    void testTransfer() {
        // 1. Mock 객체를 직접 생성
        AccountRepository mockRepository = mock(AccountRepository.class);
        
        // 2. 생성자로 직접 주입 - Spring 없이도 가능!
        TransferService service = new TransferService(mockRepository);
        
        // 3. 테스트 실행
        Account from = new Account("A", 1000);
        Account to = new Account("B", 500);
        service.transfer(from, to, new Money(100));
        
        // 4. 검증
        verify(mockRepository, times(2)).save(any(Account.class));
    }
}
```

	
Setter Injection의 문제점

	1. 의존성 주입 시점이 분리됨: 객체 생성 후에 setter를 통해 주입되므로, 테스트에서 의존성을 주입하지 않은 채로 메서드를 호출할 위험이 있습니다.​​

	2. Spring Container 의존성: Setter injection은 Spring의 @Autowired를 통해 동작하므로, 단위 테스트에서도 Spring Container를 띄워야 합니다.​


### Test Pattern

Given : 테스트 데이터 준비
When : 테스트 실행
Then : 결과 검증

```java
public class ReservationQueryServiceTest {  
  
    @Mock  
    private SeatRepository seatRepository;  
  
    @InjectMocks  
    private ReservationQueryService reservationQueryService;  
  
    @BeforeEach  
    void setUp() {  
       MockitoAnnotations.openMocks(this);  
    }  
  
    @Nested  
    @DisplayName("statusOfSeatsOfTheEvent 메서드는")  
    class StatusOfSeatsOfTheEventTest {  
  
       @Test  
       @DisplayName("이벤트에 좌석이 없으면 빈 리스트를 반환한다")  
       void shouldReturnEmptyListWhenNoSeatsExist() {  
          Long eventId = 1L;  
          ReservationBookingRequest request = createRequest(eventId);  
  
          when(seatRepository.findByEvent_Id(eventId)).thenReturn(List.of());  
  
          List<SeatStatusResponse> result = reservationQueryService.statusOfSeatsOfTheEvent(request);  
  
          assertThat(result).isEmpty();  
          verify(seatRepository).findByEvent_Id(eventId);  
       }  
    }  
  
    private ReservationBookingRequest createRequest(Long eventId) {  
       ReservationBookingRequest request = new ReservationBookingRequest();  
       request.setEventId(eventId);  
       return request;  
    }  
}
```

method 를 감싸고 있는 class 에는 @Test 붙이면 안됨


### Mockito @Mock

Mockito 라이브러리가 제공하는 어노테이션, 실제 객체의가짜 버전을 생성함.
(Mockito 는 JUnit 에 속하는게 아니라 별개의 프레임워크임)

#### 핵심 기능

1. 외부 의존성 제거. DB, 외부 API 등 실제 연결이 필요한 객체를 Mock 으로 대체함.

2. 테스트 코드 반복을 줄이고 가독성을 높임


#### 동작 메커니즘

- 테스트 시 실제 객체의 복잡한 동작이나 외부 의존성을 대신해 동작을 흉내 내도록 만듦.
    
- 즉, 해당 객체의 메서드 호출을 가로채서 사전에 지정한 동작이나 결과를 반환하게끔 함.


#### 사용법

@Mock 하고 싶은 필드에 어노테이션 붙임

둘째, `MockitoAnnotations.openMocks(this)`를 호출하여 Mock 객체를 초기화합니다. 이는 보통 `@BeforeEach` 메서드에서 실행합니다

```java
@BeforeEach
void setUp() {
   MockitoAnnotations.openMocks(this);
}
```

셋째, `when().thenReturn()` 또는 `doReturn().when()` 메서드로 Mock 객체의 동작을 정의합니다.

```java
when(seatRepository.findByEvent_Id(eventId)).thenReturn(List.of());
```

#### @Mock vs @MockBean 차이

`@Mock`은 순수 Mockito 어노테이션이고, `@MockBean`은 Spring Boot 전용입니다. `@MockBean`은 Spring ApplicationContext에 Mock 객체를 Bean으로 등록하여 실제 Bean을 대체하지만, `@Mock`은 Spring과 무관하게 Mockito만으로 동작합니다

|                | @Mock               | @MockBean              |
| -------------- | ------------------- | ---------------------- |
| 제공자            | Mockito             | Spring Test            |
| Spring Context | 필요 없음               | 필요함                    |
| 사용 시기          | 단위 테스트 (순수 비즈니스 로직) | 통합 테스트, Controller 테스트 |
| 속도             | 빠름 (Context 로딩 없음)  | 느림 (Context 로딩 필요)     |
| 예시             | Service 클래스 로직 테스트  | @SpringBootTest와 함께 사용 |


#### ## 언제 @Mock을 쓰나

단위 테스트(unit test)를 작성할 때 사용합니다. 
**Spring Context가 전혀 필요 없고**, 오직 JUnit과 Mockito만으로 특정 클래스의 비즈니스 로직을 테스트하는 경우

이 방식의 장점은 테스트 속도가 매우 빠르다는 점입니다. Spring Context를 로딩하지 않기 때문

#### ## 언제 @MockBean을 쓰나

통합 테스트(integration test)나 Spring MVC Controller 테스트처럼 Spring Context가 필요한 경우 사용합니다

Controller를 테스트하는데 실제 데이터베이스는 연결하고 싶지 않을 때 Repository만 `@MockBean`으로 대체합니다:

```java
@SpringBootTest
@AutoConfigureMockMvc
public class UserMockBeanTests {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    UserRepository userRepository;  // Spring Context에 Mock Bean 등록
    
    @Test
    void saveUsers() throws Exception {
        when(userRepository.save(any)).thenReturn(user);
        // MockMvc로 실제 HTTP 요청 테스트
    }
}
```

- MockBean 사용 시 주의사항

`@MockBean`을 남용하면 안 됩니다. Spring Context를 매번 새로 생성하기 때문에 테스트 속도가 느려집니다.


#### @InjectMocks

테스트할 실제 객체에는 @Mock 이 아니라 이 어노테이션을 써야함

@InjectMocks는 해당 테스트 대상 객체(여기서는 ReservationBookingService)를 생성할 때,  
그 객체가 의존하는 필드(클래스 내부에 선언된 UserManagementService, ReservationQueryService, ReservationRepository 등)에  
테스트에서 @Mock으로 만든 객체를 자동으로 주입함.  
즉, ReservationBookingService가 의존하는 타입들이 이미 @Mock으로 생성된 경우,  
그 Mock 객체들이 필드 주입(setter나 생성자 등) 방식으로 자동 할당됨.

ReservationBookingService가 의존하는 여러 객체들을  
@Mock으로 따로 만들어 놓고, ReservationBookingService 생성 시 자동으로 껴주는 기능이라고 생각하면 됨.  
그래서 "그 bean이 의존하는 의존성들을 Mock 으로 주입하는 것"이 맞음.




### H2 in-memory Database

Spring Boot 는 테스트 환경에서 명시적 설정이 없으면 자동으로 H2 를 쓴다.

정확히 말하면:

	jdbc:h2:mem:testdb 형식으로 설정하면 JVM 메모리 안에만 존재함
	
	애플리케이션(또는 테스트)이 종료되면 데이터가 완전히 사라짐 (In-Memory 특성)​​
	
	DB_CLOSE_DELAY=-1 파라미터를 쓰면 애플리케이션 생명주기 동안 DB를 유지하지만, 결국 앱 종료 시 삭제됨​

#### 테스트 시작/종료 시 생성/삭제 여부

맞음. H2 인메모리 DB는 **테스트 시작하면 생성되고, 테스트 끝나면 삭제됨**.

#### 클래스마다 생성? ApplicationContext마다 생성?

기본적으로 **ApplicationContext마다 생성됨**. 하지만 설정에 따라 **각 테스트 클래스마다** 또는 **각 테스트 메서드마다** 생성되도록 바꿀 수 있음

#### 추가로 알아둘 것

H2를 테스트에 쓰는 건 편하긴 한데, **실제 production DB (PostgreSQL, MySQL 등)와 
SQL 문법이나 동작이 다를 수 있음**. 
그래서 진짜 프로덕션 환경을 더 정확하게 테스트하려면 **Testcontainers** 같은 걸 써서 실제 DB를 도커로 띄워서 테스트하는 게 더 나음.

##### 그럼 JPA 쓸때는 상관없는지 ?

아니, JPA 쓴다고 해서 SQL 문법 차이가 완전히 무시되는 건 아님.

핵심은 이거임:

	JPA는 데이터베이스 독립적인 추상화 레이어지만, 결국 실행 시점에 데이터베이스 방언(dialect)에 맞는 SQL로 변환됨.​
	
	그런데 H2는 경량 인메모리 DB라 production DB의 방언과 완벽히 일치하지 않음. 일부 함수, 쿼리 최적화, 조인 동작 등이 다를 수 있음.​
	
	그래서 JPA를 쓰더라도, 복잡한 native query나 방언에 민감한 기능 사용 시, H2에서 테스트 성공해도 production DB에서 오류가 날 가능성 존재.​
	
	일반적인 CRUD나 단순 JPA 메서드는 큰 문제 없지만, DB 고유 기능까지 테스트하려면 production DB 환경 또는 Testcontainers 같은 도구로 실제 DB 환경 테스트 필요임.​

요약하면:
	JPA가 SQL 문법 차이를 많이 줄여주긴 하지만, 완전히 없애진 못한다. 특히 native query나 DB 고유 기능은 주의해야 한다는 뜻임.

-> 그래서 난 test 용 postgresql, redis db 를 만들어버렸다. 그리고 docker 로 띄웠다.


