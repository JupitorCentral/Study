## JPA

-> RDBMS 를 사용하는 방식을 정의한 interface

자바 ORM 기술의 표준. 

java persistence API

db 데이터를 자바 객체로 쓰겠다라는 의미.

#### persistence ?

'영속성'
프로그램이 종료되어도 계속 남아있는 속성.

자바 객체의 정보를 DB 에 영구저장하는 규약. 을 의미하게된다.


#### 자바 ORM ?

Object-relational Mapping 
자바 객체와 RDBMS 를 자동으로 연결해주는 기술

객체지향과 RDBMS 의 차이를 해소시키는 역할.

#### Hibernate ?

프레임워크로써, JPA 구현체 중 하나.


### JPA vs Spring Data JPA

JPA 는 method name 으로 그 쿼리를 자동생성해주는 것에 의의가 있음.

```java
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

public class SeatService {
    @PersistenceContext
    private EntityManager em;
    
    // 저장, 조회 메서드에서 em 사용
}
```

```java
Seat seat = new Seat("A-10"); // seatNumber만 생성자에 넣음
em.persist(seat);  // DB에 INSERT 실행 준비
```

```java
Seat seat = em.find(Seat.class, 1L); // id가 1인 Seat 조회
```

근데 Spring Data JPA 를 쓰면 Entity Manager 나 @PersistenceContext 를 안써도 됨.

```java
public interface SeatRepository extends JpaRepository<Seat, Long> {
    // 알아서 save, findById, findAll 등 여러 메서드 자동 제공
}
```

```java
@Autowired  // 또는 생성자 주입
private SeatRepository seatRepository;

@Test
void 저장_조회_테스트() {
    Seat seat = new Seat("A-10");
    seatRepository.save(seat);  // 저장
    Seat found = seatRepository.findById(seat.getId()).orElse(null); // 조회
}
```

추상화가 더 들어간다고 생각하면 된다.


## Spring Data JPA

Repository interface 기반으로
jpaRepository 를 상속받으면 기본적인 CRUD 사용 가능

메서드의 이름만 잘 작성하면 Spring Data JPA 가 그에 맞는 SQL/JPA 쿼리를 자동 생성.


Spring Data JPA 사용의 핵심은
JPA 의 자동 쿼리 생성과 함께 
쿼리 자체를 직접쓰는 방식(@Query)과 혼합하여 상황에 따라 적절히 사용하는 것.

### How to use

#### interface 정의

제너릭 타입 2개 -> Repository 가 다룰 Entity 클래스, Entity 의 ID 타입

정의만 하면 다음 메소드 사용 가능

```java
// 저장
seatRepository.save(seat);              // 엔티티 저장
seatRepository.saveAll(seats);          // 여러 엔티티 한 번에 저장

// 조회
seatRepository.findById(1L);            // ID로 조회
seatRepository.findAll();               // 전체 조회
seatRepository.existsById(1L);          // ID로 존재 여부 확인

// 삭제
seatRepository.delete(seat);            // 엔티티 삭제
seatRepository.deleteById(1L);          // ID로 삭제
seatRepository.deleteAll();             // 전체 삭제

// 개수
seatRepository.count();                 // 전체 개수 반환
```


#### 메소드 이름으로 쿼리 자동 생성

```java
findBy + 필드명 + (조건키워드)
```

```java
public interface SeatRepository extends JpaRepository<Seat, Long> {
    
    // seatNumber로 조회
    Seat findBySeatNumber(String seatNumber);
    
    // 이 메서드 이름만으로 Spring이 자동으로 다음 쿼리 생성:
    // SELECT * FROM seat WHERE seat_number = ?
}
```

```java
// 이 네 개는 완전히 동일합니다
List<Seat> findBySeatNumber(String seatNumber);
List<Seat> readBySeatNumber(String seatNumber);
List<Seat> queryBySeatNumber(String seatNumber);
List<Seat> getBySeatNumber(String seatNumber);
```

```java
// seatNumber가 정확히 일치
Seat findBySeatNumber(String seatNumber);

// isAvailable이 true인지 확인
List<Seat> findByIsAvailableTrue();

// price가 null인지 확인
List<Seat> findByPriceIsNull();
```

```java
// seatNumber에 특정 문자열 포함
List<Seat> findBySeatNumberContaining(String keyword);

// seatNumber가 특정 문자열로 시작
List<Seat> findBySeatNumberStartingWith(String prefix);

// seatNumber가 특정 문자열로 끝남
List<Seat> findBySeatNumberEndingWith(String suffix);
```

```java
// price가 특정 값보다 큰
List<Seat> findByPriceGreaterThan(BigDecimal price);

// price가 특정 값보다 작은
List<Seat> findByPriceLessThan(BigDecimal price);

// price가 범위 안에 있는
List<Seat> findByPriceBetween(BigDecimal min, BigDecimal max);
```

```java
// seatNumber와 isAvailable 둘 다 만족
Seat findBySeatNumberAndIsAvailable(String seatNumber, boolean available);

// seatNumber 또는 row 중 하나만 만족
List<Seat> findBySeatNumberOrRow(String seatNumber, String row);

// 복잡한 조합도 가능
List<Seat> findByRowAndIsAvailableTrueAndPriceGreaterThan(
    String row, BigDecimal price
);
```

```java
public interface SeatRepository extends JpaRepository<Seat, Long> {
    
    // 좌석 번호로 찾기
    Seat findBySeatNumber(String seatNumber);
    
    // 예약 가능한 좌석만 조회
    List<Seat> findByIsAvailableTrue();
    
    // 특정 행(row)의 예약 가능한 좌석 조회
    List<Seat> findByRowAndIsAvailableTrue(String row);
    
    // 가격 범위로 좌석 찾기
    List<Seat> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);
}
```


#### 두 테이블을 조인할때 어디에 선언하는가 ? -> Aggregate Root

두 테이블 A, B 에 대해서 A 와 B 를 조인한 결과가 Entity A 의 형태로 반환되면 (Aggregate Root : A)
테이블 A 에 대한 Repository 에서 해당 메서드를 정의한다.



#### @Query 

JPQL , NativeSQL 을 작성하게 해줌

```java
public interface SeatRepository extends JpaRepository<Seat, Long> {
    
    @Query("SELECT s FROM Seat s WHERE s.seatNumber = ?1")
    Seat findBySeatNumber(String seatNumber);
}
```

##### 파라미터 바인딩

```java
@Query("SELECT s FROM Seat s WHERE s.row = ?1 AND s.isAvailable = ?2")
List<Seat> findByRowAndAvailable(String row, boolean available);
```

```java
@Query("SELECT s FROM Seat s WHERE s.row = :row AND s.isAvailable = :available")
List<Seat> findByRowAndAvailable(@Param("row") String row, 
                                   @Param("available") boolean available);
```

##### 예시

```java
@Query("SELECT s FROM Seat s " +
       "WHERE s.isAvailable = true " +
       "AND s.price BETWEEN :minPrice AND :maxPrice " +
       "ORDER BY s.seatNumber")
List<Seat> findAvailableSeatsInPriceRange(
    @Param("minPrice") BigDecimal minPrice,
    @Param("maxPrice") BigDecimal maxPrice
);
```

```java
@Query("SELECT s FROM Seat s WHERE s.seatNumber LIKE %:keyword%")
List<Seat> searchSeatsByNumber(@Param("keyword") String keyword);

@Query("SELECT COUNT(s) FROM Seat s WHERE s.isAvailable = true")
long countAvailableSeats();
```

```java
@Query(value = "SELECT * FROM seat WHERE is_available = true", 
       nativeQuery = true)
List<Seat> findAvailableSeatsNative();
```


##### 언제 @Query 를 쓸까?

**메서드 이름으로 만들기 어려운 경우**​

- 복잡한 JOIN이 필요할 때
- 집계 함수(COUNT, SUM, AVG)를 사용할 때
- 여러 조건이 복잡하게 섞여있을 때
- 성능 최적화를 위해 특정 컬럼만 조회할 때
    
**간단한 조회라면 메서드 이름 규칙을 사용하고, 복잡하면 @Query를 사용**하는 게 일반적


#### Entity 관계 매핑 : @ManyToOne과 @OneToMany

- **@OneToOne**: 일대일 (사용자 1명 - 프로필 1개)
    
- **@OneToMany**: 일대다 (사용자 1명 - 예약 여러 개)
    
- **@ManyToOne**: 다대일 (예약 여러 개 - 사용자 1명)
    
- **@ManyToMany**: 다대다 (학생 여러 명 - 강의 여러 개)


```java
@Entity
public class Reservation {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String reservationNumber;
    
    // 여러 예약(Many)이 한 명의 사용자(One)에게 속함
    @ManyToOne
    @JoinColumn(name = "user_id")  // 실제 테이블의 외래키 컬럼명
    private User user;
    
    // 생성자, getter, setter
}
```

이 어노테이션만 있으면 단방향 관계 성립.

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    
    // 한 명의 사용자(One)가 여러 예약(Many)을 가짐
    @OneToMany(mappedBy = "user")
    private List<Reservation> reservations = new ArrayList<>();
    
    // 생성자, getter, setter
}
```

-  핵심 포인트

	- `@OneToMany`는 **1쪽 Entity**에 붙입니다.​
	- **컬렉션 타입**(List, Set)으로 선언해야 합니다.​
	- `mappedBy = "user"`는 **Reservation Entity의 user 필드**가 관계의 주인임을 나타냅니다.​	    
	- 빈 컬렉션으로 초기화해야 NullPointerException을 방지할 수 있습니다


-> 양방향 관계

```java
// Reservation.java (관계의 주인)
@Entity
public class Reservation {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}

// User.java (역방향)
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToMany(mappedBy = "user")
    private List<Reservation> reservations = new ArrayList<>();
}

```

- 관계의 주인

	- 외래키가 있는 쪽(@ManyToOne)이 관계의 주인입니다.​
	    
	- 주인 쪽에서만 외래키를 관리(등록, 수정)할 수 있습니다.​
	    
	- `mappedBy`가 있는 쪽은 **읽기만 가능**합니다



```java
@Service
public class ReservationService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ReservationRepository reservationRepository;
    
    public void createReservation(Long userId, String reservationNumber) {
        // 사용자 조회
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        // 예약 생성
        Reservation reservation = new Reservation();
        reservation.setReservationNumber(reservationNumber);
        reservation.setUser(user);  // 관계 설정
        
        reservationRepository.save(reservation);
    }
    
    public List<Reservation> getUserReservations(Long userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        // 양방향 관계로 접근 가능
        return user.getReservations();
    }
}
```


 3. findById() - Repository 메서드

```java
User user = userRepository.findById(userId)
```

- **무엇인가?**
    
    - `JpaRepository`가 기본으로 제공하는 메서드입니다.        
    - DB에서 주어진 ID로 Entity를 조회합니다.
        
- **어떤 쿼리가 실행되는가?**

```sql
SELECT * FROM user WHERE id = ?
```

- **반환 타입은?**
    
    - `Optional<User>`를 반환합니다.
        
    - 왜 `User`가 아니라 `Optional<User>`일까요? → **값이 없을 수도 있기 때문**입니다.
        

---

4. orElseThrow() - Optional 처리
```java
    .orElseThrow(() -> new RuntimeException("User not found"));
```

- **무엇인가?**
    
    - `Optional` 객체에서 값을 꺼내는 메서드입니다.
        
- **어떻게 동작하는가?** (educative)
    
    - **값이 있는 경우**: 그 값(`User` 객체)을 반환합니다.
        
    - **값이 없는 경우**: 괄호 안의 예외를 던집니다.
        
- **코드 분석**

```java
() -> new RuntimeException("User not found")
```
	
    - 이것은 람다식입니다.
        
    - "값이 없으면 이 예외를 던져라"는 의미입니다. (geeksforgeeks)
        
- **왜 이렇게 쓰는가?**
    
    - 값이 없을 때 `null`을 반환하면 나중에 `NullPointerException`이 발생할 수 있습니다.
        
    - 명확한 예외 메시지로 문제를 빠르게 파악할 수 있습니다. (educative)
        

---

5. 객체 생성과 세터

```java
Reservation reservation = new Reservation();
reservation.setReservationNumber(reservationNumber);
reservation.setUser(user);
```

- **무엇인가?**
    
    - 일반적인 자바 객체 생성과 값 설정입니다.
        
    - `setUser(user)`로 관계를 설정합니다.
        
- **왜 중요한가?**
    
    - `setUser(user)`를 호출하면 `Reservation` 엔티티의 `user` 필드에 `User` 객체가 할당됩니다.
        
    - 저장할 때 이 관계가 DB의 **외래키(Foreign Key)**로 저장됩니다.
        

---

6. save() - 저장

```java
reservationRepository.save(reservation);
```

- **무엇인가?**
    
    - `JpaRepository`가 제공하는 저장 메서드입니다.
        
- **어떤 쿼리가 실행되는가?**
    
    SQL
    
    ```
    INSERT INTO reservation (reservation_number, user_id) VALUES (?, ?)
    ```
    
- **저장 후 어떻게 되는가?**
    
    - 저장이 완료되면 `reservation` 객체의 `id` 필드가 자동으로 채워집니다 (DB가 생성한 ID).
        
    - 저장된 객체가 반환됩니다 (필요하면 받아서 사용 가능).
        

---

-  전체 흐름 요약

	- **@Service**: Spring이 이 클래스를 서비스로 인식하고 Bean 등록 (geeksforgeeks)
	    
	- **@Autowired**: Spring이 Repository 자동 주입
	    
	- **findById()**: DB에서 `userId`로 `User` 조회
	    
	- **orElseThrow()**: 값이 없으면 예외, 있으면 `User` 반환 (geeksforgeeks+1)
	    
	- **new Reservation()**: 예약 객체 생성
	    
	- **setUser()**: `User`와의 관계 설정
	    
	- **save()**: DB에 저장 (geeksforgeeks)