
## Lombok

### @Getter, @Setter

getter setter 자동 생성

JPA Entity 에서는 조심해서 사용하라고 하네. Setter 를 무분별하게 쓰면 불변성이 깨질 수 있다고.

### @NoArgsConstructor, @AllArgsConstructor, @RequiredArgsConstructor

생성자 자동 생성

- `@NoArgsConstructor`: JPA Entity에 필수. JPA는 reflection으로 객체를 생성하므로 기본 생성자가 반드시 필요하다​
  파라미터가 없는 기본 생성자(default constructor)를 생성
    
- `@AllArgsConstructor`: 모든 필드를 초기화해야 할 때. 주로 `@Builder`와 함께 사용
  **모든 필드**에 대해 파라미터를 받는 생성자를 생성
    
- `@RequiredArgsConstructor`: `final` 필드나 `@NonNull` 필드만 초기화하는 생성자. 의존성 주입(DI)에서 자주 사용
  **일부 필드만** 파라미터로 받는 생성자를 생성
  
  1. 초기화되지 않은 `final` 필드 (non-initialized final fields)
  2. `@NonNull`로 표시되었지만 선언 시 초기화되지 않은 필드
  

**주의**: `@AllArgsConstructor`만 쓰면 기본 생성자가 사라진다. JPA Entity라면 반드시 `@NoArgsConstructor`를 함께 붙여야 한다.


#### @NoArgsConstructor는 왜 사용하나요?

`@NoArgsConstructor`를 사용하는 주된 이유는 여러 프레임워크가 객체를 생성할 때 **기본 생성자**를 필요로 하기 때문입니다.

##### JSON 역직렬화 (가장 중요)

Spring Boot에서 HTTP 요청의 JSON 데이터를 객체로 변환할 때를 예로 들 수 있습니다.

```java
// Controller
@PostMapping("/reservation")
public Response book(@RequestBody ReservationRequest request) {
    // JSON → ReservationRequest 객체로 변환
}
```

이 과정에서 Jackson 라이브러리(Spring Boot의 기본 JSON 라이브러리)는 다음과 같이 동작합니다.

1. **기본 생성자**로 빈 객체를 먼저 생성합니다. (`new ReservationRequest()`)
    
2. 이후 Setter를 통해 JSON의 필드 값을 주입하거나, 리플렉션(Reflection)을 통해 직접 필드에 값을 주입합니다.
    

만약 `ReservationRequest` 클래스에 기본 생성자가 없다면, Jackson이 첫 단계인 객체 생성을 하지 못해 **역직렬화에 실패**하고 오류가 발생합니다. ❌

### @Data

- `@Getter` (모든 필드)
    
- `@Setter` (모든 non-final 필드)
    
- `@ToString`
    
- `@EqualsAndHashCode`
    
- `@RequiredArgsConstructor`

의 조합

@Data 는 명시적이지 않아 가능한한 안쓰는게 좋다

#### @EqualsAndHashCode 의 문제

class B extends class A

일때, 

그냥 class B 에 선언해버리면 class B 에만 속하는모든 필드값만 가지로 hashcode 를 자동생성함.
즉 부모클래스의 값을 따지지 않음

또한, 모든 필드를 다 자동적용해버리기때문에
불필요한 값도 포함시켜버리게 됨.

주의해야함


### @Builder

Builder 패턴을 자동으로 구현 

```java
@Builder
public class User {
    private String name;
    private int age;
    private String email;
}

// 사용
User user = User.builder()
    .name("John")
    .age(30)
    .build();  // email은 null
```


Builder 어노테이션은 내부적으로 모든 필드에 대한 생성자가 필요하므로
@AllargsConstructor 가 필요함

### @ToString

`toString()` 메서드를 자동 생성

JPA Entity에서는 매우 위험하다. Lazy loading된 연관 관계를 건드려서 불필요한 쿼리가 발생하거나 `LazyInitializationException`이 발생할 수 있다

### @Slf4j

Logger를 자동으로 생성


### @Value

불변(immutable) 클래스를 만든다. 모든 필드가 `private final`이 되고, setter는 생성되지 않는다.


### @EqualsAndHashCode

equals()와 hashCode() 메서드 자동 생성