
## jsp 에서 Response 는 어떤 것을 담당하는 변수인가 ?


request 와는 반대로 웹 브라우저에 보내는 응답정보를 담는다.

response 의 기능은
- 헤더 정보 입력
-> setDateHeader

- 리다이렉트

### 웹 브라우저 캐시 제어를 위한 응답 헤더 입력

개발하다보면 DB 에 저장된 값이 브라우저에 출력되는 내용이 바뀌지 않을때가 있는데,
이는 브라우저의 캐싱 때문이다

-> a.jsp 에 요청을 했다가 다시 해당 페이지에 대해 요청했을때 a.jsp 요청에 대한 response 가 차이가 없다면
브라우저는 불필요하게 동일한 자원을 요청하지 않고 로컬 저장소에 출력을 저장함.

HTTP 는 어떤 헤더를 설정해서 캐싱유무를 설정할 수 있음.
- HTTP 응답헤더
	- Cache-Control
	- Pragma
	- Expires



## Tomcat 의 Thread Pool 은 왜 존재하는 것인가 ?


DB connection Pool 은 사용자의 요청에 따라 JDBC 를 통해 DB 에 연결시
DB 연결 자체는 TCP 를 사용하고, TCP 는 연결을 위해 3-way handshake 라는 비용이 발생하기 때문에
더 빠른 처리를 위해 연결을 미리 생성하는 것이다.

그리고 ThreadPool 은, 위와 비슷한 이유인데, 
마찬가지로 Client 의 request 에 따라 스레드를 생성하는 비용때문에 존재한다.

메모리 생성시 발생하는 비용들은

- Memory Allocation
  -> Thrad 마다 고유한 stack 을 할당해야 함
  
- OS kernel 개입
  -> Thread 생성은 user space 가 아닌 kernel space 에서 일어나서, context switching 이 발생한다
  (user space, kernel space 는 실행 레벨로써 각각 user mode, kernel mode를 의미함)
  
  만약 1000개의 thread 를 생성한다고 하면
  Kernel System call 이 1000번 발생
  
- Thread 초기화
  Thread Control Block, 스케쥴링 정보 설정 등
  
- Resource 할당
  Thread-local Storage, register set 등을 준비해야 함

메모리 할당 -> System Call -> Context Switching


Thread Pool을 만들어두면 Thread 를 매번생성하지 않고도 사용자의 요청을 처리할 수 있게 되는데, 이는 결국

- Thread 생성 및 소멸 비용이 없어짐
- 메모리할당/해제 오버헤드가 없음
- Kernel 개입 횟수가 줄어듦

```java
[User Mode]
1. Application code: new Thread() 호출
2. System call 준비 (syscall number, parameters를 register에 설정)
3. syscall instruction 실행
   ↓
[Mode Switch 발생: User Mode → Kernel Mode]
   ↓
[Kernel Mode]  
4. CPU가 kernel stack으로 전환
5. User space registers를 kernel stack에 저장 (context 보존)
6. Kernel의 thread creation code 실행
   - TCB 생성
   - Stack memory 할당
   - Scheduler에 등록
7. User space registers 복원
8. Return value를 rax register에 저장
   ↓
[Mode Switch 발생: Kernel Mode → User Mode]
   ↓
[User Mode]
9. Application code로 복귀
```

일반적으로 CPU 가 무엇을 실행한다는 것은 어떤 프로세스, 쓰레드이며 이에 해당하는 프로그램 코드를 실행한다는 것인데,
Thread 를 생성한다는 것은 이러한 프로그램 코드를 실행하는 것이 아니라 쓰레드를 생성하는 Kernel 코드를 실행하는 것이며
이에 따라 CPU 의 User mode -> Kernel mode 로의 Context Switching 이 발생한다는 것을 의미함.


## Filter vs Interceptor

### Jsp Programming 책에서 말하는 Filter

HTTP 요청과 응답을 변경할 수 있는 재사용 가능한 클래스.
jsp/서블릿을 실행하기 전에 요청이 올바른지, 자원에 접근할 수 있는 권한이 있는지 여부를 미리 처리할 수 있음.

### 사전 지식

Tomcat = 서블릿 컨테이너 + 웹 서버 
> "Tomcat is composed mainly of three components: (1) **Catalina, a servlet container**, (2) **Coyote, a web server**, and 
> (3) Jasper, a Jakarta Server Pages processor."

- 웹 서버
	- HTTP 프로토콜을 이해하고 처리하는 서버, 정적파일 (HTML, CSS, js, 이미지 등)을 그대로 전달하는게 주 역할
	- Tomcat 은 스레드풀을 사용함 (따라서 jsp, spring 모두 스레드풀을 사용함)
	- Apache HTTP server, Nginx 등도 Thread Pool 을 쓰지만 방식이 다름
- 서블릿 컨테이너
	- 서블릿 생명주기 관리 (init, service - 요청 처리, destory - 정리)
	- 요청 라우팅 - HTTP request 를 적절한 servlet 으로 매핑
	- 멀티 스레드 처리 - 스레드 풀에서부터 스레드를 가져와 Request 처리
	- 세션 관리
	- 보안 - 인증, 권한 체크

톰캣은 WAS 가 아니다 (Web Application Server).




Spring Boot 에서 
- jar 파일 : 내장 Tomcat 포함
	  java -jar myapp.jar 로 실행
- war (web archive) 파일 : Tomcat 제외하고 패키징,
	  class 파일 + HTML + JSP + 설정 파일 등을 담은 ZIP 압축 파일 (확장자가 .war 임)


SpringBoot 가 일반적으로 사용하는 ApplicationContext 타입
-> `AnnotationConfigServletWebServerApplicationContext`

Spring Boot는 `WebApplicationType`에 따라 자동으로 적절한 ApplicationContext를 선택
- **SERVLET** 타입 (spring-boot-starter-web 사용 시) → `AnnotationConfigServletWebServerApplicationContext` 생성[](https://docs.spring.io/spring-boot/reference/web/servlet.html)​
- **REACTIVE** 타입 (WebFlux 사용 시) → `AnnotationConfigReactiveWebServerApplicationContext` 생성[](https://stackoverflow.com/questions/62229265/what-is-a-default-spring-boot-application-context)​
- **NONE** 타입 (웹 기능 없는 일반 앱) → `AnnotationConfigApplicationContext` 생성[](https://stackoverflow.com/questions/62229265/what-is-a-default-spring-boot-application-context)​

java.lang.Object
	org.springframework.core.io.DefaultResourceLoader
		org.springframework.context.support.AbstractApplicationContext
			org.springframework.context.support.GenericApplicationContext
				org.springframework.web.context.support.GenericWebApplicationContext
					org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext
						org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext

이 중에 
GenericWebApplicationContext class 가 ConfigurableWebApplicationContext interface 를 implement 하고,
ConfigurableWebApplicationContext interface 가 WebApplicationContext interface 를 extends 한다.

docs.spring.io 에
> `DispatcherServlet` expects a `WebApplicationContext` (an extension of a plain `ApplicationContext`) for its own configuration.


- Spring 의 DispatcherServlet 안에는 2가지 타입의 WebApplicationContext 이 있다.

![[Screenshot 2025-10-29 at 12.38.27 PM.png|600]]


- jsp 는 jsp 페이지마다 서블릿을 생성하고, 이 서블릿은 singleton 으로 하나만 존재하며,
이 서블릿들은 상태가 없는한 할당되는 메모리 크기가 매우 작다.
그리고 요청이 올때마다 이를 재사용해서 비효율적이지 않다.
jsp 의 servlet 은 Heap 공간에 생성됨 (spring은 모름)


- spring 의 경우 servlet 을 가리키는 것은 DispatcherServlet 이며 이는 보통 하나이며, 
이 크기는 매우 큰데
DispatcherServlet 의 크기 자체는 별로 안크지만, WebApplicationContext 의 크기가 매우 크기 때문에
이를 포함하는 DispatcherServlet 자체도 자연스럽게 커지게 된다.

왜냐하면 WebApplicationContext 가 Bean 을 포함하기 때문
(WebApplicationContext 는 ApplicationContext 을 extends 한다. 즉 Bean 의 생명주기 관리에 참여할수도 있음(may))

이렇게 보면, spring 은 jsp 의 servlet 자체를 엄청나게 확장한 것으로 생각할 수 있다.

- spring 에는 여러개의 DispatcherServlet 이 존재할 수 있다 (jsp 처럼)
	여러 개의 DispatcherServlet이 필요한 경우는 매우 특수한 상황입니다:[](https://stackoverflow.com/questions/23049736/working-with-multiple-dispatcher-servlets-in-a-spring-application)​​
	- UI 요청과 RESTful API 요청을 완전히 분리해야 하는 경우
	- 완전히 다른 설정(view resolver, interceptor 등)이 필요한 경우
	- 레거시 시스템과의 통합 등
**요약**: 가능하긴 하지만, 실제로는 거의 모든 애플리케이션에서 하나의 DispatcherServlet만 사용합니다. 
이것이 Front Controller 패턴의 원칙에도 부합하고, Spring MVC의 표준 구성입니다.


자, 이 이해를 바탕으로...

### Filter ?

Filter 는 Servlet Container 레벨에서 동작하는 Java Class 이다.
Request, Response 가 서블릿(jsp 는 페이지마다, spring에는 보통 하나만 존재하는) 에 도착하기 전 후로 전처리와 후처리를 수행한다.

그러니까 Spring 으로 치면 Request 가 DispatcherServlet 에 닿기 전에 pre-Processing 하고,
Response 가 DispatchServlet 으로부터 나와 client 에 닿기 전에 post-processing 하는 클래스를 말함.

(Spring MVC 에서의 실행 흐름)
```java
Client Request
    ↓
Filter Chain
    ↓
['보통 하나'의 DispatcherServlet] 
    ↓
ApplicationContext
    ↓
Handler Mapping (어떤 Controller로 보낼지 결정) -> 얘도 Bean 이다.
    ↓
Controller (예: @GetMapping("/user"))
    ↓
Service/Repository
    ↓
Controller가 Model과 View 이름을 리턴
    ↓
ViewResolver (View 이름 → 실제 JSP 파일 경로 매핑)
    ↓
[해당 JSP의 서블릿] ← 여기서 JSP 서블릿이 실행됨
    ↓
렌더링된 HTML이 클라이언트에게 리턴
```

어쨌든 Servlet Container 에서 관리되므로 전통적인 Filter 에서는 Spring 의 컨텍스트와 상관없이 동작한다. 

- 전통적 FIlter 구현 (web.xml)
```xml
<filter>
    <filter-name>LogFilter</filter-name>
    <filter-class>com.example.LogFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>LogFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

SpringBoot 은 Bean 을 사용해서 Filter 를 설정할 수 있다.

---- 
(이 부분은 다시 다듬기 필요)
**전통적인 Java 웹 애플리케이션 (WAR 배포)**

- 외부 Servlet Container (Tomcat, Jetty 등)에 WAR 파일을 배포.
- `web.xml`에 Filter와 DispatcherServlet을 등록.
- 이 경우, Servlet Container가 주도권을 가지고 있다.​

**Spring Boot (Embedded Container)**

- Spring Boot는 **Embedded Servlet Container**를 사용해. 즉, Tomcat이 애플리케이션 안에 포함되어 있음.[](https://docs.spring.io/spring-boot/reference/web/servlet.html)​
- Spring Boot가 애플리케이션을 시작할 때, **Spring Boot가 Servlet Container를 생성하고 설정**함. 그래서 주도권이 역전됨.[](https://mosy.tech/blog/spring-boot-autoconfiguration/)​
- 이 과정에서 Spring Boot는 `ServletWebServerFactory`를 통해 Servlet Container를 초기화하고, Filter와 Servlet을 프로그래밍 방식으로 (xml 이 아니라) 등록할 수 있음.

Spring만 사용하면,
Spring MVC (Spring Boot 아님)에서는 `DelegatingFilterProxy`라는 특수한 Filter를 `web.xml`에 등록. 
이 녀석이 Servlet Container와 Spring ApplicationContext를 연결해주는 다리 역할을 한다.[](https://stackoverflow.com/questions/6725234/whats-the-point-of-spring-mvcs-delegatingfilterproxy)​

-  동작 방식
1. `web.xml`에 `DelegatingFilterProxy`를 등록.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html)​
2. Spring Context에 실제 Filter를 Bean으로 등록.[](https://stackoverflow.com/questions/6725234/whats-the-point-of-spring-mvcs-delegatingfilterproxy)​
3. `DelegatingFilterProxy`가 요청을 받으면, Spring Context에서 해당 Bean을 찾아서 위임(delegate).[](https://docs.spring.io/spring-security/reference/servlet/architecture.html)​

---

### Interceptor ?

jsp 에는 없는 개념이다.

Spring 에는 두 가지 인터셉터 종류가 있다.

하나는 Spring MVC 에서 DispatcherServlet 에서 Handler 로 갈때 요청을 가로채는 interceptor 와
AOP interceptor 가 있다.

먼저 Spring 이 Bean을 생성할때, 해당 Bean 에 AOP 가 적용되는 지 확인.
적용대상이면, Bean 을 Proxy 로 감싸서 ApplicationContext 에 등록. (이 작업은 이제 Runtime 에 일어난다)
이렇게 등록되고 나면, 해당 Bean 에 대해서 `getBean()` 으로 꺼내온 빈은 사실 Proxy 객체이다.

그래서 proxy 로 감싸진 빈의 메서드가 호출되면 (물론 메서드마다 프록시 호출여부를 설정할 수 있다), 
Proxy 클래스가 먼저 실행된다.
이때 Proxy class 는 해당 메서드의 실행전, 후로 동작을 수행할 수 있다.
(Before, Around, After 등의 advice 가 그 것)

**두 가지 Proxy 방식**
- **JDK Dynamic Proxy**: 인터페이스 기반. 인터페이스를 구현한 Proxy 클래스를 런타임에 생성.​
- **CGLIB Proxy**: 클래스 기반. 원본 클래스를 상속받은 Subclass를 런타임에 생성.​


### Filter vs Interceptor

먼저 3가지 요소를 비교해야 한다고 생각한다.
Filter , HanlderInterceptor (Spring MVC의), AOP Interceptor

Filter 와 Handler interceptor 는 HTTP 요청 레벨에서 동작한다.
Filter는 Servlet Container ,  Handler interceptor 는 DispatcherServlet 레벨에서 가로챌뿐
요청/응답을 가로채는것은 동일함.

Handler Interceptor 는 DispatcherServlet 이 직접 Interceptor chain 을 실행함

```java
1. mappedHandler.applyPreHandle() → 모든 Interceptor의 preHandle() 실행
2. HandlerAdapter.handle() → Controller 실행
3. mappedHandler.applyPostHandle() → 모든 Interceptor의 postHandle() 실행 (역순)
4. View 렌더링
5. mappedHandler.triggerAfterCompletion() → 모든 Interceptor의 afterCompletion() 실행 (역순)
```

그러나 이 둘과 확연하게 AOP Interceptor 는 구분되는 것이
AOP Interceptor 는 method 레벨에서 동작한다.
HTTP 와 무관하고,
모든 SpringBean 에 대해서 메서드를 가로챌 수 있다.
Proxy 기반으로 동작한다.

여기서 Proxy 란 
Proxy는 **원본 Bean(Target Object)을 감싸서**, 원본 Bean 호출시 
원본 메서드 호출을 가로채고 추가 로직(Advice)을 실행한 뒤, 원본 메서드를 호출하는 객체.



## JRE, JDK, JVM


어셈블리 시절 -> 소스코드를 여러개
C 언어 -> 하나의 소스코드, 여러개의 컴파일러 (OS 별 컴파일러)
Java -> 하나의 소스코드 ,하나의 컴파일러 , 여러개의 운영환경

이 운영환경이 JRE. 

각 OS 에 맞는 JRE (Java Runtime Environment) 를 설치해야
JRE 가 JVM 을 실행시키고
하나의 소스코드로 어떤 환경에서든 JRE 만 있으면 JVM 으로 실행시킬 수 있고

이 Java Application 을 만들기 위해서 JDK 가 필요한 것.

JRE 를 JVM 을 포함하고 JDK 가 JRE 를 포함하는 형태로 배포됨 (편의를 위해서)

JDK 는 자바 소스 컴파일러 javac.exe 를 포함하고 있음
JRE 는 자바 프로그램 실행기인 java.exe 를 포함하고 있음.

JDK 로 개발 & 컴파일 -> 자바 Object file (.class)

OS 별 JRE 가 JVM 을 실행시켜 위에 컴파일된 자바 Object file을 실행

## 객체 지향 특성 4가지

### 객체란, Application Boundary

우리가 어떤 것을 만들 어야 할 것인가에 대한 범위가 Application Boundary
(내가 창조하려는 세계는 어떤 세계인가?)

인간을 예로 들면, 먹다 자다 숨쉬다 등의 수많가지 특성과 행동이 있지만 

어떠한 어플리케이션을 만드는데 있어서 인간의 모든 속성이 필요한 것은 아니다.

즉 객체란 Application Boundary 에 따라 대상들의 공통된 속성, 행동들을 추출하여 모델링하여 나온 분류에 속하는 유일무이한 대상이다.

추상화 : 구체적인 것을 분해해서 관심영역에 대한 특성만을 가지고 재조합하는것
-> 객체 지향의 추상화는 곧 모델링이다.

클래스는 분류이며, 클래스를 설계하기 위해서는 추상화가 필요하고, 추상화를 위해서는 관심영역을 설정해야 한다 (Application Boundary)




### 객체와 클래스에 대한 오해


객체와 클래스는 붕어빵과 붕어빵틀의 관계가 아니다

그리고 부모 자식 클래스는 잘못된 말이다

클래스는 '분류' 라고 생각해야 한다.


클래스는 개념, 객체는 실체이다.

클래스와 개념을 구분하는 방법은 ~은 몇살인가 등의 구체적인 질문이 있다.

사람의 나이는 몇살인가 ?  -> 대답 불가능
홍길동의 나이는 몇살인가 ? -> 대답 가능



### 추상화 : 모델링, 추상화와 T memory

T memory -> Static, Stack, Heap

클래스의 메서드는 Heap 에 저장되지 않고
static 공간에 저장된다.

인스턴스가 생성되면 Heap 에 저장된다.
Stack 은 메소드가 실행될때 ({ 블록이 실행될때) 메소드가 실행된다.

클래스 A 를 상속받은 클래스 B 가 있다고 했을때,

```java
ClassB objB = new ClassB();
ClassA objA = new ClassB();
```

이렇게 하면 objB 는 가장 하위 서브 클래스 인스턴스 (Heap에 있는) 를 가리키나
objA 는 ClassA 인스턴스를 가리킨다 (대신에 ClassB 까지 인스턴스가 생성되어 있다.)

### 상속 - Inheritence 보다는, 재사용 + 확장

상속에 대해서 올바른 개념도는 분류도이지, 계층도/ 조직도가 아니다.

계층적 구조면 상위 클래스가 아버지, 하위 클래스가 딸이어야 하는데

```java
아버지 person = new 딸();
```

앞뒤가 안맞는다.


분류도라고 하면 고래, 박쥐는 포유류에 속하는데

```java
포유류 obj = new 고래();
```

논리적으로 맞는 말이 된다.


하위 클래스는 상위 클래스이다 -> LSP 

하위클래스 is a 상위 클래스 -> X
-> 고래 is a 포유류 ?
-> 앞뒤가 안맞는다

하위 클래스 is a kind of 상위 클래스
-> 고래는 포유류의 한 종류이다.
-> 자연스러움

> The derived class is clearly a kind of the base class.

즉 객체지향의 상속은 상위 클래스의 특성을 재사용하고, 확장하는 것이며
is a kind of 관계를 만족해야 한다.

```java
포유류[] 동물들 = new 포유류[n];
동물들[0] = new 고래();
동물들[1] = new 박쥐();

for (int i=0; i<n; i++) {
	동물들[i].소리내다();
}
```

위 상황에서 동물들\[0] 은 Heap 에 포유류 인스턴스를 가리키나, 실제로 고래에 해당하는 인스턴스까지 메모리를 할당받고 바로 옆에 붙어있다.
그래서 동물들\[0] 은 포유류에는 없고 고래에만 구현된 메서드는 사용 불가 (어쨌든 참조가 포유류 타입이기 때문에)

이때 주의해야할 점 : 하위 클래스의 인스턴스로 생성되고 그 인스턴스를 가리키는 것이 상위클래스의 참조일때,
만약 상위 클래스의 어떤 메서드가 하위클래스에서 오버라이딩 됬을 경우,
상위 클래스에서 호출한 해당 메서드는
상위 클래스에서 정의한 내용이 아니라 하위 클래스에서 정의한 내용이 실행된다.

#### 다중 상속과 자바

만약 인어가 사람과 물고기를 모두 상속받는다고 했을때,
사람과 물고기 모두 헤엄치다 라는 행동이 있을 수 있다.
인어는 사람처럼 두 팔로 헤엄쳐야 할까 아니면 물고기처럼 헤엄쳐야 할까?

-> 자바는 이러한 애매모호함을 없애기로 했음

#### 상속과 인터페이스

인터페이스는 행동.

'implemented class' is able to 'interface'

상위클래스가 하위 클래스에게 물려줄 속성이 많을 수록 좋다 -> LSP
인터페이스는 구현을 강제할 메서드가 적을 수록 좋다 -> ISP (Interface segregation)

### 다형성 : 사용 편의성

오버로딩, 오버라이딩

오버로딩 - 함수명 하나 가지고 인자타입만 바꾸어서 사용이 가능하다

```java

class Animal {
	public void speak() {
		System.out.println("I'm an animal");
	}
}

class rat extends Animal {
	public void speak() {
		System.out.println("I'm a ratl");
	}
}


class cat extends Animal {
	public void speak() {
		System.out.println("I'm a cat");
	}
}



...
public void animalSounds() {

	Animal[] animals = new Animal[4];
	
	animals[0] = new rat();
	animals[1] = new cat();
	animals[2] = new dog();
	animals[3] = new goat();
	
	for (int i=0; i<animals.length; i++) {
		animals[i].speak();
	}
}
```

하위 클래스의 인스턴스로 생성되고 그 인스턴스를 가리키는 것이 상위클래스의 참조일때,
만약 상위 클래스의 어떤 메서드가 하위클래스에서 오버라이딩 됬을 경우,
상위 클래스에서 호출한 해당 메서드는
상위 클래스에서 정의한 내용이 아니라 하위 클래스에서 정의한 내용이 실행된다.


### 캡슐화 : 정보 은닉





## SOLID 원칙

하나의 리팩토링에 대해서 두가지 이상의 원칙이 적용됬다고 말할수도 있다.
관점에 차이에 따라 해석이 달리 된다.


### SRP - Single Responsibility 단일 책임

-> 어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.

한 남자가 있다.
한 남자에게는 여자친구도, 어머니도, 직장상사도, 소대장도 있다.
각각 남자친구, 아들, 사원, 소대원 역할이다.

이때 남자 하나의 클래스만 구현했다고 생각해보자.

이때 남자가 여자친구와 헤어졌으면 여자친구와 할 키스하기, 기념일 챙기기 등은 무쓸모하게 된다.

이런 낭비 문제가 생김에 따라

각 역할마다 클래스를 나누어 남자라는 클래스를 쪼갤 수 있다.

하나의 클래스는 다수의 역할과 책임을 맡게하지 말아야 한다.

하나의 클래스에는 하나의 역할만. 하나의 속성에는 하나의 의미만.

사람 - 남자, 여자 - 군번



하나의 속성이 여러 의미를 갖는 경우도 단일 책임 원칙을 지키지 못하는 것.

DB - 하나의 필드가 토지인 경우 면적, 건물인 경우 층수

if 문

### OCP - Open Closed Principle 개방 폐쇄

자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀있어야 한다.

운전자 -> 마티즈
운전자 -> 쏘나타

운전자 -> 자동차 -> 마티즈
			->  쏘나타

자동차 : 창문개방, 기어조작
마티즈 : 창문개방, 기어조작
쏘나타 : 창문개방, 기어조작

상위 클래스 또는 인터페이스를 중간에 둠으로써
다양한 자동차가 생긴다고 해도 운전자는 운전습관에 영향을 받지 않게 됨.

즉 운전자라는 클래스가 자동차에 대한 변화에 대해 영향받지 않게 됨.

자동차 라는 클래스 또는 인터페이스에 대해서는 확장에 개방되어 있는 것이고,
운전자 입장에서는 주변의 변화에 폐쇄되어 있는 것.


그리고 위 예시는 DIP 이기도 함 (의존성 역전 원칙)



JDBC
-> 자바 어플리케이션
JDBC interface
JDBC driver for oracle / JDBC driver for MySQL / JDBC driver for PostgreSQL


자바 자체도 소스코드가 어떤 환경에서 실행될지 걱정하지 않음

편의점 - 직원 삼교대 - 구매한다 - 손님
직원이 바뀌어도 손님이 구매한다는 행동에는 변함이 없음

### LSP - Liskov Substitution 리스코프 치환

Sub type 은 언제나 자신의 base type 으로 교체할 수 있어야 함.

객체 지향의 상속은 
sub class is a kind of super class
implemented class is able to interface
이 두 조건을 만족해야 한다.

위 문장대로 구현되지 않는 코드는 상속이 조직도나 계층도 형태로 구축된 경우.
-> 리스코프 치환 법칙 위배

이게 위배되면 논리적으로 앞뒤가 맞지 않는 일이 생긴다 
-> 춘향이가 아버지의 역할을 대신할 수 있는가 ?


### ISP - Interface Segregation 인터페이스 분리

-> 클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다

위 SRP 의 예시 - 남자 - 남자친구, 아들, 사원, 소대원 클래스로 나눈 방법 외에 다른 방법?

남자친구, 아들, 사원, 소대원 등을 다 interface 로 만들어서 남자가 그 들을 implement 하게 하면 됨.

남자가 어머니와 있을때는 아들로, 소대장 앞에서는 소대원 행동을 하게끔 하는 것.

같은 문제에 대해서 SRP 와 ISP 는 서로 다른 해결책.


ISP 에서는 인터페이스 최소주의 원칙이 있음.
인터페이스를 통해 메서드를 외부에 제공할때는 최소한의메서드만 제공하라는 것.

-> 위 예시에서 남자친구라는 인터페이스에 소대원 인터페이스에 들어갈만한 '사격하기' 라는 메서드가 들어가서는 안될 것.

인터페이스 최소주의 원칙 -> 소대원 , 남자친구 따로따로 인터페이스는 오케이
소대원 + 남자친구라는 인터페이스는 앞뒤가 안맞음
(소대장한테 기념일챙기기 ?)


위에 얘기했던 상위클래스가 풍성할수록 좋은 이유는
재사용성이 늘어나기 때문이다 
(하위 클래스에서 불필요하게 중복 선언하지 않아도 됨)


### DIP - Dependency Inversion 의존 역전

자동차 -> 스노우 타이어

자동차라는 클래스는 스노우 타이어라는 클래스에 의존함.


```
자동차 -> <interface> 타이어

타이어 -> 스노우 타이어
	-> 일반 타이어
	-> 광폭 타이어

```

자동차는 타이어가 스노우이든 일반이든 광폭이든간에 의존하지 않아도 됨.
그리고 스노우타이어가 그 무엇에도 의존하지 않는 클래스였는데
추상적인 것 - 타이어에 의존하게 됨.
-> 의존 관계 역전.

OCP 와 똑같음. 관점만 다름.

자신보다 변하기 쉬운 것에 의존하지 말 것.

고차원 모듈은 저차원 모듈에 의존하면 안된다.
이 두 모듈 모두 다른 추상화된 것에 대해 의존해야 한다.

추상화된 것은 구체적인 것에 의존하면 안된다. (구체적인 것 -> 하위 클래스)
구체적인 것이 추상화된 것에 의존해야 한다.

자주 변경되는 구체 (Concrete) 클래스에 의존하지 말 것.

