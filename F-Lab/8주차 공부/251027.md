
## HashSet, LinkedHashSet, TreeSet


모두 Set 인터페이스의 구현체이다.

### HashSet

HashMap 으로 부터 구현되며,
HashSet 이 값을 add 할때 HashMap 은 그 값을 엔트리의 키로, 엔트리의 값은 Present Object로써
Table에 저장한다.

Table 의 타입은 Node\<K, V>의 배열 이며, Node 는 Map Interface 의 내부 interface 인 Entry\<K, V> 를 implement 한 것이고,
이 Entry 는 단순한 kay-value pair 이다.

그러니까 HashMap 에 어떤 값이 저장될때 이 Node\<K, V> 배열(Hash Table)에 저장되며 이게 버킷 리스트가 된다.
그래서 HashMap 에 키-값 을 저장할때, key에 따라 해쉬값을 정하고
그 정한 해쉬값으로 인덱스를 정해서 Hash Table 에 저장되는 것.

#### HashMap 에서의 충돌

##### 시나리오 1: 같은 Key로 put (이건 collision이 아님)

```java
HashMap<String, Integer> map = new HashMap<>();
map.put("key1", 100);
map.put("key1", 200);  // "key1"의 값이 100 → 200으로 교체됨
```

- 이건 collision이 **아닙니다**
- 단순히 같은 key의 value를 업데이트하는 것
- 기존 값은 사라지고 새 값만 남음​
    
##### 시나리오 2: 다른 Key인데 같은 Hash Code (진짜 collision)

```java
// 서로 다른 key인데 hash code가 같은 경우
String key1 = "Aa";
String key2 = "BB";
// key1.hashCode() == key2.hashCode() 인 경우 (실제로 이렇습니다)

HashMap<String, Integer> map = new HashMap<>();
map.put("Aa", 100);
map.put("BB", 200);
```

이 경우 같은 bucket에 두 entry가 **모두 저장**됩니다 (linked list로 chaining)
​​
```
`Bucket 4:   Entry("Aa", 100) → Entry("BB", 200) → null`
```

그래서 HashSet 에 대해서 

- 순서: No ordering guarantee
- 삽입: Average O(1), Worst O(n) or O(log n) (Java 8+)
- 조회: Average O(1), Worst O(n) or O(log n) (Java 8+)

Java8 이전에는 LinkedList 로 충돌을 관리했기 때문에 O(n) 이었지만,
이제는 특정 버킷의 수가 8개 (TREEIFY_THRESHOLD) 가 넘어가면 해당 버킷만  red-black tree (TreeNode) 가 된다. (treeify)

HashMap 의 hash table 의 타입은 Node\<K,V> 인데, 
특정 버킷이 tree 가 되면 TreeNode 타입이 되는데,
이 TreeNode 타입은 `LinkedHashMap.Entry<K,V>` 를 extends 한 것이며,
다시 `LinkedHashMap.Entry<K,V>` 는 `HashMap.Node<K,V>` 를 extends 한다.

쨌건 O(logn)이 되는 이유는 이 red-black tree 덕분.

Red-black Tree : 높이가 log n 이하로 자동 유지되는 self-balancing 이진트리

### Load Factor

LoadFactor 는 HashTable 이 resize 되기 위한 조건을 설정하는 값이다.

**load factor = (저장된 요소 수) ÷ (테이블의 전체 버킷 수)**.

HashSet 의 경우 HashMap 기반 구조를 사용하기 때문에 LoadFactor 가 존재함.
LinkedhashSet 의 경우 HashSet 을 extends 하므로 마찬가지로 LoadFactor 가 존재하나
TreeSet은 Red-Black Tree 기반으로 Load Factor 가 없음

일단 0.75값으로 설정되어 있다.


### LinkedHashSet

HashSet의 sub class.
따라서 HashTable 을 사용.
LinkedhashMap 을 통해서 구현.

삽입 순서 보장.
iteration 의 시간복잡도는 O(1) 로 되려 hashSet 보다 유리하다.
단 linkedList 를 유지하기 위한 메모리 오버헤드가 생김.

HashSet 과 동일하게 ThreadSafe 하지 않음.
여러 스레드 접근시 `Collections.synchronizedSet()`을 사용하는 것이 권장됨.


### TreeSet

Red-Black Tree 를 이용한 Set 구현체. 위와 달리 Map 을 이용해 구현되지 않음.

```java
public class TreeSet<E> extends AbstractSet<E>  
    implements NavigableSet<E>, Cloneable, java.io.Serializable
```

_SortedSet_ 과 _NavigableSet_ 인터페이스를 구현하여 원소를 **정렬된 순서로 저장하고 탐색**할 수 있음.

균형을 유지하 삽입, 검색, 삭제의 시간복잡도를 O(logN)으로 보장.

- **정렬 방식 (Ordering)**

	- 기본적으로 **요소의 자연 순서(natural ordering)** 를 따릅니다.
	- 또는 생성자에서 **Comparator**를 전달해 맞춤 정렬도 가능

- **특징**

	- **중복 불허:** 같은 값을 추가하려 하면 무시됩니다.
	- **정렬 보장:** 원소들이 항상 정렬 상태로 유지됩니다.
	- **null 금지:** null 요소는 허용하지 않습니다.  
	    이는 비교 시 `NullPointerException`을 유발하기 때문입니다.​
	- **unsynchronized:** 스레드 안전하지 않으며, 필요 시 `Collections.synchronizedSet()`으로 감싸야 합니다

- **성능 특성**
    - `add`, `remove`, `contains` → O(log n)        
    - `iteration` → O(n)
    - 즉, HashSet처럼 O(1)은 아니지만, **정렬된 순서를 유지하는 대가로 약간의 성능 비용이 추가**됩니다.

### 셋 비교

| Set 종류        | add      | contains | remove   | iteration (순회)         |
| ------------- | -------- | -------- | -------- | ---------------------- |
| HashSet       | O(1)     | O(1)     | O(1)     | O(h+n) (h: table 크기) ​ |
| LinkedHashSet | O(1)     | O(1)     | O(1)     | O(1) ​                 |
| TreeSet       | O(log n) | O(log n) | O(log n) | O(log n)​              |
|               |          |          |          |                        |

|클래스|내부 구조|순서 보장|시간 복잡도(add/contains)|비고|
|---|---|---|---|---|
|HashSet|해시 테이블 (HashMap)|없음|O(1)|가장 빠르지만 순서 무의미 ​|
|LinkedHashSet|해시 + 링크드 리스트|삽입 순서|O(1)|순서 유지 ​|
|TreeSet|Red-Black 트리|정렬 순서|O(log n)|자동 정렬 지원 ​|


- HashSet과 LinkedHashSet은 대부분 연산이 평균적으로 상수 시간(O(1)), 단 테이블이 꽉 차거나 해시가 불균형할 때 linked list traversal 때문에 성능 하락이 있습니다. HashSet의 iteration은 버킷 전체를 검사하는 구조라서 전체 bucket size만큼 시간이 듭니다.
    
- TreeSet은 항상 정렬된 데이터를 이진 트리로 관리하므로 검색, 삽입, 삭제가 O(log n)입니다. iteration도 연속적으로 log n 수준의 traversal이 필요합니다.
    
- LinkedHashSet은 순회(iteration)는 O(1)로 상당히 효율적입니다. 이는 이중 연결 리스트로 이어지기 때문입니다.




## TCP vs UDP

TCP vs UDP 에 대해서 나의 답변은  
TCP 는 3way handshake 을 통한 소켓간 연결로 데이터의 순서, 그리고 데이터 신뢰성(데이터가 손실없이 전송되는지) 를 보장하고, 
4way handshake 로 연결을 종료함에 따라 오버헤드가 있고,  
  
UDP 는 TCP 와 같은 연결 및 연결 해제 과정 없이 데이터를 전송하며, 네트워크 중간 라우터의 알고리즘 및 네트워크 상황에 따라 어떤 데이터가 먼저 도착할지 모르기 때문에 데이터 전송 완료 순서를 보장하지 않고, 데이터 신뢰성도 보장하지 않아. 만약 하려면 상위계층해서 해야해.  
대신 연결에 대한 자원이 들지 않기 때문에 상대적으로 데이터 전송속도가 빠르다.  
  
상기 특징때문에 TCP 는 데이터 손실이 반드시 없어야 하는 예를들면 계좌이체 같은 동작시에 필요하고  
UDP 는 데이터 손실율을 어느정도 감수할 수 있는 동영상 스트리밍등에 쓰인다.


|특징|TCP (Transmission Control Protocol)|UDP (User Datagram Protocol)|
|---|---|---|
|연결 방식|Connection-oriented (3-way handshake) [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|Connectionless (no handshake) [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|
|데이터 신뢰성|Reliable, ordered delivery (retransmission, ack) [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|Unreliable, unordered, best-effort only [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|
|속도/오버헤드|느림 (많은 오버헤드, 헤더 20~60 bytes) [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|빠름, 최소 오버헤드, 헤더 8 bytes [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|
|순서 보장|Yes, sequencing [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|No, 순서 보장 없음 (상위 계층에서 필요시 구현) [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|
|용도 예시|데이터베이스, 계좌 이체, 웹서핑, 이메일 [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|음성/영상 스트리밍, 게임, IoT [](https://www.geeksforgeeks.org/computer-networks/differences-between-tcp-and-udp/)​|


