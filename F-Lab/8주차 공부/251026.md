## Web 이란 무엇인가 ?

인터넷 위에서 하이퍼 링크를 포함하는 하이퍼 텍스트를 통해 여러 문서와 리소스들을 서로 연결하고 
정보를 공유하는 정보 시스템으로써, HTTP 프로토콜을 기반으로 동작하며, 각 리소스들은 URL 로 특정된다.

### 정보 시스템이란 ?
Information System

정보를 모으고, 가공하고, 저장하고, 필요한 사람에게 전달하는 구성요소들의 집합.

Task, People, Structure, Technology


## Set 은 Map으로 구현된다

-> HashSet은 HashMap 으로, LinkedHashSet 은 LinkedHashMap 으로, TreeSet은 TreeMap 으로 구현된다.

### Set 과 Map 의 차이점?

Set 은 '값' 만을, Map 은 '키-값' 을 저장한다.


## HashSet, LinkedHashSet, TreeSet

### HashSet

Set 의 구현체. HashMap 기반.

Set 이므로 중복을 허용하지 않음, Hash Table 을 통해 요소를 저장함.
hashCode 값을 기반으로 bucket array 내 위치를 계산하여 데이터를 관리.

(HashSet)
```java
// Dummy value to associate with an Object in the backing Map  
private static final Object PRESENT = new Object();

public boolean add(E e) {  
    return map.put(e, PRESENT)==null;  
}

map.put 
-> (HashMap)
```

(HashMap)
```java
public V put(K key, V value) {  
    return putVal(hash(key), key, value, false, true);  
}

static final int hash(Object key) {  
    int h;  
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);  
}
```
기본 Object class 의 hashCode 값을 사용
해쉬코드와 그 해쉬코드를 16비트 오른쪽으로 쉬프트 연산 (왼쪽 비트는 0으로 채움) 한 값을
XOR 하여 해시 분포를 균등하게 함.

- >> vs >>>
```java
int x = -8;   // 11111111 11111111 11111111 11111000 (2의 보수 표현)
System.out.println(x >> 2);   // 11111111 11111111 11111111 11111110 → -2
System.out.println(x >>> 2);  // 00111111 11111111 11111111 11111110 → 1073741822
```
	- `   >>`는 **부호 유지(signed shift)**.  
	    즉, 오른쪽으로 밀어도 맨 왼쪽 비트(부호 비트)를 그대로 유지합니다. 그래서 음수는 여전히 음수입니다.
	    
	- `>>>`는 **zero-fill shift (unsigned shift)**.  
	    왼쪽 빈자리에 **항상 0을 채워서**, 음수도 양수처럼 보이는 큰 값으로 바뀝니다.


어쨌든 hashSet에 넣으려는 값 자체를 HashMap 의 key 로 두고 value 는 HashSet 의 동일한 static final 객체로 넣음

(HashMap) 
```java

/** 
Implements Map.put and related methods.
Params:
hash – hash for key
key – the key
value – the value to put
onlyIfAbsent – if true, don't change existing value
evict – if false, the table is in creation mode.
Returns:
previous value, or null if non
*/
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,  
    ...
}
```


```java
/**
Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.
Returns:
the table
*/
final Node<K,V>[] resize() {  
    ... 
}```

구한 hashCode, key, value, false, true 로 putVal.



```java
/**  
 * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. 
*/
   final void treeifyBin(Node<K,V>[] tab, int hash) {  
    ...
}
```

-> 나중에 여유되면 intelliJ 에서 putVal, resize, treeifyBin 을 읽어보자.


#### HashTable 이 사용되는 메커니즘

```java
class HashMap<K, V> {
    static class Node<K, V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
    }

    Node<K,V>[] table;  // hash table
}
```

  
충돌(collision)이 발생하면 같은 인덱스의 bucket에 연결 리스트로 저장되고,  
Java 8 이후에는 일정 임계치(기본 8) 이상이면 **Red-Black Tree**로 변환한다.


#### load factor

-> 테이블이 얼마나 차면 해싱을 다시 하는지 결정하는 값.
**load factor = (저장된 요소 수) ÷ (테이블의 전체 버킷 수)** 입니다.
예를 들어 HashSet의 기본 load factor는 **0.75** (즉 75%)입니다.  
이 말은 테이블의 **75% 버킷이 사용**되면 자동으로 **rehash**(더 큰 배열로 복사 및 재배치)가 발생한다는 뜻입니다.

