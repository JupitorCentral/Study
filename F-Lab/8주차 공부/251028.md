
## TCP 는 어떻게 신뢰성을 보장하는가 ?


### TCP 전송의 흐름

맨처음 : 클라이언트가 서버한테 Syn flag : 1 인 TCP header 를 날린다


###  Error Detection - checksum

데이터가 전송될때 0, 1이 간섭이나 노이즈 때문에 바뀔 수 있다 -> 이를 감지하는 것.

TCP 의 최대 크기 : 1460 bytes + 20 bytes (TCP header) -> 헤더는 그대로고 데이터 부분이 가변.

예를들어 데이터 크기가 680바이트면
TCP 세그먼트 전체를 2바이트로 나눔 -> 680 + 20 bytes -> 700 bytes 를 2바이트로 나눔 -> 350개.

이 나눠진 2바이트 워드들을 계속 더하는데, 이때 2워드 크기가 넘어가면 이 넘어간 비트를 하위비트로 더한다.
이 짓을 모든 데이터 워드들에 대해서 다 더하고
이를 반전시킨게 error checksum 이며, TCP receiver 가 이를 받아서 데이터 오류 검출을 한다.

receiver 가 데이터를 받으면 마찬가지로 2바이트 워드들로 다 쪼개서 더한다음
checksum 을 다 더했을때 모두 1 이면 (0xFFFF) 오류없음으로 간주.

###  Sequence Number

현재 segment 의 첫번째 byte 가 몇번째 byte 인지 알려줌

1. 중복 패킷 감지 (duplicate detection)
2. 순서대로 재조립 (ordering)

#### Sequence Number의 두 가지 역할

##### 1. 중복 패킷 감지 (Duplicate Detection)

Sender가 segment 1을 보냈는데 ACK가 안 와서 다시 segment 1을 보낸다고 가정해봅시다.

- Segment 1의 sequence number는 100입니다
    
- Receiver는 segment 1 (seq 100)을 받고 ACK를 보냅니다
    
- ACK가 손실됩니다
    
- Sender는 timeout으로 segment 1 (seq 100)을 다시 보냅니다
    
- Receiver는 sequence number 100을 보고 "이거 이미 받았네"라고 판단합니다

Sequence number가 같으면 중복 패킷입니다. Receiver는 이를 버립니다.


##### 2. 순서 보장 (Ordering)

Sender가 segment 1, 2, 3을 보내는데 네트워크에서 순서가 바뀌어 2, 3, 1 순서로 도착한다고 가정해봅시다.

- Segment 1: sequence number 100 (10 bytes)
    
- Segment 2: sequence number 110 (10 bytes)
    
- Segment 3: sequence number 120 (10 bytes)
    

##### 구체적 예시

10000 bytes 데이터를 1400 bytes segment로 쪼갠다면:

- 첫 번째 segment: sequence number 0 (0~1399 bytes 포함)
    
- 두 번째 segment: sequence number 1400 (1400~2799 bytes 포함)
    
- 세 번째 segment: sequence number 2800 (2800~4199 bytes 포함)
    
- ...


Receiver는 다음과 같이 동작합니다:

- Segment 2 (seq 110)을 받습니다 → 100을 기다리는데 110이 왔으니 버퍼에 저장합니다
    
- Segment 3 (seq 120)을 받습니다 → 100을 기다리는데 120이 왔으니 버퍼에 저장합니다
    
- Segment 1 (seq 100)을 받습니다 → 드디어 100이 왔습니다. 100, 110, 120 순서대로 application에 전달합니다8th.pdf​
    

Sequence number를 보고 정렬해서 올바른 순서로 데이터를 전달합니다.

#### Sequence Number는 Byte 단위

중요한 점은 TCP의 sequence number는 segment 번호가 아니라 byte 번호입니다.Computer-Networking_-A-Top-Down-Approach-8th.pdf​

책에서:

> "TCP views data as an unstructured, but ordered, stream of bytes. The sequence number for a segment is therefore the byte-stream number of the first byte in the segment."Computer-Networking_-A-Top-Down-Approach-8th.pdf​

예시:

- 첫 번째 segment: seq 0 (0~999 bytes)
    
- 두 번째 segment: seq 1000 (1000~1999 bytes)
    
- 세 번째 segment: seq 2000 (2000~2999 bytes)
    

#### 정리

1. 중복 감지: 같은 sequence number를 가진 segment가 다시 오면 중복이라고 판단하고 버립니다​
    
2. 순서 보장: Sequence number를 보고 out-of-order segments를 버퍼에 저장했다가, 순서대로 재조립해서 application에 전달합니다
    

###  Timeout, Acknowledgement, Retransmission


3 개의 duplicate ACK (Acknowledgement) 를 받으면 timeout 을 기다리지 않고 즉시 재전송.

Timeout 이 발생하면 sender 는 segment를 다시 보냄

1. Sender가 segment를 보내고 timer를 시작합니다​
2. ACK를 받으면 timer를 멈춥니다​
3. Timeout이 발생하면 재전송합니다​

#### ACK + Timeout + Retransmission 동작 방식

##### 정상 동작

1. Sender가 segment 1을 보냅니다 (sequence number 100, 10 bytes)
    
2. Timer를 시작합니다
    
3. Receiver가 segment를 받고 ACK 110을 보냅니다 (110번부터 기다린다는 뜻)
   (이때 header 만 날아간다)
    
4. Sender가 ACK 110을 받고 timer를 멈춥니다
    

##### Segment가 손실된 경우

1. Sender가 segment 1을 보냅니다 (sequence number 100)
    
2. Timer를 시작합니다
    
3. Segment가 중간에 손실됩니다
    
4. Timeout이 발생합니다
    
5. Sender가 같은 segment를 다시 보냅니다 (재전송)
    
##### ACK가 손실된 경우

1. Sender가 segment 1을 보냅니다 (sequence number 100)
    
2. Receiver가 받고 ACK 110을 보냅니다
    
3. ACK가 중간에 손실됩니다
    
4. Sender에서 timeout이 발생합니다
    
5. Sender가 segment 1을 다시 보냅니다
    
6. Receiver는 sequence number를 보고 중복이라는 걸 알고 버립니다
    
##### 여러 개를 보낼 때 (Pipelining)

1. Sender가 segment 1, 2, 3을 연속으로 보냅니다
    
2. 각각 sequence number 100, 110, 120입니다
    
3. Segment 2가 손실되고, segment 1과 3은 도착합니다
    
4. Receiver는 ACK 110을 계속 보냅니다 (110번을 기다린다는 뜻)
    
5. Sender는 같은 ACK 110을 3번 받으면 segment 2를 재전송합니다
    

##### 핵심

1. Segment 보낼 때 timer 시작
    
2. ACK 받으면 timer 멈춤
    
3. Timeout 발생하면 재전송
    
4. Receiver는 sequence number로 중복 확인
    


### Bytes of Stream


TCP 는 참고로 연결을 하고 나서
여러개의 데이터들을 전송을 할텐데, 이때 데이터간 의 구분을 안한다

> TCP views data as an unstructured, but ordered, stream of bytes


#### TCP는 데이터를 구분하지 않음 (TCP does not preserve message boundaries)

TCP는 애플리케이션 계층의 서로 다른 데이터를 구분하지 않아. TCP 입장에서는 그냥 연속적인 byte stream일 뿐이야.​

책에서 명확하게 말하고 있어:

> "TCP views data as an unstructured, but ordered, stream of bytes."​

즉, TCP는 데이터를 "구조 없는(unstructured), 하지만 순서가 있는(ordered) byte stream"으로 본다는 거야.


네가 웹브라우저에서 같은 서버에 3개 파일을 요청했다고 해보자. 동일한 TCP connection 사용:

1. Request 1: "GET /file1.html" (100 bytes)
    
2. Request 2: "GET /file2.html" (100 bytes)
    
3. Request 3: "GET /file3.html" (100 bytes)
    

TCP 입장에서는:

- Sequence number 0~99: 첫 번째 데이터의 bytes
    
- Sequence number 100~199: 두 번째 데이터의 bytes
    
- Sequence number 200~299: 세 번째 데이터의 bytes
    

TCP는 이게 "파일 요청 3개"인지, "하나의 긴 메시지"인지 전혀 모르고 신경도 안 써. 그냥 0번부터 299번까지 byte를 순서대로 전달할 뿐이야.​

#### 그럼 누가 데이터를 구분하나?

바로 **애플리케이션 계층(Application layer)**이야.​

책에서 이렇게 설명해:

> "The client process passes a stream of data through the socket... Once the data passes through the door, the data is in the hands of TCP running in the client."​

즉:

1. Application이 데이터를 socket에 보냄
    
2. TCP는 그걸 send buffer에 저장
    
3. TCP는 적절한 시점에 segment로 나눠서 보냄
    
4. Receiver의 TCP는 받은 데이터를 receive buffer에 저장
    
5. Receiver의 application이 buffer에서 데이터를 읽음​
    

여기서 중요한 건, **TCP는 메시지 경계(message boundaries)를 보존하지 않는다**는 거야.

#### 메시지 경계를 보존하지 않는다는 게 뭐냐면

Sender가:

- Send 1: "Hello" (5 bytes)
    
- Send 2: "World" (5 bytes)
    

이렇게 두 번 나눠서 보냈어도, receiver는:

- Receive 1: "HelloWorld" (10 bytes 한 번에)
    

이렇게 받을 수도 있고, 또는:

- Receive 1: "Hel" (3 bytes)
    
- Receive 2: "loWor" (5 bytes)
    
- Receive 3: "ld" (2 bytes)
    

이렇게 완전히 다른 단위로 받을 수도 있어


#### 그럼 애플리케이션은 어떻게 구분하냐?

애플리케이션 계층 프로토콜이 자체적으로 구분자(delimiter)나 길이 정보(length)를 사용해.[](https://intronetworks.cs.luc.edu/current/uhtml/tcpA.html)​

예를 들어:

1. **HTTP:** `\r\n\r\n` (빈 줄)로 header와 body 구분
    
2. **Length-prefixed:** 데이터 앞에 "다음 100 bytes가 하나의 메시지"라고 길이 명시
    
3. **Fixed-length:** "항상 256 bytes씩이 하나의 메시지"라고 고정 크기 사용
    
4. **Special delimiter:** `\n`, `\0` 같은 특수 문자로 메시지 끝 표시
    
#### 정리하면

1. **TCP는 구분 안 함:** TCP는 모든 데이터를 하나의 연속된 byte stream으로 봄​
    
2. **Sequence number 역할:** 단지 "이 segment의 첫 번째 byte가 전체 stream에서 몇 번째냐"만 표시​
    
3. **메시지 경계 없음:** TCP는 message boundaries를 보존하지 않음[](https://intronetworks.cs.luc.edu/current/uhtml/tcpA.html)​
    
4. **Application이 구분:** 서로 다른 데이터의 구분은 application layer protocol의 책임




##  jsp 에서 Reqeust 는 어떤 것을 담당하는 변수인가?

request 기본 객체는 client 의 요청 정보를 제공한다.



이 객체의 역할은
- 클라이언트와 관련된 정보 읽기 기능

- 서버와 관련된 정보 읽기 기능

-> 웹 서버에 연결한 클라이언트의 ip 주소, 클라이언트가 요청한 요청정보 길이, 요청 프로토콜 등등

- 클라이언트가 전송한 요청 파라미터 읽기 기능

- 클라이언트가 전송한 요청 헤더 읽기 기능

- 클라이언트가 전송한 쿠키 읽기 기능

- 속성 처리 기능

![[Screenshot 2025-10-28 at 7.36.43 PM.png|600]]
![[Screenshot 2025-10-28 at 7.36.49 PM.png|600]]

post 방식으로 request 를 보내면 parameter 가 body 에 생김

-> `request.getParameter()` 메서드는 GET 방식(URL 파라미터)과 POST 방식(request body)의 데이터를 **동일하게** 처리합니다.
-> 왜 이게 가능한가?

`request.getParameter()` 메서드는 내부적으로 다음 두 곳에서 파라미터를 찾습니다.​
1. **Query String** (URL 파라미터) - GET 방식에서 사용 
2. **Request Body** (요청 본문) - POST 방식에서 사용
즉, 이 메서드는 HTTP 메서드와 상관없이 파라미터를 추출할 수 있도록 설계되어 있습니다.


### Parameter Encoding

브라우저는 파라미터를 웹서버에 전송할때 알맞은 캐릭터셋에 따라 파라미터를 인코딩함.
웹서버는 그에 해당하는 알맞는 캐릭터셋에 따라 파라미터를 디코딩해야 파라미터값을 활용할 수 있음.

어떤 캐릭터셋을 사용할지는 GET 이나 POST 냐에 따라 달라짐.
POST 방식은 입력폼을 보여주는 응답화면이 사용하는 캐릭터셋을 사용함

```jsp
<%@ page contentType = "text/html; charset=utf-8" %>
...

```
-> UTF-8

GET 방식의 경우 파라미터를 보내는 방법이
a 태그에 쿼리 문자열을 추가하거나, HTTP Form 의 method 를 get 으로 설정해서 보내거나, 
웹 브라우저 주소에 직접 쿼리 문자열을 포함하는 URL 을 입력하는 방식이 있는데,

앞에 2가지 방식은 웹 페이지 인코딩을 사용하고
3번째 방식은 웹 브라우저마다 다르다.