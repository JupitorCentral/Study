## JPA 엔티티에 꼭 참조하는 테이블의 엔티티가 들어가야 하는가 ?

반드시 들어갈 필요는 없다. 



##  App 레벨에서 ACID 중 C 를 보장하는 방법

```java
@Query("""
	select s from Seat s
	join fetch s.event e
	where s.id = :seatId
	  and e.id = :eventId
	""")
Optional<Seat> findValidSeat(Long seatId, Long eventId);
```

JPA 에서 값을 가져올때 조인해서 가져온다. 

존재하지 않으면 Valid 한 Seat 이 아닌 것.




## Docker 정리


### Docker ?
-> VM : 하드웨어 + OS 까지 별도
-> Dokcer : OS 커널은 공유, 그 위에 격리된 프로세스 집합

리눅스 커널을 같이 쓰는 프로세스 격리 환경

그래서 컨테이너 안에서 보면 /가 자기 루트처럼 보이고
파일 시스템, 네트워크, 프로세스목록도 자기 것만 보이지만
실제로는 전부 호스트 OS 위에 얹힌 것


docer-compose.yml 작성 (포트를 환경변수로 설정할 수 있고,  어떤 파일의 환경변수를 쓸지는 env_file 로 설정이 가능하다.)


### Docker 명령어 

 - 로컬 준비 순서임: cp .env.example .env 후 비번/포트 채움 → docker network prune 같은 건 불필요, 기본 네트워크 pulseticket-network와 볼륨을 docker
    compose가 자동 생성함.
    
  - 볼륨만 먼저 미리 만들고 싶으면(선택):
    docker volume create pulseticket_postgres_data
    docker volume create pulseticket_redis_data
    docker volume create pulseticket_gradle_cache
    docker volume create pulseticket_gradle_user_cache
    docker volume create pulseticket_grafana_data
    docker volume create pulseticket_loki_data



  메인 스택(app/postgres/redis/모니터링)

  - 빌드+실행: docker compose -f docker-compose.yml -f docker-compose.override.yml up -d --build
  - 상태 확인: docker compose ps / 로그: docker compose logs -f app (또는 postgres, redis 등)
  - 중지(볼륨 보존): docker compose -f docker-compose.yml -f docker-compose.override.yml down
  - 중지+볼륨 삭제까지: docker compose -f docker-compose.yml -f docker-compose.override.yml down -v (데이터 날아가니 주의)

  테스트 스택(postgres-test/redis-test)

  - 실행: docker compose -f docker-compose.test.yml -f docker-compose.test.override.yml up -d
  - 상태 확인: docker compose -f docker-compose.test.yml -f docker-compose.test.override.yml ps
  - 중지: docker compose -f docker-compose.test.yml -f docker-compose.test.override.yml down (필요 시 -v로 테스트 볼륨 초기화)

  유용한 확인용 명령

  - 볼륨 목록: docker volume ls | grep pulseticket
  - 컨테이너 로그 단발: docker compose logs --tail=200 app
  - 재빌드만: docker compose -f docker-compose.yml -f docker-compose.override.yml build

### Docker-compose 설정



```yml
# ============================================================================
# Docker Compose 설정 파일
# PostgreSQL, Redis, Spring Boot 애플리케이션을 하나의 네트워크로 구성
# ============================================================================

name: pulseticket

services:
  # ============================================================================
  # PostgreSQL 데이터베이스 서비스
  # ============================================================================
  postgres:
    image: postgres:16-alpine
    container_name: pulseticket-postgres
    mem_limit: 100m
    mem_reservation: 50m
    env_file:
      - .env
    environment:
      PGDATA: /var/lib/postgresql/data/pgdata
    ports:
      # 호스트 포트:컨테이너 포트 (docker-compose.override.yml에서 설정)
      - "${POSTGRES_HOST_PORT:-5432}:${POSTGRES_PORT:-5432}"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init:/docker-entrypoint-initdb.d
    networks:
      - pulseticket-network
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -h localhost -p ${POSTGRES_PORT:-5432} -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
      interval: 10s
      timeout: 5s
      retries: 5
    labels:
      logging: "promtail"
      logging_jobname: "pulseticket-postgres"
    restart: unless-stopped

  # ============================================================================
  # Redis 캐시 서비스
  # ============================================================================
  redis:
    image: redis:7-alpine
    container_name: pulseticket-redis
    mem_limit: 50m
    mem_reservation: 25m
    env_file:
      - .env
    command: redis-server --port ${REDIS_PORT:-6379} --appendonly yes --requirepass ${SPRING_DATA_REDIS_PASSWORD}
    ports:
      # 호스트 포트:컨테이너 포트 (docker-compose.override.yml에서 설정)
      - "${REDIS_HOST_PORT:-6379}:${REDIS_PORT:-6379}"
    volumes:
      - redis_data:/data
    networks:
      - pulseticket-network
    healthcheck:
      # Redis 준비 상태 확인 (포트는 docker-compose.override.yml에서 설정)
      test: [ "CMD", "redis-cli", "-p", "${REDIS_PORT:-6379}", "--raw", "incr", "ping" ]
      interval: 10s
      timeout: 5s
      retries: 5
    labels:
      # Promtail이 이 컨테이너의 로그를 수집하도록 설정
      logging: "promtail"
      logging_jobname: "pulseticket-redis"
    restart: unless-stopped

  # ============================================================================
  # Spring Boot 애플리케이션 서비스 (개발 모드)
  # 소스 코드 변경 시 자동 반영을 위한 볼륨 마운트 사용
  # ============================================================================
  app:
    build:
      # 개발 모드용 Dockerfile 사용
      context: .
      dockerfile: Dockerfile.dev
    container_name: pulseticket-app
    mem_limit: 1536m
    mem_reservation: 768m
    env_file:
      - .env
    environment:
      # JVM 힙 메모리 설정 (컨테이너 limit보다 작게 설정)
      JAVA_OPTS: "-Xms512m -Xmx1200m"
      # Docker 네트워크 내부에서 사용하는 호스트명으로 변경
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:${POSTGRES_PORT:-5432}/${POSTGRES_DB}
      SPRING_DATASOURCE_USERNAME: ${SPRING_DATASOURCE_USERNAME}
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: ${REDIS_PORT:-6379}
      # 프로파일 설정 (개발 환경)
      SPRING_PROFILES_ACTIVE: docker,dev
      # Spring Boot DevTools 활성화를 위한 설정
      SPRING_DEVTOOLS_RESTART_ENABLED: "false"
      SPRING_DEVTOOLS_LIVERELOAD_ENABLED: "false"
    volumes:
      # 소스 코드를 볼륨으로 마운트하여 실시간 변경사항 반영
      - ./src:/app/src:rw
      - ./build.gradle.kts:/app/build.gradle.kts:ro
      - ./settings.gradle.kts:/app/settings.gradle.kts:ro
      - ./gradlew:/app/gradlew:ro
      - ./gradle:/app/gradle:ro
      # Gradle 캐시 디렉토리 (빌드 속도 향상)
      - gradle_cache:/root/.gradle
      # Gradle 사용자 홈 디렉토리 캐시 (익명 볼륨 방지)
      - gradle_user_cache:/home/gradle/.gradle
    networks:
      - pulseticket-network
    depends_on:
      # PostgreSQL과 Redis가 준비된 후 애플리케이션 시작
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    labels:
      # Promtail이 이 컨테이너의 로그를 수집하도록 설정
      logging: "promtail"
      logging_jobname: "pulseticket-app"
    restart: unless-stopped

  # ============================================================================
  # Grafana 서비스
  # 로그 시각화 및 모니터링 대시보드
  # ============================================================================
  grafana:
    image: grafana/grafana:11.3.0
    container_name: pulseticket-grafana
    mem_limit: 150m
    mem_reservation: 75m
    ports:
      - "${GRAFANA_PORT:-3000}:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      # 데이터 영속성을 위한 볼륨 마운트
      - grafana_data:/var/lib/grafana
      # 커스텀 설정 파일 마운트
      - ./docker/grafana/grafana.ini:/etc/grafana/grafana.ini
    networks:
      - pulseticket-network
    depends_on:
      - loki
    restart: unless-stopped

  # ============================================================================
  # Loki 서비스
  # 로그 수집 및 저장
  # ============================================================================
  loki:
    image: grafana/loki:3.3.0
    container_name: pulseticket-loki
    mem_limit: 150m
    mem_reservation: 75m
    ports:
      - "${LOKI_PORT:-3100}:3100"
    command: -config.file=/etc/loki/local-config.yaml
    volumes:
      - ./docker/loki/loki-config.yaml:/etc/loki/local-config.yaml
      - loki_data:/loki
    networks:
      - pulseticket-network
    restart: unless-stopped

  # ============================================================================
  # Promtail 서비스
  # Docker 컨테이너 로그 수집 및 Loki로 전송
  # ============================================================================
  promtail:
    image: grafana/promtail:3.3.0
    container_name: pulseticket-promtail
    mem_limit: 70m
    mem_reservation: 35m
    command: -config.file=/etc/promtail/promtail.yaml
    volumes:
      - ./docker/promtail/promtail.yaml:/etc/promtail/promtail.yaml
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
    networks:
      - pulseticket-network
    depends_on:
      - loki
    restart: unless-stopped

# ============================================================================
# 네트워크 설정
# ============================================================================
networks:
  pulseticket-network:
    driver: bridge

# ============================================================================
# 볼륨 설정
# ============================================================================
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  # Gradle 캐시 볼륨 (개발 모드에서 빌드 속도 향상)
  gradle_cache:
    driver: local
  # Gradle 사용자 홈 디렉토리 캐시 볼륨
  gradle_user_cache:
    driver: local
  # Grafana 데이터 볼륨
  grafana_data:
    driver: local
  # Loki 데이터 볼륨
  loki_data:
    driver: local


```

Postgres는 기본적으로 컨테이너 내부의
/var/lib/postgresql/data 디렉터리에 데이터를 저장한다.​

PGDATA 환경변수는 “컨테이너 안에서” 실제 데이터 파일이 들어 있는 서브 디렉터리를 지정하는 역할을 한다. 
PGDATA is an environment variable used to specify the path to the subdirectory containing the database files within the container.​

쉽게 말하면:
컨테이너 안 기준으로 “DB 파일 폴더가 여기야” 라고 알려주는 설정

내 설정: PGDATA=/var/lib/postgresql/data/pgdata
→ 컨테이너 안에서 이 경로에 데이터 디렉터리가 만들어짐​

1. PGDATA: /var/lib/postgresql/data/pgdata

  PostgreSQL이 실제 데이터를 저장할 디렉토리 경로를 지정하는 것임.

  - PGDATA는 PostgreSQL의 환경변수
  - 데이터베이스 파일들(테이블, 인덱스, 설정 등)이 이 경로에 저장됨
  - 여기서는 /var/lib/postgresql/data/pgdata로 지정했음

  2. ports: - "${POSTGRES_HOST_PORT:-5432}:${POSTGRES_PORT:-5432}"

  호스트와 컨테이너 간의 포트 매핑 설정임.

  호스트_포트:컨테이너_포트

  - ${POSTGRES_HOST_PORT:-5432}: .env 파일에 POSTGRES_HOST_PORT가 있으면 그 값 사용, 없으면 5432 사용 (호스트 포트)
  - ${POSTGRES_PORT:-5432}: 컨테이너 내부 포트 (기본값 5432)
  - 이 설정으로 localhost:5432로 접속하면 → 컨테이너 내부의 5432 포트로 연결됨

  3. volumes: - postgres_data:/var/lib/postgresql/data

  컨테이너가 삭제되어도 데이터가 사라지지 않도록 볼륨을 마운트하는 것임.

  볼륨_이름:컨테이너_내부_경로

  - postgres_data: Docker가 관리하는 named volume (docker-compose.yml 하단에 정의됨)
  - /var/lib/postgresql/data: 이 경로를 볼륨으로 마운트함

  핵심 포인트: 경로 관계

  볼륨 마운트: postgres_data → /var/lib/postgresql/data
                                      └─ /pgdata (실제 DB 데이터 위치, PGDATA 설정)

  왜 이렇게 했는가?

  PostgreSQL 공식 이미지는 /var/lib/postgresql/data를 볼륨으로 권장함. 하지만 이 디렉토리에 바로 데이터를 쓰면 볼륨 마운트 시 권한 문제가 발생할
  수 있음. 그래서:

  1. 볼륨은 /var/lib/postgresql/data에 마운트
  2. 실제 데이터는 그 하위의 /var/lib/postgresql/data/pgdata에 저장

  이렇게 하면 권한 문제를 피하면서도 데이터 영속성을 보장할 수 있음.

  정리

  environment:
    PGDATA: /var/lib/postgresql/data/pgdata  # ← "여기에 DB 데이터 저장해"

  volumes:
    - postgres_data:/var/lib/postgresql/data  # ← "이 경로를 영구 저장소로 마운트"

  컨테이너를 삭제(docker-compose down)해도 postgres_data 볼륨은 남아있어서 데이터가 보존됨.







### 다 정리 못하겠다

설정이 너무 많아

### PostgreSQL 에서 데이터를 남기려면 왜 volume 을 꼭 써야 하는가?

컨테이너도 디스크 (파일 시스템) 이 있다.
컨테이너가 생성될때 Docker 가 writable layer 를 만들어줌
이 레이어 위에 `/var/lib/postgresql/data/...` 같은 파일이 저장될 수 있음

근데 이 writable layer 는 컨테이너 생명주기와 같이 감.
그러니까 컨테이너를 삭제하면 레이어도 같이 날라감.

그래서 volume 은 컨테이너의 생명주기와는 별도로 호스트 쪽에 있는 정보가 유지되는 저장소.

그래서 Postgres 같은 DB는:

- 컨테이너 내부 경로: `/var/lib/postgresql/data` (혹은 `/pgdata` 등)
- 이 경로를 volume에 연결해서  
    “DB는 자기 로컬 디렉토리에 쓰는 것처럼 보이는데, 실제로는 호스트의 영구 저장소에 쓰는 구조”를 만드는 것

```yaml
- postgres_data:/var/lib/postgresql/data
```
이 부분이 그 역할.
