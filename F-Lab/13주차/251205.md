
## 왜 DB 에서 Atomicty 를 달성하기 어려운가 ? CPU/ALU 레벨에서는 간단한데.

### 연산하려는 대상이 작다

cpu 가 한번에 atomic 하게 연산이 보장되려면 한 워드 크기의 메모리 연산 정도임.
이건 레지스터/버스/캐시 안에서 하나~몇 사이클 안에 끝나는 아주 작은 연산.
-> 다루는 데이터 범위가 좁고, 시간도 짧음.

DB 의 경우 트랜잭션 안에 있는 모든 작업에 대해 all-or-nothing을 요구하는데,
이 작업들은 여러 record, page, 인덱스, 심지어 DB 외의 서비스까지 겹칠 수 있음.

### 하드웨어가 순서를 완전히 컨트롤 한다

한 코어 안에서 실행되는 instruction 은 파이프라인, 버스, 캐시 프로토콜에 의해
"중간 상태가 바깥에 공개되지 않게" 설계됨.

즉 하드웨어상으로 이미 어떤 8바이트 저장 instruction 이 실행될때 그 8바이트를 
반만 쓰인 상태로 다른 코어가 보지 못하게 설계.

회로 수준에서 중간 상태르 외부에 노출하지 않는다는 규칙을 만들어버림.

CPU 는 자기의 공간 안에서 모든 타이밍/순서를 통제할 수 있지만,

DB 의 경우 디스크에 언제 flush 되는지, OS 가 언제 죽는지, 프로세스라 언제 크래시나느지 통제할 수 없음.
DB 는 DB 바깥의 환경에 영향을 많이 받음.


### 환경이 단순하다

CPU 입장에서 atomic 을 구현할때 신경써야 할건 
레지스터, 캐시, 메인메모리 등.
그리고 이들의 속도는 굉장히 빠름.


DB 환경 : 디스크,. 네트워크, 다른 프로세스, 여러 노드.
트랜잭션하나가 수 ms ~ 수 초까지 갈 수 있는데,
그 사이에 crash, 장애, 컨텍스트 스위칭이 다 일어날 수 있음.
여러 리소스에 흩어진 상태를 commit 시점에 논리적으로 한 시간에 한번에 바뀐 것처럼 유지해야하는데,
이게 보통 만만찮은 일이다.


## Websocket vs Long polling vs polling


### Polling 

클라이언트가 주기적(예로 들면 1초)으로 서버에 요청을 보내 확인

장점 : 구현이 쉽고, 기존 HTTP 로 구현이 가능하며 브라우저 호환성이 좋다
단점 : 빈번한 요청으로 서버 부하가 증가하고, 실시간성이 떨어짐 (1초 사이에 변화를 감지할 수 없음)으로,
짧은 시간내에 많은 변화가 일어나기에는 부적합함.


### Long polling

클라이언트가 서버에 요청을 보냄
서버는 바로 응답하지 않고, 새 데이터가 생길때까지 연결을 오래 유지
새 데이터가 생기면 그떄 응답 
클라이언트는 응답 받자마자 다시 요청을 보내서 연결을 유지

장점 : 
Polling 보다 실시간성이 우수
일반 HTTP 위에서 동작 -> 여전히 호환성이 좋음 -> WebSocket이 어려운 인프라에서도 사용가능

단점 : 연결을 유지하고 있어서 서버 리소스가 큼
동시 접속자 수가 많으면 커넥션 관리 부담이 큼
여전히 요청-응답 반복이 필요

-> 사용자가 적으면 괜찮자면, 피크 타임에는 한계가 온다.

### Websocket

최초 한번만 HTTP 로 핸드셰이크 -> 그 후 , 양방향 지속 연결 유지
서버와 클라이언트가 서로에게 알림 가능
메인 HTTP 헤더를 실어 나르지 않음 -> 오버헤드 적고 효율적

장점 : 
지연이 매우 낮음
동시 접속기 많을수록 polling/long polling 보다 유리
서버가 여러 클라이언트에게 브로드 캐스팅하기 좋음

단점:
polling 에 비해 구현복잡도가 큼
로드밸런서, 프록시 설정 등도 신경써야함
