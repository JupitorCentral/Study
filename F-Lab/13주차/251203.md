
## Java Persistence with Hibernate

### What is Persistence ?

데이터가 app 의 생명주기를 넘어서 살아있는 것.

### The paradigm mismatch

여기서 말하는 paradigm mismatch 는, 
Java 에서의 데이터 모델, 또는 클래스 등의 구조가
DB 와는 맞지 않는 상황을 말한다.

즉 객체지향적 파라다임과 관계형 패러다임이 서로 안맞음을 일컫는것.


이커머스 시스템을 만든다고 쳐보자.

User -> BillingDetails

```java
public class User {
	String username;
	String address;
	Set billingDetails;
// Accessor methods (getter/setter), business methods, etc.
}
public class BillingDetails {
	String account;
	String bankname;
	User user;
// Accessor methods (getter/setter), business methods, etc.
}
```

```sql
create table USERS (
USERNAME varchar(15) not null primary key,
ADDRESS varchar(255) not null
);

create table BILLINGDETAILS (
ACCOUNT varchar(15) not null primary key,
BANKNAME varchar(255) not null,
USERNAME varchar(15) not null,
foreign key (USERNAME) references USERS
);
```

#### problem of granularity ... ?

데이터 granularity라고 하면 데이터가 얼마나 세밀하게 쪼개져 저장·표현되어 있는지(예: 일 단위 vs 분 단위 로그)를 말한다.
시스템·아키텍처에서는 기능이나 작업을 얼마나 작은 단위까지 나눴는지 표현할 때 쓰며, fine-grained(고운 granularity) / coarse-grained(거친 granularity) 같은 말로 같이 나온다.

그러니까 나눔정도에서의 문제...? 얼마나 작게 나눌 것인가에 대한 고민?

glaringly  adv -> 눈에 띄게, (나쁜 점이)) 두드러지게, 명백하게

모든 유저에게는 '주소' 가 있다.
근데 이 주소가 지금 테이블에는 하나의 varchar, 즉 String 으로 저장되어 있으나
실제로는 구, 동, 길 이렇게 나누어져 있음.
-> 그럼 DB 에는 도대체 어떻게 저장할 것 인가??

You have the choice of adding either several columns or a
single column (of a new SQL data type). This is clearly a
problem of granularity.

그러니까, 하나의 정보를 담기 위해 여러개의 컬럼을 둘것인지, 아니면 하나의 컬럼 또는 새로운 타입의 하나의 컬럼을 둘 것인지에 대한 고민을 하게 된다.
이게 바로 problem of granularity.

```sql
create table USERS (
	USERNAME varchar(15) not null primary key,
	ADDRESS address not null
);

create table USERS (
	USERNAME varchar(15) not null primary key,
	ADDRESS_STREET varchar(255) not null,
	ADDRESS_ZIPCODE varchar(5) not null,
	ADDRESS_CITY varchar(255) not null
);

-- 이렇게 해야 하나, 저렇게 해야 하나...
```



#### the problem of subtype

자바에서는, 상속을 사용한다. super - subclass 를 이용해서.
이게 왜 mismatch problem 을 낳을 수 있는지 저자는 다음과 같은 모델을 제시함.


![[Screenshot 2025-12-03 at 5.50.30 PM.png|600]]


java 에서는 이게 구현이 가능한데, DB 에는 이 상황을 도대체 어떻게 테이블로 구현해야 할까?
DB 에서는 BillingDetails 을 확장한 CreditCard 테이블을 만들 수 있나? 당연히 불가능.

상속 뿐만 아니라, polymorphism 즉 다형성에 대한 문제도 있다.

User class 는 BillingDetails 클래스와의 관계가 있는데, 이건 다형적 관계이다 (polymorphic association)
runtime 중에 User 는 BillingDetails 의 어떤 subclass instance 를 참조할지 모름.
(BillingDetails 를 interface 로 생각하면 더 다가온다)

SQL DB 에서는 이런 관계를 표현할 방법이 없다. f key 는 반드시 하나의 테이블을 가리켜야한다. 하나의 foreign key 가 
여러개의 테이블을 가리킨다는게 '직관적' 이지 않음. 
그걸 구현하기 위해서는, 그러한 제약조건을 만족시키기 위해선 여러개의 sql 문을 강제로 날려야 할 것.

이런 문제에 대한 해답을 ORM 이 제시한다. 


#### The problem of identity

시스템이 복잡하다보면, 2개의 인스턴스가 같은지를 판단해야 할 경우가 있다.
자바에서는 2가지 방식의 '같음' 이 있음

첫번째 : instance identity -> a == b (memory location, 즉 물리적으로 실제로 같은 인스턴스인지)
두번째 : instance equality -> a.equals(b) (also called equality by value, 즉 값이 같으면 같은 객체라는 것)

DB 에서의 identity 는 pk  로 정의된다.
근데, db 에서는 때에 따라서 identity 인지, equality 인지 명확하지가 않음.
-> 즉 Java 랑 매칭이 안됨.


#### Problems relating to associations

관계와 관련된 문제.

우리가 예시로 든 모델에서는 association 이 엔티티 사이의 '관계(relationships)' 를 나타낸다.
User , Address, BillingDetails 클래스들이 모두 연관이 있음.

근데 Address 와는 다르게, BillingDetails 는 테이블이 따로 나뉘어져 있음. 즉 지혼자 스스로 독립되어 있음.
BillingDetails 의 인스턴스는 (자바에서) BillingDetails 테이블에 저장이 되는 것이기 때문에.

객체지향적 언어는 관계를 Object reference (객체 참조) 를 이용해 표현함.
하지만 relational world, 즉 관계형 테이블의 세계에서는, 외부키 제약으로 관계를 표현함. 값의 복사를 통해서.
이 제약조건이 관계의 integrity (완전함) 을 보장함.
그런데 이 2가지 방식은 큰 차이점이 있음.

객체 참조 방식은 상속적이며 방향이 있음(directional). 포인터니까. 두 객체 사이를 오고가고 싶다면, 
관계를 2번 정의해야 함 (A->B, A<-B) - 즉 각자 서로를 향하는 포인터가 있어야함

```java
public class User {
Set billingDetails;
}

public class BillingDetails {
User user;
}
```

관계형 데이터 모델에서는, 이러한 특정 방향으로의 '탐색' 이 무의미함.
그냥 원하는 컬럼 가지고 조인해버리거나, projection 을 써버리면 되기때문에 (A join B = B join A)


“문제(도전 과제)는, 애플리케이션과 독립적인 ‘완전히 열려 있는(open)’ 데이터 모델을  
이 특정 애플리케이션이 필요로 하는 연관들만 제한적으로(narrow) 갖는, 애플리케이션 의존적인 네비게이션 모델로 매핑하는 데 있다.”
-> 말이 정말 어려운데, 다시 말하자면

DB 쪽은 뭐든지 조인해서 볼 수 있는 ‘열린 세계’인데,  
자바 쪽 도메인 모델은 특정 앱이 실제로 쓰는 관계들만 골라서 ‘길이 정해진 그래프(네비게이션 모델)’로 만들어 놓는다.  
이 둘을 어떻게 매끄럽게 1:1로 대응시키느냐가 ORM의 어려운 점이다. 라는 말.


그리고 Java 에서는 many-to-many 'multiplicity' 를 가질 수 있음.

```java
public class User {
	Set billingDetails;
}
public class BillingDetails {
	Set user
}
```

근데 BillingDetails의 foreign key 는 many-to-one 관계임. 
각각의 은행계좌는 한 사람에게만 엮여있음.

만약 RDBMS 에서 이런 관계를 정의하고 싶다면 중간 테이블 - 소위 말하는 'link table' 을 두어야 함.

```sql
create table USER_BILLINGDETAILS (
	USER_ID bigint,
	BILLINGDETAILS_ID bigint,
	primary key (USER_ID, BILLINGDETAILS_ID),
	foreign key (USER_ID) references USERS,
	foreign key (BILLINGDETAILS_ID) references BILLINGDETAILS
);
```



#### The problem of data navication

java 와 rdbms 에서 데이터를 접근하는 방식은 근본적으로 다르다.
java 에서는 어떤 사용자의 결제 정보를 접근하기 위해선

```java
someUser.getBillingDetails().iterator().next()
```
이런식으로 접근한다. 이건 walking the object network (object graph) 이라고도 불림.
하나의 인스턴스에서 다른 인스턴스로, 주소를 가지고 넘어감.

근데 이건 db 에서 접근하기 좋은 방식이 아님.

data 접근의 퍼포먼스를 낫게 하기 위한 가장 중요한 한가지는 바로 db 에 대한 요청을 최대한 줄이는 것임.
sql query 의 수를 줄이는 것이 그 예가 될 것.

그래서 rdbms 에 이상적인 request 는 관심이 되는 테이블들의 join 이 필요하게 됨.

-> 그니까 객체지향언어에서는 여러 단계별로 데이터를 가져가는게 이상적이나 (SRP 때문), 
DB 에서는 한번에 가져오는게 이상적임.

예를 들면, 결제정보에는 관심이 없으나 사용자정보에만 관심있으면

```sql
select * from USERS u where u.ID = 123
```

단순히 이렇게 쓰면 되는데, 결제정보까지 관심이 있다면

```sql
select * from USERS u
	left outer join BILLINGDETAILS bd
		on bd.USER_ID = u.ID
where u.ID = 123
```

이렇게 써야한다. 

그러니까 조인을 효율적으로 쓰려면, 처음 엔티티를 가져올때, 이후의 객체 그래프에서 어디까지 탐색할건지를 미리 알고있어야 한다는 얘기.

제대로 된 ORM (Object - relation Mapping) 이라면, 연관된 객체는 자바 코드에서 
그 연관을 '처음으로' 접근할때 비로소 로딩하는 기능 - 즉 lazy fetch 를 제공한다.


piecemeal -> 조각조각인

`This piecemeal style of data access is fundamentally
inefficient in the context of an SQL database, because it
requires executing one statement for each node or
collection of the object network that is accessed. This is the
dreaded n+1 selects problem.`

이러한 조각조각 필요한 순간마다 하나씩 쿼리를 날리는 방식은 db 입장에서는 비효율적.
각 그래프의 노드마다 select 를 하나씩 날리게 되는데, 이걸 흔히 n+1 selects problem 이라고 부름.


Object network﻿  
-> “엔티티들을 연관 관계로 엮었을 때, User → BillingDetails → Orders → OrderLines → Product﻿처럼 ‘객체들이 포인터로 이어진 그래프 전체’를 말한다.”

Lazy loading﻿  
“연관을 실제로 접근할 때까지 DB에서 안 가져오고, 접근하는 순간 추가 SELECT﻿로 필요한 데이터만 가져오는 방식.

n+1 selects problem﻿  
“한 번의 조회로 n개의 엔티티를 가져온 뒤, 그 각각에 대해 연관을 로딩하느라 n번 더 쿼리를 날려서, 총 n+1﻿번의 SELECT﻿가 발생하는 패턴. 적은 데이터에서는 티가 안 나지만, 데이터가 커지면 심각한 성능 문제가 된다.”



### proxy entity 에 대해서

```java
public static Reservation reserve(User user, Seat seat) {  
    return Reservation.builder()  
       .user(user)  
       .seat(seat)  
       .event(seat.getEvent())  
       .status(Reservation.ReservationStatus.PENDING)  
       .expiresAt(LocalDateTime.now().plus(Reservation.RESERVATION_EXPIRATION))  
       .build();  
}
```

위 코드에서 seat.getEventId() 를 하면, 
Event 를 불러오기 위해 또 select 문이 생성되는가 ?

아니라고 한다.





## JPA annotation

@JoinColumn(insertable = false, updatable = false)
-> 이 필드는 db 에서 읽기만하고, insert/update query 에는 절대 포함시키지 말 것.
이렇게 쓰는 이유는

```java
@Entity
class Reservation {

    @Column(name = "user_id")
    private Long userId;  // 진짜로 INSERT/UPDATE 하는 FK 컬럼

    @ManyToOne
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private User user;    // 같은 컬럼을 공유하지만, 연관은 read-only
}
```

이런식으로 fk 를 직접 다루기 위해서이다.


일반적으로는 
```java
@Entity
class User {

    @OneToMany(mappedBy = "user")
    private List<Reservation> reservations = new ArrayList<>();
    // mappedBy = "user" 는 Reservation.user 필드가 FK 소유자라는 뜻
}

@Entity
class Reservation {

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;  // Reservation 테이블의 user_id FK 컬럼
}
```


이 상황에서,

```java
Reservation reservation = reservationRepository.findById(reservationId);

reservation.getUser(),getId();
```

일때, User 값을 얻기 위한 select 문이 한번 더 실행될까?

@ManyToOne 은 기본적으로 Eager fetch 이므로, reservation.getUser() 에 대한 이미 호출되어서 추가적으로 select 문이 실행되지 않는다.

만약 ManyToOne(featch=Lazy) 즉 lazy fetch 일 경우 
User 필드에는 UserProxy 가 생성되는데, 
 

#### Field Access vs Property Access

- Field Access 
  -> @Id private long id; 처럼 필드에 직접 어노테이션을 붙이면, Hibernate 가 user.id 필드를 직접 붙인다.

- Property Access : 
	  private long id; 
	public Long getId() { return id; } 에 @Id 를 붙임
	-> Hibernate 가 @getter 메서드를 통해 읽음

```java
@Entity(access = AccessType.FIELD)  // field access
@Entity(access = AccessType.PROPERTY) // property access (기본값)
```


### JPA column access

```java
@ManyToOne(fetch = FetchType.LAZY)  
@JoinColumn(name = "seat_id")  
private Seat seat;  
/**  
 * 예약된 좌석의 id  
 */@Column(name = "seat_id", nullable = false)  
private Long seatId;
```
이렇게 하면

```java
Caused by: org.hibernate.MappingException: Column 'event_id' is duplicated in mapping for entity 'personnel.jupitorsendsme.pulseticket.entity.Reservation' (use '@Column(insertable=false, updatable=false)' when mapping multiple properties to the same column)
...
```
이런 오류를 뱉는다. 

즉 하나의 엔티티에서 하나의 컬럼은 기본적으로 하나의 필드만 책임져야 한다.

Hibernate 는 엔티티를 스캔하면서, "어떤 필드가 어떤 컬럼에 매핑되는지" 메타 데이터를 만든다.
이때 하나의 엔티티 안에 같은 컬럼 이름을 두 필드가 공유하면, Hibernate 는 위와 같은 에러를 낸다.

ORM 은 
 “클래스 ↔ 테이블, 프로퍼티 ↔ 컬럼, 연관관계 ↔ 외래 키” 같은 매핑 메타데이터를 먼저 만든 다음, 이걸 기준으로 SQL을 생성하고 결과를 엔티티 필드에 채워 넣는다

또 Hibernate 가 변경 감지(dirty checking)를 위해 “엔티티의 각 프로퍼티 값을 추적해서 바뀐 컬럼만 UPDATE 한다”고 설명한다

Hibernate 입장에선 “컬럼 단위로 어느 필드를 봐야 하는지”가 명확해야만 변경 감지, 캐시, SQL 생성이 깔끔하게 돌아간다

동일한 컬럼을 여러 필드에 막는 이유는

1. 쓰기 충돌 방지 (두 필드가 모두 insertable=true, updatable=true 면) 어느 값으로 인서트/업데이트 해야 하는지 모순이 생김
2. 변경 감지 일관성 : Hibernate 는 프로퍼티 단위로 '이 컬럼이 바뀌었는지' 판단하는데,
   같은 컬럼을 두 필드가 다르게 들고 있으면 어떤 값을 진실로 볼지 알 수가 없음.
3. 캐시/2차 캐시 일관성 : 필드 매핑이 1:1이 아니면 엔티티 상태를 직렬화·역직렬화할 때도 혼선이 생김


-  엔티티 상태를 직렬화·역직렬화 ???
-> 직렬화는 자바 객체를 byte 배열 등으로 변환하여 전송 가능한 형태로 바꾸는 것.
역직렬화는 그 반대로 byte 를 자바 객체로 복원하는 과정

Hibernate 2차 캐시는 엔티티 상태를 캐시에 넣을때, 
`java.io.Serializable`을 구현한 값들을 “byte stream 으로 변환해서(VARBINARY 같은 컬럼이나 메모리 캐시에 저장) 
다시 꺼낼 때 그 byte를 풀어서 원래 객체로 복원한다”고 설명한다


## Hibernate 의 캐시

1차 캐시와 2차 캐시가 있다.

DB 에 쓰기 직전 상태의 엔티티와 그 스냅삿이 메모리에 있는 곳은 1차 캐시, 즉 persistence context 쪽이 맞다.

persistence context (1차 캐시) 는 항상 메모리에 있고, 각 Entity Manager/ Session 마다 하나씩 있다.


## 객체가 persist 되는 과정

![[Screenshot 2025-12-04 at 9.53.02 AM.png|600]]


![[Screenshot 2025-12-04 at 9.52.44 AM.png|500]]

em.persist 는 클래스 Item 의 instance 'item' 을 persistent, '영속화' 한다.
(그 이전에는 item 은 transient 상태)

Iten instance 를 db 에 저장하기 위해, Hibernate 는 INSERT SQL statement 를 실해앻야 한다.
지금 하고 있는 작업의 단위의 transaction 이 commit 할때,
Hibernate 는 persistence context 를 flush 하고, 그리고 나서 INSERT 가 발생한다.

Hibernate 는 또한 INSERT 를 JDBC level 에서 다른 statement 와 함꼐 'batch' 할 수 있음.
(그러니까 여기서 batch 는 한꺼번에 실행한다는 의미)




