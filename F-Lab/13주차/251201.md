## 가격에 대한 PostgreSQL 타입 고민

 **추천 타입 (우선순위순)**

  

  ### **1. NUMERIC(precision, scale) - 가장 추천**


  ticket_price NUMERIC(10, 2) NOT NULL,
  - **장점**:
    - 정확한 소수점 계산 (부동소수점 오차 없음)
    - Java의 BigDecimal과 완벽하게 매핑됨
    - 국제 통화 지원 (달러, 유로 등 소수점 필요)
    - 금융 계산에 표준으로 사용됨

  - **precision, scale 설정**:
    - NUMERIC(10, 2): 최대 99,999,999.99 (1억 미만, 소수점 2자리)
    - NUMERIC(12, 2): 최대 9,999,999,999.99 (100억 미만, 소수점 2자리)
    - NUMERIC(15, 2): 최대 9,999,999,999,999.99 (경우에 따라)

  

  ### **2. INTEGER - 원화 전용이라면**

  ticket_price INTEGER NOT NULL,

  - **장점**:
    - 단순하고 저장 공간 효율적
    - 원화는 소수점이 없어서 적합함
    - 인덱스 성능이 약간 더 좋음

  - **단점**:
    - 나중에 다른 통화 지원 시 마이그레이션 필요
    - 할인율 계산 시 반올림 문제 발생 가능


  ### **3. BIGINT - 큰 금액의 원화**

  ticket_price BIGINT NOT NULL,
  - INTEGER보다 큰 범위 (최대 9,223,372,036,854,775,807)
  - 고액 티켓이라면 고려

###   **4. MONEY - 비추천**

  ticket_price MONEY NOT NULL,

  - **단점**:
    - PostgreSQL 전용 타입 (이식성 낮음)
    - 로케일에 의존적
    - JPA 매핑이 복잡함
    - 일반적으로 권장하지 않음


## 결제 플로우

### PG - payment Gateway 
-> 우리 서버와 은행 사이의 중개자 역할

### 토큰
-> 카드 정보를 안전하게 바꿔놓은 임시 ID

#### 토큰 만료

일회용 토큰 : 하나의 결제에 쓰이면 더 이상 못씀
시간 제한 : 생성 후 5분 안에 써야 함

### 실제 결제 플로우

1. 클라이언트에서 토큰 생성
사용자 카드 정보 입력 -> 브라우저의 JavaScript 가 바로 PG 서버로 전송
-> PG 가 토큰을 생성해서 브라우저에게 돌려줌. 우리 서버를 거치지 않는다.

2. 토큰을 서버로 전달
-> 브라우저가 받은 토큰 + 주문 정보를 우리 백엔드 서버로 보냄.
이떄 카드정보는 없고 토큰만 있음.

3. 서버가 PG 에 결제 요청
-> 서버가 이 토큰을 들고 PG 서버에 '이 토큰으로 결제를 승인해줘' 라고 요청.
이때 우리 서버만 알고 있는 비밀키를 같이 보내서 인증.

4. 서명 검증
-> PG 가 서버의 요청에 대해 응답할때, 메시지 내용을 특정 알고리즘  (SHA-256 등의) 으로 암호화한 서명을 같이 보냄.
그걸 가지고 서버에서 요청 내용이 일치하는지 확인.


### 플로우 요약 

1. 클라이언트(브라우저) → PG: 카드 정보 전송, 토큰 받음
    
2. 클라이언트 → 너희 서버: 토큰 + 주문 정보 전송
    
3. 너희 서버 → PG: 토큰 + 비밀키로 결제 승인 요청
    
4. PG → 은행: 실제 카드 정보로 승인 요청
    
5. 은행 → PG → 너희 서버: 승인/거절 결과
    
6. 너희 서버 → 클라이언트: 최종 결과



