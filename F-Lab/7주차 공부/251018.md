
## spring 의 proxy pattern 에 대하여

(spring 5 Design pattern > Consideration of Structural and Behavioral patterns > Examining the core design patterns > Structural Design patterns > Proxy Design )


Proxy design 은 어떤 클래스의 객체를 제공하는데, 이 객체는 다른 클래스의 기능을 가진 객체이다.
실제 객체를 직접 사용하지 않고, 대리인 객체를 만들어 제공하는 패턴.

이 패턴은 GOF design patterns 의 structural design 패턴 (구조적 디자인 패턴) 에 속한다.

GOF ? -> Gang of Four

- GOF(Gang of Four)**는 네 명의 저자(Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides)를 가리키는 말.
- 이 네 명이 쓴 책이 바로 **"Design Patterns: Elements of Reusable Object-Oriented Software"**(1994)이고, 이 책에서 23가지의 대표적인 디자인 패턴을 정리함.
- 이 패턴들은 소프트웨어 설계에서 반복적으로 등장하는 문제를 해결하기 위한 베스트 프랙티스(best practice)로, 객체지향 프로그래밍에서 아주 널리 쓰인다.


GOF 가 정의한 23개의 디자인 패턴 중, 프록시 패턴은 '클래스와 객체들의 구조' 를 설계하는데 사용되는 패턴

### 프록시 패턴의 핵심 목적

- 실제 객체 (Real Object) 대신 대리인 (proxy) 를 외부에 노출 시키는 것
- 하지만 이 대리인은 실제 객체와 똑같은 기능을 제공해야 함
- 클라이언트(외부) 는 프록시를 사용하는지, 실제 객체를 사용하는지 구별할 수 없어야 한다.


### 예시 코드

```java
// 1. Subject (공통 인터페이스)
public interface Account {
    void accountType();
}

// 2. RealSubject (실제 구현체)
public class SavingAccount implements Account {
    public void accountType() {
        System.out.println("SAVING ACCOUNT");
    }
}

// 3. Proxy (대리인)
public class ProxySavingAccount implements Account {
    private Account savingAccount;  // 실제 객체 참조
    
    public void accountType() {
        // 실제 객체가 없으면 생성 (lazy initialization)
        if (savingAccount == null) {
            savingAccount = new SavingAccount();
        }
        // 실제 객체에게 작업 위임
        savingAccount.accountType();
    }
}
```

```java
Account account = new ProxySavingAccount();  // 프록시 사용
account.accountType();  // 하지만 실제 기능은 동일!
```

#### 1. **실제 객체를 외부로부터 숨김 (Hide the actual object)**

- 클라이언트는 실제 구현체를 몰라도 됨

#### 2. **성능 향상 (Improve performance)**

- **Lazy initialization** (필요할 때만 생성)
- **Caching** (결과를 캐시해서 재사용)    

#### 3. **접근 제어 (Control access)**

- **보안 검사** (권한이 있는지 확인)
- **로깅** (메서드 호출 기록)


### Spring에서 프록시가 사용되는 곳:

1. **Spring AOP** - 트랜잭션, 보안, 로깅 등 횡단 관심사(cross-cutting concerns) 적용    
2. **Transaction Management** - `@Transactional` 어노테이션
3. **Security** - `@Secured`, `@PreAuthorize` 등
4. **Remote Services** - RMI, HTTP Invoker



## JSP 웹 프로그래밍

URL - 웹 브라우저에 주소줄이 쓰여저 있는 것. (Uniform Resource Locator)

프로토콜 + 서버이름 + 경로 + 쿼리 문자열 (파라미터)

http 는 따로 공부하는게 좋을 것 같은데.

Chapter 1 ~ 4 대충 읽기 완료

나중에 시간날때 다시 보자. 근데 읽히지가 않는다.

---

### Chapter 9 - 클라이언트와의 대화 1 : 쿠키

서버는 쿠키를 이용하여 웹 브라우저에 정보 전송 가능.
웹서버로부터 쿠키를 전송받은 웹 브라우저는 이후 웹 서버에 요청을 보낼때 쿠키와 함께 전송함.
이를 사용하면, 웹 서버와 웹 브라우저는 필요한 값을 공유하고 상태를 유지할 수 있음 (stateful)

쿠키는 웹브라우저가 저장하는 데이터.
쿠키는 웹서버, 웹브라우저가 모두 생성할 수 있음.

#### JSP 프로그래밍에서의 쿠키 동작 방식

##### 쿠키 생성

JSP 에서는 웹서버 측에서 생성. 생성한 쿠키를 응답 데이터의 헤더에 저장해서 웹 브라우저에 전송

##### 쿠키 저장

웹브라우저는 받은 쿠키를 쿠키 저장소에 보관.
쿠키 종류에 따라 메모리나 파일에 저장.

##### 쿠키 전송

웹 브라우저는 저장한 쿠키를 요청이 있을때마다 웹 서버에 전송
(해당 쿠키를 생성한 도메인)
웹 서버는 웹 브라우저가 전송한 쿠키를 사용해서 필요한 작업을 수행함.

##### 쿠키의 기본 동작 흐름

**1. 최초 요청 (Initial Request)**

- 웹 브라우저는 처음에 쿠키를 가지고 있지 않습니다
- 서버에 첫 번째 request를 보냅니다[](https://blog.naver.com/with_msip/222960897375)​
    

**2. 서버 응답 (Server Response with Set-Cookie)**

- 서버는 HTTP response의 `Set-Cookie` header에 쿠키를 포함시켜 보냅니다[](https://www.browserstack.com/guide/cookie-header)​
- 예: `Set-Cookie: sessionId=abc123; Domain=example.com; Path=/`

**3. 브라우저의 쿠키 저장**

- 브라우저는 `Set-Cookie` header를 받으면 해당 쿠키를 저장합니다[](https://hudi.blog/cookie-and-session/)​

**4. 이후 요청 (Subsequent Requests)**

- 동일한 도메인에 대한 이후 요청에서, 브라우저는 자동으로 저장된 쿠키를 `Cookie` header에 포함시켜 전송합니다[](https://httpwg.org/specs/rfc6265.html)​    
- 예: `Cookie: sessionId=abc123`

---

웹브라우저에 쿠키가 저장되면, 삭제될때까지 웹 서버에 쿠키를 전송함.
웹 어플리케이션을 사용하는 동안 지속적으로 유지해야 하는 정보는 쿠키를 이용하면 됨.


#### 쿠키의 구성

이름 - 쿠키를 구분
값 - 쿠키의 이름과 관련된 값
유효시간 - 유지 시간
도메인 - 쿠키를 전송할 도메인
경로 - 쿠키를 전송할 요청 경로

브라우저는 유효시간이 지난 쿠키를 자동으로 삭제한다.
별도 유효시간을 설정하지 않으면 웹 브라우저 종료시 쿠키도 함께 삭제함.

또한 지정한 도메인이나 경로로만 쿠키를 전송하도록 제한할 수도 있음.

#### 쿠키 변경

쿠키 생성할떄랑 똑같은 문법.
그래서 쿠키가 존재하는지부터 판단.


#### 쿠키의 도메인

기본적으로 쿠키는 그 쿠키를 생성한 서버에만 전송이 됨. (도메인을 설정 안했을때)
다른 사이트로 연결할때는 전송되지 않고, 생성한 서버에 연결할때만 전송됨.

하지만 같은 도메인 (웹사이트를 기억하기 쉽게 만드는 대표주소, url 은 프로토콜, 경로, 파라미터 등 모든 정보를 다 담은 문자열) 을 
사용하는 모든 서버에 쿠키를 보내야 할 때가 있음.

예를 들어, `www.somehosst.com` 서버에서 생성한 쿠키를 `mail.somehost.com` 서버와
`javacan.somehost.com` 서버에 전송해야 할 때가 있음. 이럴떄 setDomain 메서드를 사용함.

setDomain 으로는 현재 서버의 도메인 및 상위 도메인만 전달 가능.
`mail.somehost.com` -> `.somehost.com`은 가능, `www.somehost.com` 은 불가능.

![[Screenshot 2025-10-18 at 7.46.55 PM.png|700]]

쿠키는 웹 서버의 도메인과 관련된 쿠키만 저장한다.
그러니까 위에 jsp 파일 결과처럼 
브라우저에서 실행되었을때 다른 도메인에 대한 쿠키를 저장한다는 요청을 서버로부터 받아도, 
실제로 브라우저는 javacan.tistory.com 에 대한 쿠키는 저장하지 않는다는 얘기.


##### 웹 브라우저가 타 도메인의 쿠키를 받지 않는 이유

보안문제.
예를들어 A 도메인의 서버가 x 라는 쿠키를 가지고 웹페이지 접근을 허용한다고 가정해보자.
이때 임의의 다른 서버 B 에서 해당 쿠키를 수정할 수 있다면, 다른 서버 B 가 서버 A 의 접속 권한을 조작할 수 있게 되는 것이다.

웹 브라우저는 쿠키의 도메인에 따라 쿠키를 서버에 전송한다.

쿠키의 도메인이 .somehost.com 이라 설정되어 있는경우, .somehost.com 에 속해있는 도메인 서버에
모두 쿠키를 전송함. (javacan.somehost.com, `www.somehost.com` 둘 다) .

별도 도메인 설정을 하지 않은 쿠키의 경우 해당 쿠키를 생성한 서버로만 전달됨.

그리고 쿠키는 언제나 다른 도메인에 대한 서버에는 쿠키가 전송이 안된다.


JSESSIONID - jsp/servlet 에서 세션관리를 위해 사용됨.


#### 쿠키의 경로

도메인 -> 쿠키를 공유할 도메인 범위를 지정
경로 -> 쿠키를 공유할 기준 경로를 설정 (?)

setPath() 를 통해 쿠키의 경로 설정
> `http://localhost:8080/chap09/path2/viewCookies.jsp`

위 URL 에서는 `/`, `/chap09`, `/chap09/path2` 등을 쿠키 경로로 사용할 수 있음.

위 메서드를 이용해 쿠키의 경로를 설정하면, 웹브라우저는 지정한 경로 또는 그 하위 경로에 대해서만 쿠키를 전송함.

그래서 예를들어 어떤 쿠키 'myCookie = value1' 에 대한 쿠키의 경로를 `/chap09`로 설정하면,
URL 에 `/chop09` 또는 `chap09/path2` 등 해당 경로 및 그 하위 경로에 request 를 보낼때 쿠키를 전송함.

쿠키에 경로를 설정하지 않으면 실행한 URL 의 경로부분을 사용함.


#### 쿠키의 유효시간

쿠키는 유효시간을 가지며, 유효시간을 설정하지 않으면 웹 브라우저 종료시 쿠키를 함께 삭제함
-> 

##### Session Cookie vs Persistent Cookie

쿠키의 유효시간에 따라 두 가지 타입으로 나뉩니다:

**1. Session Cookie (세션 쿠키)**

- `Expires`나 `Max-Age` 속성이 **없는** 쿠키입니다[](https://captaincompliance.com/education/session-cookies-vs-persistent-cookies/)​
- 브라우저가 종료되면 자동으로 삭제됩니다[](https://www.cookielawinfo.com/session-cookies-vs-persistent-cookies/)​
- **메모리(cache memory)에만 저장**되고, 하드 디스크에는 저장되지 않습니다[](https://captaincompliance.com/education/session-cookies-vs-persistent-cookies/)​
    

```text
`Set-Cookie: sessionId=38afes7a8`
```

이 예시처럼 유효시간(expiration date/time)을 명시하지 않으면, 브라우저를 닫을 때 쿠키가 삭제됩니다.[](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies)​

**2. Persistent Cookie (영구 쿠키)**

- `Expires` 또는 `Max-Age` 속성이 **있는** 쿠키입니다[](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies)​
- **하드 디스크에 영구적으로 저장**됩니다[](https://captaincompliance.com/education/session-cookies-vs-persistent-cookies/)​
- 유효기간이 만료되거나 사용자가 수동으로 삭제하기 전까지 유지됩니다[](https://www.cookielawinfo.com/session-cookies-vs-persistent-cookies/)​

```text
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT
Set-Cookie: id=a3fWa; Max-Age=2592000
```

##### 쿠키 삭제 주체

**브라우저(Browser)**가 쿠키의 생명주기(lifecycle)를 관리하며, expired된 쿠키를 삭제하는 책임을 가집니다. OS는 이 과정에 관여하지 않습니다.[](https://en.wikipedia.org/wiki/HTTP_cookie)​

##### 삭제되는 시점 (Deletion Timing)

여기서 중요한 포인트가 있습니다. 쿠키가 삭제되는 **정확한 시점**은 브라우저마다 다르며, 실시간으로 즉시 삭제되지 않을 수 있습니다:[](https://connect.mozilla.org/t5/ideas/deleting-of-expired-cookies/idi-p/63379)​

**1. 쿠키가 만료되었을 때**

- `Expires` 날짜가 지났거나 `Max-Age`가 0 이하가 되면 쿠키는 "만료(expired)" 상태가 됩니다[](https://en.wikipedia.org/wiki/HTTP_cookie)​
- 하지만 **파일 시스템에서 즉시 삭제되지 않을 수 있습니다**[](https://learn.microsoft.com/en-us/answers/questions/2114084/cookies-that-have-expired-are-not-deleted)​
    

**2. 실제 삭제 시점**

- **요청 시점 (Request Time)**: 브라우저가 다음 HTTP request를 보낼 때, 만료된 쿠키는 전송하지 않습니다[](https://syrenis.com/resources/blog/understanding-cookie-consent-expirations/)​
- **유휴 시간 (Idle Time)**: Chrome은 idle time에 만료된 쿠키를 정리합니다[](https://connect.mozilla.org/t5/ideas/deleting-of-expired-cookies/idi-p/63379)​
- **브라우저마다 다름**:
    
    - Chrome: idle time에 자동으로 expired cookies를 삭제[](https://connect.mozilla.org/t5/ideas/deleting-of-expired-cookies/idi-p/63379)​
    - Firefox: 자동 삭제가 제대로 작동하지 않는 경우가 있음[](https://connect.mozilla.org/t5/ideas/deleting-of-expired-cookies/idi-p/63379)​
    - Edge: 개발자 도구를 열었을 때 삭제되는 경우도 보고됨[](https://learn.microsoft.com/en-us/answers/questions/2114084/cookies-that-have-expired-are-not-deleted)

##### 실제 동작 비교

| 쿠키 타입                 | 저장 위치    | 브라우저 종료 시 | 프로세스 비정상 종료 시 |
| --------------------- | -------- | --------- | ------------- |
| **Session Cookie**    | 메모리(RAM) | 삭제됨       | 삭제 안될 수 있음 ⚠️ |
| **Persistent Cookie** | 하드 디스크   | **유지됨** ✅ | **유지됨** ✅     |



#### 쿠키의 헤더

쿠키를 추가하면 Set-Cookie 헤더를 통해 전달된다.
-> 서버가 쿠키를 생성해서 브라우저에 보낼떄의 이야기.


쿠키는 HTTP 헤더(Header)를 통해 서버와 브라우저 간에 전달됩니다. 여기서 두 가지 다른 헤더가 사용됩니다.[](https://www.browserstack.com/guide/cookie-header)​

#### HTTP 헤더와 쿠키의 관계

HTTP 통신에서 쿠키는 메시지의 본문(body)이 아니라 헤더(header) 영역에 포함됩니다. 헤더는 HTTP 메시지의 메타데이터를 담는 부분으로, 요청이나 응답에 대한 추가 정보를 제공합니다.[](https://stackoverflow.com/questions/3467114/how-are-cookies-passed-in-the-http-protocol)​

##### Set-Cookie 헤더 (Response Header)

서버가 브라우저에게 쿠키를 저장하라고 지시할 때 사용하는 헤더입니다.[](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie)

"The HTTP Set-Cookie response header is used to send a cookie from the server to the user agent, so that the user agent can send it back to the server later."[](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie)​
​
즉, 서버에서 클라이언트(브라우저)로 가는 방향(Server → Client)에서 사용됩니다

```text
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: sessionId=abc123
Set-Cookie: theme=dark; Max-Age=3600
```

##### Cookie 헤더 (Request Header)

브라우저가 이전에 저장한 쿠키를 서버로 다시 보낼 때 사용하는 헤더입니다.[](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie)​

"The Cookie header is an HTTP request header used by browsers to send stored cookies back to the server."[](https://www.browserstack.com/guide/cookie-header)​

즉, 클라이언트(브라우저)에서 서버로 가는 방향(Client → Server)에서 사용됩니다.[](https://www.browserstack.com/guide/cookie-header)​

```text
GET /page HTTP/1.1
Host: example.com
Cookie: sessionId=abc123; theme=dark
```

이 예시에서 브라우저는 HTTP request의 헤더 영역에 Cookie 헤더를 포함시켜 저장된 쿠키들을 서버로 전송합니다.

##### 전체 흐름 예시

RFC 6265에 나온 실제 예시

```text
== Server → User Agent ==
Set-Cookie: SID=31d4d96e407aad42

== User Agent → Server ==
Cookie: SID=31d4d96e407aad42
```

1. 서버가 응답할 때 Set-Cookie 헤더에 쿠키 정보를 담아서 보냅니다
2. 브라우저는 이 헤더를 해석(parse)하여 쿠키를 저장합니다
3. 이후 요청 시, 브라우저는 Cookie 헤더에 저장된 쿠키를 담아서 보냅니다[](https://httpwg.org/specs/rfc6265.html)​

##### 두 헤더의 비교

| 헤더         | 방향              | 역할                   |
| ---------- | --------------- | -------------------- |
| Set-Cookie | Server → Client | 쿠키를 생성하고 브라우저에 저장 지시 |
| Cookie     | Client → Server | 저장된 쿠키를 서버로 전송       |


#### 쿠키를 사용한 로그인 상태 유지

1. 로그인에 성공하면 특정 이름을 갖는 쿠키를 생성
2. 해당 쿠키가 '존재하면' 로그인한 상태라고 상정
3. 로그아웃하면 해당 쿠키를 삭제함


