
## AI 정리
### 멘티님이 앞으로 할 것들

- 2의 보수와 부동 소수점에 대한 이해도를 높인다.
- 해시맵과 해시코드 구현 방식에 대한 심화 공부를 한다.
- 프로그래밍 실력을 키우기 위해 이펙티브 자바를 읽는다.

### 인사이트 정리

- 자바의 싱크로나이즈는 암묵적인 락으로 사용된다.
- 모니터 락은 스레드의 락을 관리하는 중요한 개념이다.
- 스테이틱 필드와 인스턴스 필드는 서로 다른 동기화 전략을 필요로 한다.
- 어레이 리스트의 동기화는 싱크로나이즈 블록 내에서만 안심하고 사용할 수 있다.
- 캐시의 유효시간 설정은 시스템 성능과 직접적으로 연관된다.
- 이해 보수 방식은 부동 소수점 처리를 위한 기초 개념이다.
- 해시맵의 구현 방식은 해시 함수에 대한 깊은 이해를 요구한다.

### 키워드

- 스레드
- 싱크로나이즈
- 모니터 락
- 스테이틱 필드
- 어레이 리스트
- GC 대상
- 부동 소수점
- 2의 보수
- 헤시코드

### 오늘 내용에 맞춰진 질문들

- #### 자바의 모니터 락은 어떻게 작동하며, 스레드와의 관계는 무엇인가?
    
    - 모니터 락이 스레드 안전성을 어떻게 보장하는가?
    - 모니터 락과 세마포어의 차이점은 무엇인가?
    - 스레드 간 경쟁 조건을 피하기 위해 모니터 락이 필수적인 이유는?
    - 모니터 락의 성능 영향을 최소화하는 방법은?
    - 싱크로나이즈 블록 내에서의 모니터 락 동작 방식을 코드 수준에서 설명하라.
- #### 어레이 리스트에 다수의 스레드가 동시에 접근할 때 어떠한 문제가 발생할 수 있는가?
    
    - 멀티 스레드 환경에서의 ArrayList는 어떻게 동작하는가?
    - ArrayList의 스레드 안전성을 높이기 위한 전략은?
    - 동기화가 ArrayList의 성능에 끼치는 영향은?
    - ArrayList 대신 사용할 수 있는 스레드 안전한 컬렉션 클래스는?
    - synchronizedList와 ArrayList의 차이점 및 활용 방법은?

- #### 부동 소수점 연산 시 발생하는 오류는 무엇이며, 이를 어떻게 해결할 수 있는가?
    
    - 부동 소수점의 근본적인 한계는 무엇인가?
    - 플로팅 포인트 아키텍처의 구조를 설명하라.
    - 정밀한 계산이 요구되는 시스템에서 부동 소수점 대신 사용할 수 있는 대안은?
    - 부동 소수점 연산을 정확하게 테스트하기 위한 방법은?
    - IEEE 754 표준이 부동 소수점 연산에 끼친 영향은?

- #### 이해 보수를 사용하는 이유 및 그 작동 원리는 무엇인가?
    
    - 이해 보수와 일의 보수의 근본적인 차이점은?
    - 컴퓨터가 이해 보수를 통해 음수를 표현하는 이유는?
    - 이해 보수가 계산에서 제공하는 장점은 무엇인가?
    - 이해 보수의 활용 사례를 예를 들어 설명하라.
    - 컴퓨터 아키텍처에서 이해 보수 연산이 중요한 이유는 무엇인가?

- #### 자바의 해시 코드와 관련한 해시맵의 내부 구현 원리는?
    
    - 햏코드 충돌을 해결하기 위한 JDK의 해시맵 전략은?
    - 해시맵의 성능 최적화를 위한 데이터 구조는 무엇인가?
    - 해시맵에 영향을 끼치는 해시 함수의 설계 전략은?
    - 해시맵 내부에서 해시 코드가 어떻게 사용되는가?
    - JDK에서 해시맵과 관련된 성능 이슈를 해결한 사례는 무엇인가?

## 멘토링 정리

#### synchronize 블록 안에 어떤 객체를 넣을 수 있다가 무슨의미일까

-> 그냥 블록안에 어떤 변수를 넣어서 사용한다는 의미이다.

#### this 를 넣으면 어떻게 어떤 기준으로 동작을 할까 ?


스레드는 어떠한 객체를 기준으로 보냐면, 하나만 생성되어 있는 스테이트 필드면 하나만 기준으로 놓고
그걸 기준으로 쭉 줄을 세우게 될 것. (스레드의 줄) 

인스턴스가 this 로 들어가게 된다고 하면, 인스턴스가 n 개가 있을 것. 
-> 즉 쓰레드마다 자기 스스로 this 를 호출하고 이 this 는 결국 객체 인스턴스 자신 (쓰레드 자신) 이다. 그러니 static field 보다 훨씬 더 자주 크리티컬 섹션에 접근할 것.
-> 하지만 static field 가 그 안에 들어갈 경우, 많은 스레드들이 그 변수에 모니터락을 얻으면서 접근하기 때문이 시간이 훨씬 더 걸릴 것.

#### synchronize 블록 안에 클래스 변수 (static field) 가 들어갔다. 어떤 일이 벌어질까 ?

위에서 나온 내용.


#### static 은, JVL 에서 클래스 파일이 로딩될때 스태틱 변수, 메소드들이 메모리에 올라온다 -> 메모리라고 하면 좀 부족하다.

-> 그렇다면 왜 부족할까 ?


#### 인스턴스, 그리고 static 은 JVM 에서 몇개 생성되는가

-> 인스턴스는 생성하는데로. static은 딱 1개.



#### 메모리와 하드디스크의 차이점은 ?


#### 만약 static field 를 여러 쓰레드에서 계속 사용하게 된다면

-> out of memory 발생.

-> method 안에 생성된 객체들은 GC 대상이 되지만, 
static field 는 gc 대상이 아니므로, 저장공간에 대한 염려를 항상 해야 한다. 무수히 많은 시간이 일어났을때를 예측해야 한다.

static field 는 JVM 전체 안에서 모든 스레드나 객체가 바라볼 수 있기 때문에, static field 는 GC 대상이 아니게 된다.


#### 자바의 쓰레드는 OS 의 kernel 을 사용한다.



#### 세마포어와 Mutex

는 각각 무엇인가 ?


#### Synchronize 는 암묵적 lock 이라고 한다. 그럼 명시적 lock 은 무엇이 있을까 ?


#### '상태란 무엇일까' 라는 질문 -> 대상 한정화

-> 멘토님이 유도하신 질문.
이러한 질문에 대해서는, '무엇에 관한 상태인가 ?' '프로세스의 상태를 말하는 것이냐'

이렇게 질문이 포괄적이면 대상을 한정짓는게 인터뷰에서, 그리고 개발자에게 굉장히 좋은 스킬이다.

내가 무엇을 대답해야 되느냐라는 범위를 특정하는 것.



#### 상태 -> Stateful API

##### what is the State ?


##### what is the stateful api ?

무엇을 저장하고, 무엇을 보내고.
그러면 그 무엇이 뭘까 ?

회원정보를 불러오는 API 가 있다. 예를들어 가입한 사람의 이름, 패스워드 등을 불러오는.
이러한 api 는 로그인 후에야 값이 반환되어야 할 것이다.


- scale out & scale in, load balancing

load balancer 는 유저의 reqeust 들을 여러개의 서버에 나눠주는 역할
-> 그렇다면, 한 유저의 첫번째 request 와 두번째 request 는 서로 다른 서버가 처리하게 될 수 있다.
-> 그렇게 되면, request 에 인증정보를 담아야 이 request 에 민감한 정보를 return 해줄지 말지를 결정할 수 있다.

-> 즉, 이 요청이 로그인 이후에 들어온 요청이다라는 것을 어느 서버도 중요하게 생각하지 않아야 한다.

-> 이 stateless 한게 중요해진 이유는, 요새는 scale out & scale in 방식을 서버에서 많이 사용한다
-> AWS 와 같은 클라우드 서비스에서 제공하는 기능. 
-> 상시에 30대의 모두 가동하는 것이 아니라, 트래픽이 폭팔적으로 늘어날때만 서버의 수를 늘림 -> scale out

> 참고로 scale out vs scale up 이라는 질문도 있다.

이런 세상이다 보니 Restful API 가 너무 중요해진 것. 
옛날에는 로그인했다라는 걸 알고있었는데 지금은 서버가 모름.
이러다 보니 JWT 라는 것도 나오게 됨.
사실 JWT 가 아니어도 세션과 쿠키로 이미 어느정도 처리가 가능.

따라서, '상태' 란 무엇인가를 알아야 내가 무슨 API 를 만들고 있는 거구나라는 것을 알 수가 있다.



#### Redis 가 무얼 하는 것인가 ?



#### 캐싱이란 ?


#### 캐싱된 정보와 하드디스크의 정보의 불일치는 어떻게 해결할 것인가 ?


#### 캐싱 사용패턴 3가지


#### Primitive Type, reference Type 이 저장되는 공간은 어디인가 ?


#### 자바에서, stack 에는 뭐가들어가고 heap 에는 뭐가 들어가는가 ?


#### 상황별 data passing 속도

``` 
- L1 cache reference 0.5 ns 
- Branch mispredict 5 ns 
- L2 cache reference 7 ns 
- Mutex lock/unlock 100 ns 
- Main memory reference 100 ns 
- Compress 1K bytes with Zippy 10,000 ns 
- Send 2K bytes over 1 Gbps network 20,000 ns 
- Read 1 MB sequentially from memory 250,000 ns 
- Round trip within same datacenter 500,000 ns 
- Disk seek 10,000,000 ns 
- Read 1 MB sequentially from network 10,000,000 ns 
- Read 1 MB sequentially from disk 30,000,000 ns 
- Send packet CA->Netherlands->CA 150,000,000 ns
```



#### Cache 에는 Expired Time 이 있다.

만료 시간을 24 시간 이렇게 가져갈 수도 있지만, 어떤 곳은 1초씩만 유지하기도 함.
-> 1초 안에 동일한 요청이 두 세번 올수 있다라고도 보기 때문에 1초만 캐싱해도 디스크에 굉장한 이득을 볼 수 있다.

AWS 를 쓰다보면 비용이 제일 무시무시한 일이 된다.
RDB 같은 디스크를 쓰는 데이터스토어는 
(RDB ?) 데이터 스토어랑 레디스 캐시같은 메모리 데이터 스토어의 가격을 비교해보면 디스크가 압도적으로 저렴함.


#### List\<Integer> arr <- 이 arr 에 null 을 add 할 수 있을까 ?

Integer 에도 null 을 대입할 수 있으니 가능할 것 같다.

-> 확인 필요.

#### 디스크와 메모리의 차이점은 ?

디스크는 영구저장, 메모리는 휘발성
디스크는 access 속도가 메모리에 비해 느리다.

-> 그렇다면 느린 이유는 ?
메모리는 랜덤엑세스이고, 디스크는 데이터를 찾기 위해 실린더가 물리적으로 돌아가기 때문.

-> 메모리가 random access 라는 부분에 대해서 더 공부해야 할듯.

#### random access 는 무엇이며, 그 와 비교될 다른것은 ?



#### hashCode -> 왜 31 일까 ?

```java
public class User {  
  
    private String name;  
    private String address;  
    private String email;  
  
  
    @Override  
    public boolean equals(Object o) {  
        if (o == null || getClass() != o.getClass()) return false;  
  
        User user = (User) o;  
        return Objects.equals(name, user.name) && Objects.equals(address, user.address) && Objects.equals(email, user.email);  
    }  
  
    @Override  
    public int hashCode() {  
        int result = Objects.hashCode(name);  
        result = 31 * result + Objects.hashCode(address);  
        result = 31 * result + Objects.hashCode(email);  
        return result;  
    }  
}
```

거기에 31이라는 숫자가 나온다.
왜 '31' 일까 ?

힌트 -> 31 = 11111

---

그리고 String 의 hashCode 를 처리할때, String 의 COMPACT_STRINGS 가 UTF16 일 경우 
(문자열 압축이 설정되어 있지 않으면, 문자열은 기본적으로 UTF16 으로 인코딩됨.)

String.hashCode -> StringUTF16.hashCode 
-> ArraySupport.hashCodeOfUTF16 
```java
public static int hashCodeOfUTF16(byte[] a, int fromIndex, int length, int initialValue) {  
    return switch (length) {  
        case 0 -> initialValue;  
        case 1 -> 31 * initialValue + JLA.getUTF16Char(a, fromIndex);  
        default -> vectorizedHashCode(a, fromIndex, length, initialValue, T_CHAR);  
    };  
}
```

-> ArraySupport.vectorizedHashCode (이때 basicType은 T_CHAR 로 넘어간다. 문자열이라 그런듯.)

-> ArraySupport.utf16hashCode
```java
private static int utf16hashCode(int result, byte[] value, int fromIndex, int length) {  
    int end = fromIndex + length;  
    for (int i = fromIndex; i < end; i++) {  
        result = 31 * result + JLA.getUTF16Char(value, i);  
    }  
    return result;  
}
```

즉 여기서 31이 나온다.

왜 31이지? 이걸 어떻게 검색해야 나올까 ?


#### 2의 보수 이해 -> 부동 소수점 이해

0.9999 = 1 이 되는 이슈들을 해결하지 못하면 난리가 남.
돈과 관련된건 무조건 BigDecimal 을 써야 하는 이유.

1의 보수도 있는데 왜 2의 보수를 사용하는가 ?


2의 보수를 위한 멘토님 블로그 글 참조.

[https://blog.yevgnenll.me/posts/why-computer-use-twos-complements-calculate-minus](https://blog.yevgnenll.me/posts/why-computer-use-twos-complements-calculate-minus)

