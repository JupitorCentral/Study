# 질문해결

## 메모리와 하드디스크의 차이점

일단 속도. 메모리는 빠르고, 하드디스크는 빠르다.
메모리는 random access, 하드 디스크는 실린더.

메모리는 휘발성, 하드디스크는 비휘발성

### 메모리가 데이터를 찾는 방법

Computer Organization and Design David A. Patterson - 5.2 Memory Technologies

상용컴퓨터의 메모리에는 DRAM 이 보통 쓰이므로 이에 대해 알아보자면
SRAM 은 하나의 비트에 대한 간섭을 막기위해 여러개의 트랜지스터를 사용, 전력이 공급만 되기만 한다면 데이터를 무한정 유지 가능.

“In a dynamic RAM (DRAM), the value kept in a cell is stored as a charge in a capacitor. 
A single transistor is then used to access this stored charge, either to read the value or to overwrite the charge stored there”

- Capacitor -> 전기 에너지를 저장하는 소자
- Charger -> 전기적 충전 상태. 전하가 있으면 1, 없으면 0 을 나타냄
- Cell -> 하나의 비트를 저장하는 기본 단위. DRAM 의 cell 은 하나의 트랜지스터, 1개의 커패시터로 구성되어있어 1T1C 구조라고 부름

cell 에 저장되는 값은 capacitor 의 charge 로써 저장됨
-> capacitor 가 charged 되어 있으면, 1을 나타내는 것이고, 이를 transistor 를 통해 접근 및 변경함.

하나의 트렌지스터 -> cell 을 더 빽빽하게 둘 수 있음

정보가 capacitor 의 charge 로 저장되기 때문에, 정보가 무한정 저장될 순 없고 주기적으로 refreshed 되어야 함.
(그래서 SRAM 은 static storage 라고 함.)

(내용이 무관하다. ㅠㅠ;)

----------------

- RAM uses an **address decoder circuit**. When the CPU provides an address, this decoder instantly selects the _one_ memory cell (or row/column of cells) that matches, allowing data to be read or written directly, without any search or waiting. All cells are ready to be selected in parallel; the electric signal chooses the desired one immediately by design.
    
- “Access time is the same for all data” in RAM because this process is electronic and parallel—there’s no physical motion or scanning needed. By contrast, hard drives have to physically move a read/write head to the correct place.
    

So: Yes, all cells are linked through circuits, and if the address is known, RAM hardware can extract the information from that cell without delay, which is why random access is possible at constant speed.


![[Screenshot 2025-09-14 at 12.16.35 AM.png|600]]


#### **How to read this:**

- **CPU** puts an address (e.g., 101) on the address lines (`A2`, `A1`, `A0`).
- The **Decoder** reads the address and activates only one line, say `[M5]`, going to memory cell 5.
- **Only** the chosen memory cell connects its value to the **Data Line** going back to the CPU.
- The CPU reads or writes data using that single line.

컴퓨터 아키텍쳐가 64비트면 한번에 64비트씩 엄청나게 빠른속도로 데이터를 읽음.
하나의 주소가 연속된 64비트를 한꺼번에 읽어들임.


### 디스크가 데이터를 찾는 방법


cpu 가 주소를 요청 -> 디스크 컨트롤러가 논리주소를 디스크 플래터의 트랙과 섹터로 바꿈
-> 디스크에 회전하는 플래터가 해당하는 트랙으로 이동
-> 원판이 돌면서 원하는 섹터가 헤드 아래로 오기를 기다림
-> 위치에 오면 헤드가 자기 신호를 감지해서 데이터를 전기신호로 변환 -> 컨트롤러 -> CPU 전송

즉 물리적으로 찾기때문에 속도가 떨어질 수 밖에 없음.


# 자바의 신 2권

## java.lang package - 어제에 이어서


### Classes related to System information

-> System 클래스

#### err, in, out

```java
System.out.println(" ");
```

out -> static PrintStream
따라서 println 은 PrintStream 의 static method

#### Properties

출력을 위한 부분은 out, error 에 선언된 PrintStream에 다 선언
System 클래스 자체에는 시스템의 정보를 확인하는 메소드들이 있음.

> 절대로 실행해서는 안되는 메소드
> GC 수행, JVM 종료


- System.clearProperty, getProperty, setProperty (setProperties)

-> "Properties" -> extends Hashtable -> Key & Map

#### Environment value

Systen.getenv

#### GC

System.gc -> GC 를 수행

System.runFinalization -> GC 처리를 기다리는 모든 객체에 대하여 finalize() 를 실행

> java 9 버전부터 Object.finalize 메소드는 Deprecated 되었음.

##### Object.finalize

-> GC에 의해 호출됨.
-> GC 가 판단하기에, 어떤 객체가 어느 무엇에게도 참조되지 않으면, GC 가 이 객체의 finalize 를 호출함.


```java
// portion of explanation of finalize
* The general contract of {@code finalize} is that it is invoked  
* if and when the Java virtual  
* machine has determined that there is no longer any  
* means by which this object can be accessed by any thread that has  
* not yet died, except as a result of an action taken by the  
* finalization of some other object or class which is ready to be  
* finalized.
  
```

contract : 약속
-> finalze 는 일반적으로, ~~ 일때 일어난다.

==there is no longer any means by which this object can be accessed by any thread==

This object can be accessed ==by the mean== by any thread
-> 이 객체는 어떠한 쓰레드에 대해서 그 수단에 의해 접근 될 수 있다.

by means 가 선행사로 빠지고, by which 가 관계대명사로
- There is no longer any means 와
- This object can be anccessed by any means by any thread 를 이어줌.

==except as a result of an action taken by the finalization of some other object or class which is ready to be finalizaed==

- object or class which is ready to be finalized
-> finalized 되기에 준비된 객체나 클래스

- an action taken by finalization of some other object or class
-> 어떤 다른 객체나 클래스의 finalization 에 의해 일어나는 (하나의) 동작

-  except as a result of an action
한 동작의 결과로써를 제외하고 
-> 말이 좀 이상한데,, '수단' 이 생략된 것이다.

- 왜 except results of an action 이 아니라 as a result of 인가 ?
as a result of -> ~의 결과로써, ~때문에 -> 인과관계 / 원인을 강조
results of -> ~의 결과들 -> 구체적인 결과물, 산출물

as a result of 는 부사구라 except 뒤에 홀로 오는게 말이 안되지 않나 ?

-> 그게  아니라, except as a result of 는 'except means as a result of' 에서 'means' 가 생략된 것.
by which this object ~~ 와 병렬로
except 문이 있다고 생각하면 됨.

- 왜 'if' 로만 쓰지 않고 'if and when' 인가 ?
if -> 사건 자체가 언제 일어날지 모름. 불확실함.
if and when -> 사건 자체가 분명 일어나긴 일어날텐데, 언제인지는 모름.

따라서, 저 말의 의미는

> 어떠한 객체나 클래스의 finalization 에 의해 생겨난 수단/방법을 제외하고는, 
> 살아있는 어떠한 스레드인지 간에 어떠한 방법으로든 해당 객체에 접근할 방법이 없을때 (분명 일어날 것이긴 하지만 언제인지 모름)
> 해당 객체의 Object.finalize 가 invoke 되는 것을 약속으로 한다.

는 의미임.

-> 그렇다는 것은 어떠한 객체나 클래스가 finalized 될때 다른 객체, 클래스에 접근하는 일이 생긴다는 얘기인가 ?
-> Yes.


#### 시간

currentTimeMills  -> 현재 시간 밀리초
nanoTime -> 현재 시간 나노초

실행 시간의 측정을 위해서는 nanoTime 을 추천


#### PrintStream Class

-> System.out, System.err 의 차이는 정상적인 출력인지, 에러일때 출력인지만 구분


```java
Object nullObj = null;  
System.out.println(nullObj);  
System.out.println(nullObj + " is null");
-------
> Task :Main.main()
null
null is null
```

-> println 에 들어가는 객체에 대해서 toString() 을 println 이 자동호출하기 때문에
null.toString() 은 말이 안되므로 런타임 오류가 나지 않나? 라고 생각할 수 있으나
println 의 동작은 단순히 파라미터의 toString 을 호출하는 것이 아니다.

-> String.valueOf() 를 사용해서 출력함.
-> 객체의 문자열을 나타낼때, toString 보다는 String.valueOf 가 더 안전하다는 의미이기도 함



## Generic

^45e137

실수를 방지하기 위해 ?

### explicit casting and generic

```java
static class TestDTO {  
    Object obj;  
  
    public Object getObj() {  
        return obj;  
    }  
  
    public void setObj(Object obj) {  
        this.obj = obj;  
    }  
}  
  
public static void main(String[] args) throws Exception {  
    TestDTO t1 = new TestDTO();  
    t1.setObj(new String());  
  
    TestDTO t2 = new TestDTO();  
    t2.setObj(new StringBuilder());  
  
    String o1 = (String) t1.getObj();  
    StringBuilder o2 = (StringBuilder) t2.getObj();  
  
    TestObjWithGeneric<String> g1 = new TestObjWithGeneric<String>();  
    g1.setObj(new String());  
  
    TestObjWithGeneric<StringBuilder> g2 = new TestObjWithGeneric<>();  
    g2.setObj(new StringBuilder());  
  
    String go1 = g1.getObj();  
    StringBuilder go2 = g2.getObj();  
}  
  
static class TestObjWithGeneric <T> {  
    T obj;  
  
    public T getObj() {  
        return obj;  
    }  
  
    public void setObj(T obj) {  
        this.obj = obj;  
    }  
}
```

-> Generic 을 쓰면, 명시적 형변환이 필요없어진다.
-> 그리고 실수도 덜하게 될 것.

### naming

자바가 정한 기본적인 제너릭 네이밍 규칙
E : 요소 (element)
K : key
N : number
T : type
S, U, V : 두번쨰, 세번째, 네번째 선언된 타입
V : value

### ? - wild card

(참고로 ?는 영어로 question mark, ! 은 exclamation point 이다)

```java
static class MyGeneric <T> {  
    T obj;  
  
    public T getObj() {  
        return obj;  
    }  
  
    public void setObj(T obj) {  
        this.obj = obj;  
    }  
}  
  
public static void main(String[] args) throws Exception {  
    MyGeneric<String> stringObj = new MyGeneric<>();  
    stringObj.setObj("stringObj");  
    methodOfStringClass(stringObj);  
  
    MyGeneric<Integer> obj = new MyGeneric<>();  
    obj.setObj( 3 );
    methodOfClass(obj);  
    methodOfClass2(obj);
    
    MyGeneric<String> obj2 = new MyGeneric<>();  
    obj2.setObj("String");  
  
    methodOfClass(obj2);  
    methodOfClass2(obj2);  
      
    methodOfStringClass(obj);   // ERROR   
}  
  
public static void methodOfStringClass(MyGeneric<String> target) {  
    println(target.getObj());  
}  
  
public static <T> void methodOfClass(MyGeneric<T> target) {  
    Object obj = target.getObj();  
    println(obj);  
}  
  
public static void methodOfClass2(MyGeneric<?> target) {  
    Object obj = target.getObj();  
    println(obj);  
}
```

책에서는 methodOfStringClass 가 String 으로 정의된 Generic 타입만 사용할 수 있으므로
다른 타입을 매개변수로 사용하려면
wildCard 를 사용해야 한다고 하는데

근데 method 에 Generic을 써도 되는거 아닌가 ??
왜 wildCard 를 굳이 써야 하는거지 ?


### Bounded Wildcards

```java
public static <T> void methodOfClass(MyGeneric<T extends Object> target) {  
    Object obj = target.getObj();  
    println(obj);  
}
-------->>> 이건 안된다

public static <T> void methodOfClass(MyGeneric<? extends Object> target) {  
    Object obj = target.getObj();  
    println(obj);  
}
---------->>> 얘는 된다

class MyGeneric2 <T> {
	
}

public static <T> void methodOfClass(MyGeneric2<? extends Car> target) {  
    Object obj = target.getObj();  
    println(obj);  
}
------------>>> Car 를 상속받은 제너릭한 클래스인 경우에만 Parameter 로 올 수 있음
```

즉 Bounded Generic 은 말이 안됨.

이때 \<extends Car> 라고 했을때, MyGeneric2 의 제너릭 타입은 Car 그 자체여도 상관이 없다.
(target 의 타입이 MyGeneric\<Car> 이어도 상관 없다는 얘기)




### Generic Method

앞선 와일드 카드 메서드에서는 값을 추가할 수 없다. 뭔얘기냐.

```java
public static void setObjOfClass2 (MyGeneric<?> target, ? value) {  
    target.setObj(value);  
    println(target.getObj());  
}   ------>>> 말이 안되므로 컴파일 안됌


public static <T> void setObjOfClass (MyGeneric<T> target, T value) {  
    target.setObj(value);  
    println(target.getObj());  
}   
-------->>> 얘는 가능
```

위 함수처럼 쓰기가 안된다는 얘기이다. -> 다른 매개변수로 해당 target 의 값을 변경할 수가 없음.
그래서 아래처럼 사용한다는 애기.



