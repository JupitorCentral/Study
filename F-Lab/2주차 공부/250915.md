

## Primitive Type, reference Type 이 저장되는 공간은 어디인가 ?

자바에는 이미 정의된 primitive 타입이 있다.  로우케이스.
얘네들의 wrapper 클래스는 capital letter로 시작, 그리고 API 에 정의된 Class 이므로 Method 가 있음.

### Primitive on the stak and heap

==Primitive Type 은 스택 또는 힙에 저장 될 수 있다.== 

local variable, paramter 일 경우 stack 에 저장됨.
member of class 의 경우 (instance variable), instance 가 생성되면서 'heap' 에 저장됨.

-> 그럼 class variable 은 ?

### Storing object on the heap

#### Reference

reference 는 객체를 가리키고, 우리가 그 객체에 접근할 수 있게 해줌. (여기서 reference 라는 특정 개념이 나오는 듯 하다)
우리가 object instance member (instance variable) 에 접근할때, 우리는 'reference' 를 사용한다.

만약 우리가 static variable 에 접근하면, 우리는 class name 을 사용 (reference 를 사용하지 않는다는 것으로 보임)

reference 는 스택과 힙에 저장.
스택 -> reference 가 local variable 일 경우
heap -> instance variable (variable inside a class) 일 경우 heap

(heap 은 동적 생산이 일때 사용되는 공간이 맞는 것 같다.)

##### reference to others 

abstract class 에 대해 reference 를 가질 수 있음 (abstract class 가 아니라. 근데 애초에 abstract class 가 객체를 가질 수 없잖아)
interface 도 마찬가지.


#### Objects

모든 객체는 'heap' 에 저장된다.
객체를 이해하려면 OOP 의 근간이 되는 이론을 알아야 함.
class 는 집의 설계도. 집이 만들어지면, 그제서야 문을 열고 창문을 닫을 수 있음.

객체가 생성되면, in-memory representation of the class 를 갖게되는 것.
reference 를 이용해서, 우린 instance members 에 접근 할 수 있음 (dot notation syntax)



#### Difference between references and objects

![[Screenshot 2025-09-15 at 12.33.50 AM.png|700]]

```java
class Person {  
    private String name;  
    private int age;  
  
    Person (String name, int age) {  
        this.name = name;  
        this.age = age;  
    }  
  
    @Override  
    public String toString() {  
        String decoratedName = "My Name is " + name + " and I am " + age + " years old";  
        return decoratedName;  
    }  
  
    public void setName (String name) {  
        this.name = name;  
    }  
}  
  
public static void main(String[] args) throws Exception {  
    Main mainObj = new Main();  
    int x = 0;  
    Person joeBloggs = mainObj.new Person ("Joe Bloggs", 23);  
    System.out.println(x);  
    System.out.println(joeBloggs.toString());  
    changeName(joeBloggs, "John");
}  
  
public static void changeName (Person person, String newName) {  
    person.setName(newName);  
}
```

이 코드를 실행하는 method 에 대해서, 
첫번째 main () method 가 있고, main () 함수를 위한 frame 을 스택에 쌓게 됨.
그리고 그 프레임안에 main method 의 local variable, parameter 가 생성됨.
이때 new 로 생성된 Person 객체에 대한 reference joeBloggs 도 main 안에 생기게 됨 (local variable 로써)

String Pool 도 Heap 공간에 저장되고, 어떤 새로운 내용을 가진 String Object 가 생기면 거기에 저장해두었다가
나중에 객체를 재사용함. 
그러니까.
```java
String s1 = "My name is Joe Bloggs";        ->> "My name is Joe Bloggs" 라는 String 객체가 String pool 에 생성
String s2 = "My name is Joe Bloggs";         --->> String Pool 에 있던 객체 그대로 씀
```

그러니까 s1, s2 는 reference 이고, "My name is Joe Bloggs" 얘는 "My name is Joe Bloggs" 라는 값을 가지는 String 객체라는 것.
("My name is Joe Bloggs" 같은건 String literal 이라고 한다.)

println method 가 콜 될때, 그를 위한 Frame 이 stack  에 push 됨.
println 실행이 끝나기 전에, joeBloggs.toString() 이 반드시 호출되어야 한다 (-> frame 이 생성됨)

그러니까, 먼저 System.out.println(x);  에 의해서 println 에 대한 frame 생성
그 다음줄에서 toString method 를 위한 프레임 생성 이런 흐름인듯.

이게 헷갈릴 수 있는게, 참 웃긴게 
joeBloggs.toString() 이 실행될때 toString() 에 대한 frame 이 stack 에 쌓이면서
toString() 의 local variable 인 reference decoratedName 이 생성되고, 
String literal 은 Heap 에 생성된다는 것이다.

타이밍은 내가 생각했을땐, toString 에 대한 method 를 위한 frame 이 생성될때 그 메서드 안에 쓰이는 
String literal 들이 String pool 에 생성될 듯.


그래서 class 에 대한 객체가 생성될때 reference 는 객체를 참조하고,
이 reference 가 함수의 parameter 로 넘어갈때 결국 이 reference 자체가 넘어가는 것이 아니라
reference 의 '값' 이 넘어가기 때문에 그리고 이 참조값은 이전에 생성했던 
new Person ("Joe Bloggs", 23);  -> 이 객체이기 때문에
changeName 에서 person 이 new Person ("Joe Bloggs", 23); 객체를 가리키게 되는 것.

결국 참조에 대한 call by value 가 되면서 call by reference 처럼 보이게 되는 것 -> 이거 사람들 사이에 의견이 분분한 것으로 알고 있다.
근데 메모리 관점에서 보면, call by value 가 일단 맞는 듯 하다. 이런 관점에서 보면.

그러니까, changeName executed -> frame for changeName created to stack 
-> person reference created inside that frame
-> call by value, so value related to new Person instance is copied to person local variable (reference) inside that frame.

그러니까 결국 포인터 개념이 맞네. cpp 처럼.

이 이후는 좀 내용이 너무 많아서 pass 하자.

-> 결국 reference 를 잘 다루어야 한다는 얘기.




## Static Field 는 클래스가 memory 에 loading 될때 저장되는데, 이에 대한 더 정확한 설명


at Java Memory Management by van Putten, Maaike (2022), Chapter 5
### Zooming in on the Metaspace


