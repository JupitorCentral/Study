

# 질문해결


## Semaphores and Mutex

### Definition of Semaphore

-> Hardware-based 하게 critical section problem 을 해결하는 것은 application programmers 한테는 사용하기 너무 어려움
-> 이를 위해 semaphore 라는 툴이 등장

세마포어란, 어떤 Integer S 
-> initialization을 제외하고, 오직 2개의 atomic 한 operations 로만 세마포어에 접근 가능
-> wait() & signal()

```java
wait(S) {
	while (s <= 0) {
		"아무것도 안함"
	}
	S--;
}

signal(S) {
	S++;
}
```


세마포어를 수정하는 wait, signal 은 indivisibly 하게 실행되어야만 한다.

- [ ] indivisibly #EnglishWord 
	- in a way that cannot be divided, separated, or broken into smaller parts

그말인 즉슨, 한 프로세스가 세마포어를 수정하는 동안에는 다른 프로세스는 접근이 불가능해야 함.

“In addition, in the case of wait(S), the testing of the integer value of S (S ≤ 0), as well as its possible modification (S--), must be executed without interruption.”
-> 이 부분은 잘 이해가 안가는데.
wait 에 한해서, 일어날지도 모르는 세마포어의 수정과 마찬가지로, 세마포어의 값을 '테스트' 하는 것은 interruption 이 없이 실행되어야 한다.
-> 여기서 'test' 란 조건을 따진다는 얘기인가 ?
뭐, pass the test 이러면 while 문 안이 실행되는 거고. 그런거 아닌가?

-> 맞다. test 는 '조건식 평가' 를 의미함.

그리고 S<=0 을 테스트하는 것과  modification of S (S--) 가 동시에 일어나서는 안됨. -> (atomicity)

### Usage

OS 에서는 종종 semaphore 를 counting 한 것과 binary 한 것으로 구분.
counting semaphore -> 제한없이 값이 올라갈 수 있음
binary semaphore -> 0 과 1이 도메인

그리고 이 Binary semaphore 가 바로 mutex locks 라고 알려져있는데,
이는 binary semephore 가 mutual exclusion 을 제공하기 떄문이다.

#### mutual exclusion ?
-> 두 개 이상의 이벤트, 동작 등의 것들이 동시에 일어나거나, 동시에 그 값이 'true' 일 수 없는 것.

```java
do {
	wait (mutex) {
		// Ciritical Section
		signal(mutex);
		// remainder section
	}	
} while (True);
```

먼저 wait (mutex) 를 콜해서 mutext 값을 0으로 감소
-> mutex 값이 0이면 다른 프로세스가 critical section 에 접근 불가
-> ciritical section 끝나고 나면 signal (mutex) 로 mutex 값 1 증가 ->  mutex = 1, 다른 프로세스 진입 가능.

counting semaphore 에서는 1보다 큰 숫자가 가능한데,
이는 critical section, 해당 리소스에 '동시에' 접근할 수 있는 프로세스의 수를 의미.
예를들어 S=5 이면 어떤 리소스에 동시에 5개의 프로세스가 접근 가능.

이걸로 여러가지 synchronization problem을 해결할 수 있는데.
가령 cuncurrently 하게 실행되는 P1, P2 프로세스가 있고 각각은 S1, S2 statement 를 실행하는데, 
S1 다음에야 S2 가 실행되게 하고 싶다고 하자.
그럼
P1 : S1 -> signal(synch)
P2 : wait(synch) -> S2

이렇게 해버리면 해결됨.


그러니까 mutex 는 값이 1인 세마포어. (binary semaphore)

#### Difference between semaphore (mutex) and monitor ?

근데 이러고 나니까, 모니터가 곧 세마포어 아닌가 ?
그냥 mutex 랑 다를게 없어보이는데.
락을 얻는다 -> wait -> mutex--; 락을 해제한다 -> signal -> mutex++;

근데 mutex 잘못쓰면 deadlock 걸리는 걸로 나온다.

그럼 모니터는 이걸 어떻게 개선했는지 ?

#### Monitor 

모니터 자체는 high-level synchronization construct , 즉 구조체 타입이다. (자바에서는 클래스와 비슷함. 변수 + 메서드가 있기때문.)

``` java
monitor 'monitor name'
{
	// shared variable declaration 
	
	procedure P1 ( ... ) {  
		...
	}
	
	procedure P2 ( ... ) {  
		...
	}
	
		,,, 
		
	procedure Pn ( ... ) {  
		...
	}
	
	initialization Code ( ... ) {
		...
	}
}
```


모니터 구조체는 모니터 안에서의 procedure 가 한번에 하나만 active 하는 것을 보장함.
그래서 Programmer 가 synchronization 을 명시적 (explicitly) 으로 신경쓸 필요가 없음.

아 일단 시간관계상 여기까지만 알아보는 걸로.




## 명시적 lock

자바의 신 2권에 명시적 lock 에 대한 내용이 없는데 ?
이거 책버전이 달라서 그런거 아니야 ?

-> Java Concurrency in Practice (by Brian Goetz)

자바 5.0 부터 ReentrantLock 지원. 
그 이전에는 synchronization problem 을 해결 하기 위해서 자바는 synchronize, volatile 키워드를 지원.

### Lock interface and ReentrantLock 

- [ ] Reentrant #EnglishWord ➕ 2025-09-14 
      adj : (of an angle) pointing inward.
      noun : a re-entrant angle
	        a person who has re-entered something, especially the labor force
			-> "re-entrants who left to raise a family and are now seeking to get back in"
		Reentrancy -> 재진입성


내재된 락킹과는 다르게 (synchronize), Lock interface 는 서로 다른 4가지의 Lock acquisition mechanism 을 제공함.
그리고 모든 lock, unlock operation 은 explicit, 즉 명시적임.

1. Unconditional
"무조건적" 으로 락을 획득함

2. Polled 

3. Timed

4. Interruptible


Lock implementations 은 반드시 instrinsic locks (synchronize 아닌가 ?) 와  같은 'memory-visibility semantics' 를 제공해야 한다.
-> 이게 뭔소리야 ?


ReentrantLock 은 Lock interface 을 구현하고, 같은 mutual exclusion 과 


### Memory visibility

java 의 synchronize block 과 method 는 어떠한 동작이 atomically 하게 동작되는 것을 보장해주는 것으로 얘기할 수 있다.
하지만 synchronize 는 단순히 atomicty 를 보장하고, critical section 을 나누는데에만 그치지 않는다.
memory visibility 에 대한 측면도 포함한다.

우리는 먼저 어떠한 스레드가 어떤 객체를 사용하고 있을때 다른 쓰레드가 그 객체의 상태를 변경하는 것을 막기를 원했는데,
그 뿐만 아니라 어떠한 객체가 어떤 객체의 상태를 변화할때, 다른 쓰레드가 그 변화를 인지하는 것을 보장하고자 하는게 우리의 목표.

synchronization 이 없으면, 우리가 원하는 이러한 동작은 보장받지 못한다. 

visibility 는 포착하기 어려운, 복잡한데 그 이유는 잘못될 수 있는 것들이 너무 직관적이지 못하기 때문 (counterintuitive).


아 이내용 너무 어렵다. 좀 나중에 해야 할 것 같다. 이거 하다가 다른거 다 못한다.





## minor gc 는 full gc 보다 크기도 작지만 방식이 달라 더 빠르다고 한다. 방식이 뭐가 어떻게 다른가 ?


나의 이해 : minor gc 는 Eden 에 있는 객체들 중에 사용하지 않는 개체는 discard 하고 남은 객체를 survivor 0 또는 s1 에 이동하는데,
자바의 runtime 중에 대부분의 객체는 빠르게 소멸하기때문에, 옮기는 양이 적고 그만큼 많은 객체를 소멸시키기 때문에
메모리 compaction 도 더 쉽다.따라서 보통의 minor gc 는 굉장히 빠르게 동작한다.

반면, full gc 는 old generation 에 쌓여있는 모든 힙 공간을 삭제하고 compaction 을 진행해야 하기 때문에 그 양이 커서 느릴 수 밖에 없다.

