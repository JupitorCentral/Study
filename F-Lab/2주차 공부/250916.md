## Static Field 는 클래스가 memory 에 loading 될때 저장되는데, 이에 대한 더 정확한 설명 2


at Java Memory Management by van Putten, Maaike (2022), Chapter 5
### Zooming in on the Metaspace

일단 metaspace는 기존 jvm 의 heap 과는 다르게 native memory 에 위치한다.

#### What constitutes Metaspace

- 클래스 파일
- 클래스의 구조 (?) 와 메서드
- 상수
- 어노테이션
- Optimizations (?)

클래스 파일 ?
클래스의 구조? 메서드는 알겠고
상수 ? 무슨 상수지 ? stack 이 아니라 ?


'원래 PermGen 에는
class metadata, interned strings, class's static variables 가 들어가 있었다.
Java 8 부턴, 클래스 메타데이터는 Metaspace 에, 
interned strings 와 class / static variables 은 heap 에 저장되게 됨.'

interned String ? 

애초에 클래스 메타데이터는 무엇인가 ?


> metaspace 도 gc 에 따라 공간이 비워질 수 있음. permanent 한 게 아님.

-> 일단 JVM 이 메모리에 클래스들을 로딩하면, 
JVM 은 반드시 그 클래스들에 대한 어떤 metadata 를 계속 추적하고 있어야 함.
-> 그 정도들이 metaspace 에 저장됨.


at https://dev.to/arshisaxena26/navigating-jvm-memory-key-concepts-for-your-java-interview-2nc8
### The Role of JDK, JRE, and JVM

#### JDK

자바 프로그램을 개발하기 위한 kit
JRE 를 포함

#### JRE

JVM + Class Library

Class Libary -> pre-compilled 된 class들 (String, Math 등)

#### JVM
자바 바이트코드 (.java 파일이 컴파일된 코드) 를 실행하는데에 책임이 있는 Core component

#### Bytecode and Class file

자바 클래스 파일은 .java 파일이 컴파일된 파일.
-> Bytecode, metadata, constant pool, method definition 등이 있음

그래서 metaspace 에 class structrue 가 포함된다는 말은 곧 그냥 class file 에 담겨있는 정보가 담겨있다는 얘기임
왜냐하면 class file structure 는 class file 에 담겨져있는 하나뿐인 Structure, 즉 구조체(메소드가 없는 Java 클래스 를 의미하는듯) 이기 때문.

![[Screenshot 2025-09-16 at 2.20.15 PM.png|500]]
(By Java virtual machine Specification Java SE 8 Edition)


-> 근데 constant pool 이 어떻게 여기 들어가지 ? heap 아니라 ?
String constant pool 은 동적으로 생길텐데 ?

#### Understanding the constant pool inside a Java class file



### JVM Memory Allocation


으아아악 일단 다른거 먼저



## 프로세스와 쓰레드의 차이는 ? 그걸 알기 위해, 프로세스는 무엇이고, 쓰레드는 무엇인가 ?


### Process
#### What is process?

프로그램은 passive 한 entity, Process 은 active 한 entity로 말할 수 있고,
프로그램에 메모리에 올라온게 프로세스이다. 

프로그램 -> disk (휘발성이 아닌, permanent 하게 데이터가 저장되는 공간) 에 저장되는 instruction 의 집합

프로세는 단순히 코드들의 집합이 아님 (코드들 -> text section 이라 불림)
stack, heap, data section 이라는 공간도 존재할 수 있음

stack -> function parameters, return address, local variables 등의 temporary data 등이 들어감
(자바에서도 function 이 call 되면 function frame 이 stack 에 쌓인다)

data section -> global variables 존재
(자바에서는 static variables, method 가 될 것. 메타스페이스와 별개의 공간이 될 수 밖에 없다.
왜냐하면 자바에서의 metaspace 는 heap 과 별개의 공간이며, native memory 에 상주하기 때문이다.
metaspace 에는 class structure, constant pool 등이 존재한다. 
근데 constant pool 은 어떤 곳에서는 heap에, 어떤 곳에서는 metaspace 에 상주한다고 한다.
뭐가 맞는 말인지.)

heap -> 동적으로 할당되는 공간. 
(자바에서는 객체가 생성되는 공간. constant pool (e.g String constant pool) 등이 상주.
그리고 객체가 생성될때, instance variable 도 객체가 생성되는 공간, heap에 저장된다 (객체 안에 존재하기 때문)
그래서 모든 primitive type이 stack 에만 저장되는 것은 아니다.)



#### state of process

new -> 새로 생성된 상태
ready -> cpu 에 할당되기를 기다리며 실행가능한 상태

running -> cpu 에 의해 실행되는 상태

waiting -> I/O 요청등에 의해 실행이 기다리는 상태.

terminated -> 종료

----

##### state of thread at Java

자바에서는, Runnable 상테 안에 ready, running 상태가 존재
ready -> cpu에 할당되기를 기다리는 상태
running -> 실제로 cpu 에 의해 실행되는 상태

그리고 waiting 에 대해서는 3가지 타입이 있다
Timing waiting, Waiting, Blocked 가 있다

Timing Waiting -> 시간초 parameter 가 설정된 sleep, join 등에 의해 일정 시간동안 기다리는 시간.
Waiting -> 기약없는 sleep, join 에 의해 설정되는 상태

Timing Waiting, Waiting 등은 notify, notifyAll 등에 의해 Runnable 상태로 전환될 수 있다. 
Timing Waiting 의 경우 시간초가 다 되면 Runnable 로 전환된다.

Monitor lock 이 필요한 곳에 접근하는 경우, Blocked 상태가 되고,
monitor lock 을 얻고 나면 Runnble 로 상태가 변한다.

쓰레드의 모든 실행이 끝나고 나면 Terminated 상태로 끝.



#### Process Control Block (PCB)

-> 프로세스에 관한 정보 (metadata).

process state -> 위에서 말한 프로세스 상태

process number -> PID. 리눅스 해봐서 알잖아

program counter -> 프로세스가 다음에 실행할 코드 시작점

Registers -> 프로세스가 실행되기 위해서 사용되는 레지스터들의 상태를 보관해두는 곳
	CPU 가 다른프로세스를 실행하다가 CPU scheduling algorithm 에 의해 해당 프로세스가 할당되면,
	PCB의 이 공간에 있던 register 들을 불러와서 프로세스 코드를 execute 하고,
	다시 다른 프로세스로 넘어가기 전에, 현재 register 의 상태들을 이곳에 보관한다.

CPU scheduling information 
	-> CPU scheduling algorithm 은 어떤 프로세스가 어떤 priority 를 갖느냐에 따라
		프로세스를 먼저 실행할지 나중에 실행할지 결정하고 그에 관한 정보가 여기 저장됨

Memory Management Information
	-> 잘 모르겠는데. 
	-> 여기에는 OS 가 사용하는 memory system 에 의해 뭐가 저장될지 바뀌며,
		base 와 register 의 value (? base 가 가리키는게 뭔데), page tables (virtual memory 에 쓰이는 건가 ?)
		또는 segment table 등이 저장될 수 있음.

Accounting Information
	-> amount of CPU 등의 정보
I/O status information
	-> 프로세스에 할당된 I/O 장치 정보 등등.


![[Screenshot 2025-09-16 at 7.08.45 PM.png|400]]

-> 쓰레드도 프로세스 내에서 이러한 매커니즘과 비슷하게 동작할 거 같다. 저 이미지에서
프로세스 P0, P1 대신에 쓰레드 T0, T1 이렇게.

### Thread

참고로 자바에서 프로세는 32MB 정도 차지한다 하면 Thread 는 1~2MB 정도 메모리를 차지한다고.

많은 현대 OS 에서는 하나의 프로세스의 여러 tasks 들을 동시에 처리하게 만들기 위해서 
하나의 프로세스가 여러개의 쓰레드를 실행하도록 설계되어 있음.

Mutiple Thread 를 제공하는 Process 는 그만큼 Thread 에 관한 추가적인 정보가 PCB 에 추가된다.

#### What is Thread ?

basic unit of CPU utilization. (cpu  활용의 기본적인 단위, 유닛. 무슨 의미일지.)
thead id, program counter, register set, stack 으로 구성되어 있음
(프로세스와 비슷하다.  )

그리고, 하나의 프로세스 안에 있는 여러개의 쓰레드들은, 프로세스 안에 담겨져있는 
code section (text section),  data section, 파일이나 signal 등과 같은 
프로세스에 할당된 OS 자원들 등을 공유한다. (같이 접근 가능)

![[Screenshot 2025-09-16 at 7.16.36 PM.png|600]]

(힙은 어떻게 되는거지...?)

스레드가 여러개임에 따라, 하나의 Web serve application Process 는 여러 사용자의 request 에 병렬적으로
처리할 수 있음.

--> 프로세스 여러개 만들면 되지않나 ?
--> 오버헤드의 차이.  일반적으로 쓰레드를 생성해서 처리하는게 더 resource 가 적게 든다
(위에도 얘기했던 것처럼, 자바에서 프로세스는 32MB, 쓰레드는 1~2MB)

#### Benefits using Thread

##### 1. Responsivness

##### 2. Resource Sharing

##### 3. Economy

##### 4. Scalability


-------------------

### 그래서, Process와 Thread의 차이점은 ?

글쎄, 뭔가 딱 짚어서 말하기가 힘들다.

프로세스는 프로그램의 active entity 이고, 프로그램으로 부터 생성된다.
프로세스가 single thread 이면 프로세스 하나에 stack, register 가 한 세트이지만

Process 가 multi-thread 이면 스레드 각자마다 register 와 스택이 있다.

그러니까 Process 는 메모리에 올려진 프로그램 코드 + 각종 자원의 집합.
쓰레드는 같은 프로세스 내에서 프로세스의 data section, code section, file 등을 공유하는
CPU 실행의 가장 작은 단위. 라고 말할 수 있으려나 ?



## 2의 보수, 1의 보수 이해 -> 왜 2의 보수를 사용하는가 ?

컴퓨터에서 수를 표현하는 방법 2가지 -> 1의 보수, 2의 보수

### 1의 보수

0101 의 음수를 구하려면, 1010. 비트를 반전시킨다.

#### pros
비트만 반전시키면 되니까 음수를 구하기 쉽다.

#### cons

1111 -> -0, 0000 -> 0 즉 0 이 두가지이다.
-0 에 대해 문제가 생기는데 

첫번째, 소프트웨어  0 을 표현할때 뭘로 표현할지 애매해진다. 0000 으로 할지, 1111로 할지 ?
그리고, 값이 1111 또는 0000 일때 모두 0으로 취급해야 하므로, 두번 체크 해야 한다. -> 즉 직관적이지 못함.

end-around carry 가 발생하면 1을 더해주어야 한다.

 3 + (-0) 을 더해보면
   0 0 1 1
   1  1  1 1 (-0)
1 0 0  1 0  -> +2 가 된다.

이를 위해선 1을 더해주어야 한다.

6 - 19
   0000 0 1  1  0   ( 6 )
   1 1 1 0  1  1  0 0  ( - 19 )
   1  1 1 1  0 0 1  0 
   -> 12 가 된다.

![[Screenshot 2025-09-16 at 10.06.29 PM.png|400]]

-> 즉, 연산이 복잡해진다.

그리고 2의 보수에 비해서 음수 1개가 빈다. 즉 표현할 수 있는 수가 한개 줄어든다.



### 2의 보수

음수를 구하기 위해서, 비트를 모두 반전하고 거기에 1을 더한다.

 0 0 1 0   -> 2
 1  1  0 1
 1  1  1  0    -> -2

( - 0 ) 의 경우

0 0 0 0
1  1  1  1
0 0 0 0   -> - 0 이 없음

그럼 최댓값은 ?

0 1 1 1   -> 7
1 0 0 0 
1 0 0 1  -> -7   -> 여전히 하나가 빈다.

1  1 1 1   -> 0 0 0 1  ->  1 1 1 1 은 -1
1  1 1 0   ->  0 0 1 0  -> 1 1 1 0 은 -2
이대로 가면
1 0 0 0   ->  8 개  ( 1 1 1 1 ~ 1 0 0 0 ) 에서 0 0 0 ~ 1 1 1 은 8개다.
즉 1 0 0 0 은 - 8 이라고 생각할 수 있다.
0 1 1 1 은 7.


그럼 위 방법으로 위의 경우를 계산해보면...
( - 0 ) 에 대한 경우에는 계산할 필요가 없으니

  0 0 0 0   0  1   1  0   ( 6 )
   1  1  1  0   1   1   0  1  ( - 19 )
   1  1  1   1    0  0  1   1 

음수니까 반전 + 1 하면

0 0 0 0  1 1 0 1   -> 13  -> 바로 딱 떨어진다

1 의 보수와 다르게 캐리 무시 가능.



## 부동 소수점 이해

floating 포인트는 2의 보수를 쓰지 않는다.


4.5 를 IEEE 754 single precision 으로 구해보면

![[Screenshot 2025-09-16 at 10.43.37 PM.png|600]]

![[Screenshot 2025-09-16 at 10.43.58 PM.png|600]]


즉, 4.5 를 100.1 로 먼저 표현. (이진수로 표현.) 4 -> 100, 0.5 -> 2분의 1 -> 2^(-1) -> 0.1
-> normalization 1.001 e^2 . 즉 지수 : 2, 가수 : 001 (1은 무조건 있다고 가정. 0을 표현하면, 가수 23비트는 모두 0이 되므로 표현 가능)

지수 2에 대해서, bias 127 을 사용, 127 을 지수에 더해서 129 를 2진수로 표현

즉 가수에 대한 2진수 구하기 + 지수 구하기 + 지수에 bias 더해서 이진수로 표현하기
signed bit + base ^ exponent + Mantissa (Significand)


### 0.1 + 0.2 != 0.3

위에 표현에 따르면, 0.5 = 2^-1. 0.25 = 2^-2. 그러니까, 소수점 아래 수는 2의 나누기로 표현한다.
이때, 0.1 과 0.2 는 이진수의 소수점 아래 표현으로 무한소수로밖에 표현이 안된다.
(0.2 가 문제인듯. 0.1 -> 0.2 가 되니까)

![[Screenshot 2025-09-17 at 2.20.50 AM.png|300]]

IEEE 754 의 정밀도의 한계는, 
Single Precision 의 경우 23bit -> 유효 자릿수 약 7자리
Double Precision 의 경우 52bit  -> 유효 자릿수 약 15-16 자리



![[Screenshot 2025-09-17 at 2.21.48 AM.png|600]]

그래서 0.1 + 0.2 != 0.3 인 것이다.
이를 보완하려면, 특정 자릿수에서 특정 오차 이내에는 값이 같다고 판정하게끔 하는 것으로 해결

```javascript
// 문제
0.1 + 0.2 === 0.3; // false

// 해결법 1: Number.EPSILON 사용
Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON; // true

// 해결법 2: 정수로 변환 후 계산
(1 + 2) / 10 === 0.3; // true

// 해결법 3: toFixed() 사용
(0.1 + 0.2).toFixed(1) === '0.3'; // true
```



### BigDecimal in Java

자바에서는 2진수로 저장안하고, 10진수 그대로 저장한다.

```java
// 내부 구조
class BigDecimal {
    BigInteger intVal;    // unscaled value (정수)
    int scale;           // 소수점 자릿수
}

// IEEE 754: 0.1을 이진수 무한소수로 근사
double d = 0.1; // 실제로는 0.1000000000000000055...

// BigDecimal: 정확한 십진수 표현
BigDecimal bd = new BigDecimal("0.1");
// 내부적으로: intVal = 1, scale = 1
// 의미: 1 × 10^(-1) = 0.1

// float/double (근사값 연산)
0.1 (근사) + 0.2 (근사) = 0.30000000000000004 (근사)

// BigDecimal (정확한 십진수 연산)
BigDecimal a = new BigDecimal("0.1");  // intVal=1, scale=1
BigDecimal b = new BigDecimal("0.2");  // intVal=2, scale=1
BigDecimal result = a.add(b);          // intVal=3, scale=1 = 0.3

```

주의할점은 BigDecimal(0.1) 이렇게 쓰면 안되고, BigDecimal ("0.1") 이렇게 
파라미터에 스트링타입을 넣어주어야 된다.

IEEE 754 의 single/double precision 은 표현할 수 있는 정밀도에 한계가 있지만
BigDecimal 의 정밀도는 메모리가 제공되는 한 무한하다. (가변적임)

대신 무한소수는 BigDeicmal 도 피할 수 없는데, 이럴땐 위와 비슷하게 특정 자릿수에서 반올림 & 오차를 사용한다.

```java
import java.math.RoundingMode;

// ✅ 정밀도와 반올림 모드 명시
BigDecimal result = one.divide(three, 10, RoundingMode.HALF_UP);
// 결과: 0.3333333333 (소수점 10자리까지)

// ✅ MathContext 사용
MathContext mc = new MathContext(50, RoundingMode.HALF_UP);
BigDecimal precise = one.divide(three, mc);
// 결과: 50자리 정밀도로 계산
```

즉, 가수 부분을 BigInteger 로 10진수로 표현해서 저장하고 
(실제 내부적으로는 당연히 2진수이지만, 1이상의 자연수는 2진수가 무한대로 표현할 수 있으므로 문제가 안됨)
그다음 지수부분 (scale) 을 따로 저장하는 것.


> [!info] 그래서 BigDecimal 은 아무래도 IEEE 754 보다 느리다.
> IEEE 754 는 하드웨어적으로 직접 연산을 지원하지만 BigDecimal 은 하드웨어적으로 표현하기 때문


####  BigInteger 는 값을 어떻게 저장하는가 ?

```java
// BigInteger 내부 구조 (개념적)
class BigInteger {
    int signum;        // -1(음수), 0(영), 1(양수)  
    int[] mag;         // magnitude (절댓값의 이진 표현)
}

// -123을 BigInteger로 저장
BigInteger negativeNum = new BigInteger("-123");

// 내부적으로:
// signum = -1
// mag = [123의 이진 표현] = [01111011]

BigInteger(int signum, byte[] magnitude) // BigInteger 의 constructor 
```

#### 2의 보수를 안쓰는 이유 ?

```java
// 2의 보수는 고정 크기에서만 의미가 있음
int value = -1;  // 32-bit: 11111111111111111111111111111111

// BigInteger는 임의 크기 지원
BigInteger huge = new BigInteger("-999999999999999999999999999999");
// 2의 보수로는 "몇 비트 기준인가?" 문제 발생
```

2의 보수로는 몇비트 기준인가? 로부터 오는 문제발생에 대해서,
연산에 대해서 생각하면 감이 확온다.

```java
// Sign-Magnitude 방식 (현재 BigInteger)
BigInteger minusOne = new BigInteger("-1");  // signum=-1, mag=[1]
BigInteger huge = new BigInteger("999999999999999999999999");
BigInteger result = minusOne.add(huge);      // 간단한 연산

// 만약 2의 보수를 썼다면:
// -1을 몇 비트로 저장할 것인가?
// 8비트? 16비트? 32비트? 64비트? 80비트?
// huge와 연산하려면 둘 다 같은 길이로 맞춰야 함
// 매번 연산할 때마다 비트 길이 결정 문제 발생
```

만약 2의 보수로 크기가 커질때마다 그 크기를 정하고 1로 채워둘 수 있지만,
위의 경우에는 서로 다른 자릿수 - 크기를 가지기 때문에 연산이 안된다.

-> 그런데 위의 경우, 연산시 동적 확장을 하면 안되는지 ?

이론적으론 가능하다, 실제로 일부 라이브러리에서 그렇게 사용.

그렇지만 성능 오버헤드가 심각함.

Reddit 개발자 경험담:

> _"tried implementing 2's complement for arbitrary precision. The overhead of constantly resizing and sign-extending made it 3-4x slower than sign-magnitude for most operations"_



#### 문서에서 Two's complement 처럼 동작한다고 말하는 것에 대한 의미

```java
// 비트 연산은 2의 보수처럼 동작
BigInteger a = new BigInteger("-5");
BigInteger result = a.shiftRight(1);  // 부호 확장 수행
System.out.println(result);  // -3 (2의 보수 규칙 따름)
```





