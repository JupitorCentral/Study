## Static Field 는 클래스가 memory 에 loading 될때 저장되는데, 이에 대한 더 정확한 설명 2


at Java Memory Management by van Putten, Maaike (2022), Chapter 5
### Zooming in on the Metaspace

일단 metaspace는 기존 jvm 의 heap 과는 다르게 native memory 에 위치한다.

#### What constitutes Metaspace

- 클래스 파일
- 클래스의 구조 (?) 와 메서드
- 상수
- 어노테이션
- Optimizations (?)

클래스 파일 ?
클래스의 구조? 메서드는 알겠고
상수 ? 무슨 상수지 ? stack 이 아니라 ?


'원래 PermGen 에는
class metadata, interned strings, class's static variables 가 들어가 있었다.
Java 8 부턴, 클래스 메타데이터는 Metaspace 에, 
interned strings 와 class / static variables 은 heap 에 저장되게 됨.'

interned String ? 

애초에 클래스 메타데이터는 무엇인가 ?


> metaspace 도 gc 에 따라 공간이 비워질 수 있음. permanent 한 게 아님.

-> 일단 JVM 이 메모리에 클래스들을 로딩하면, 
JVM 은 반드시 그 클래스들에 대한 어떤 metadata 를 계속 추적하고 있어야 함.
-> 그 정도들이 metaspace 에 저장됨.


at https://dev.to/arshisaxena26/navigating-jvm-memory-key-concepts-for-your-java-interview-2nc8
### The Role of JDK, JRE, and JVM

#### JDK

자바 프로그램을 개발하기 위한 kit
JRE 를 포함

#### JRE

JVM + Class Library

Class Libary -> pre-compilled 된 class들 (String, Math 등)

#### JVM
자바 바이트코드 (.java 파일이 컴파일된 코드) 를 실행하는데에 책임이 있는 Core component

#### Bytecode and Class file

자바 클래스 파일은 .java 파일이 컴파일된 파일.
-> Bytecode, metadata, constant pool, method definition 등이 있음

그래서 metaspace 에 class structrue 가 포함된다는 말은 곧 그냥 class file 에 담겨있는 정보가 담겨있다는 얘기임
왜냐하면 class file structure 는 class file 에 담겨져있는 하나뿐인 Structure, 즉 구조체(메소드가 없는 Java 클래스 를 의미하는듯) 이기 때문.

![[Screenshot 2025-09-16 at 2.20.15 PM.png|500]]
(By Java virtual machine Specification Java SE 8 Edition)


-> 근데 constant pool 이 어떻게 여기 들어가지 ? heap 아니라 ?
String constant pool 은 동적으로 생길텐데 ?

#### Understanding the constant pool inside a Java class file



### JVM Memory Allocation


으아아악 일단 다른거 먼저



## 프로세스와 쓰레드의 차이는 ? 그걸 알기 위해, 프로세스는 무엇이고, 쓰레드는 무엇인가 ?


### Process
#### What is process?

프로그램은 passive 한 entity, Process 은 active 한 entity로 말할 수 있고,
프로그램에 메모리에 올라온게 프로세스이다. 

프로그램 -> disk (휘발성이 아닌, permanent 하게 데이터가 저장되는 공간) 에 저장되는 instruction 의 집합

프로세는 단순히 코드들의 집합이 아님 (코드들 -> text section 이라 불림)
stack, heap, data section 이라는 공간도 존재할 수 있음

stack -> function parameters, return address, local variables 등의 temporary data 등이 들어감
(자바에서도 function 이 call 되면 function frame 이 stack 에 쌓인다)

data section -> global variables 존재
(자바에서는 static variables, method 가 될 것. 메타스페이스와 별개의 공간이 될 수 밖에 없다.
왜냐하면 자바에서의 metaspace 는 heap 과 별개의 공간이며, native memory 에 상주하기 때문이다.
metaspace 에는 class structure, constant pool 등이 존재한다. 
근데 constant pool 은 어떤 곳에서는 heap에, 어떤 곳에서는 metaspace 에 상주한다고 한다.
뭐가 맞는 말인지.)

heap -> 동적으로 할당되는 공간. 
(자바에서는 객체가 생성되는 공간. constant pool (e.g String constant pool) 등이 상주.
그리고 객체가 생성될때, instance variable 도 객체가 생성되는 공간, heap에 저장된다 (객체 안에 존재하기 때문)
그래서 모든 primitive type이 stack 에만 저장되는 것은 아니다.)



#### state of process

new -> 새로 생성된 상태
ready -> cpu 에 할당되기를 기다리며 실행가능한 상태

running -> cpu 에 의해 실행되는 상태

waiting -> I/O 요청등에 의해 실행이 기다리는 상태.

terminated -> 종료

----

##### state of thread at Java

자바에서는, Runnable 상테 안에 ready, running 상태가 존재
ready -> cpu에 할당되기를 기다리는 상태
running -> 실제로 cpu 에 의해 실행되는 상태

그리고 waiting 에 대해서는 3가지 타입이 있다
Timing waiting, Waiting, Blocked 가 있다

Timing Waiting -> 시간초 parameter 가 설정된 sleep, join 등에 의해 일정 시간동안 기다리는 시간.
Waiting -> 기약없는 sleep, join 에 의해 설정되는 상태

Timing Waiting, Waiting 등은 notify, notifyAll 등에 의해 Runnable 상태로 전환될 수 있다. 
Timing Waiting 의 경우 시간초가 다 되면 Runnable 로 전환된다.

Monitor lock 이 필요한 곳에 접근하는 경우, Blocked 상태가 되고,
monitor lock 을 얻고 나면 Runnble 로 상태가 변한다.

쓰레드의 모든 실행이 끝나고 나면 Terminated 상태로 끝.



#### Process Control Block (PCB)

-> 프로세스에 관한 정보 (metadata).

process state -> 위에서 말한 프로세스 상태

process number -> PID. 리눅스 해봐서 알잖아

program counter -> 프로세스가 다음에 실행할 코드 시작점

Registers -> 프로세스가 실행되기 위해서 사용되는 레지스터들의 상태를 보관해두는 곳
	CPU 가 다른프로세스를 실행하다가 CPU scheduling algorithm 에 의해 해당 프로세스가 할당되면,
	PCB의 이 공간에 있던 register 들을 불러와서 프로세스 코드를 execute 하고,
	다시 다른 프로세스로 넘어가기 전에, 현재 register 의 상태들을 이곳에 보관한다.

CPU scheduling information 
	-> CPU scheduling algorithm 은 어떤 프로세스가 어떤 priority 를 갖느냐에 따라
		프로세스를 먼저 실행할지 나중에 실행할지 결정하고 그에 관한 정보가 여기 저장됨

Memory Management Information
	-> 잘 모르겠는데. 
	-> 여기에는 OS 가 사용하는 memory system 에 의해 뭐가 저장될지 바뀌며,
		base 와 register 의 value (? base 가 가리키는게 뭔데), page tables (virtual memory 에 쓰이는 건가 ?)
		또는 segment table 등이 저장될 수 있음.

Accounting Information
	-> amount of CPU 등의 정보
I/O status information
	-> 프로세스에 할당된 I/O 장치 정보 등등.


![[Screenshot 2025-09-16 at 7.08.45 PM.png|400]]

-> 쓰레드도 프로세스 내에서 이러한 매커니즘과 비슷하게 동작할 거 같다. 저 이미지에서
프로세스 P0, P1 대신에 쓰레드 T0, T1 이렇게.

### Thread

참고로 자바에서 프로세는 32MB 정도 차지한다 하면 Thread 는 1~2MB 정도 메모리를 차지한다고.

많은 현대 OS 에서는 하나의 프로세스의 여러 tasks 들을 동시에 처리하게 만들기 위해서 
하나의 프로세스가 여러개의 쓰레드를 실행하도록 설계되어 있음.

Mutiple Thread 를 제공하는 Process 는 그만큼 Thread 에 관한 추가적인 정보가 PCB 에 추가된다.

#### What is Thread ?

basic unit of CPU utilization. (cpu  활용의 기본적인 단위, 유닛. 무슨 의미일지.)
thead id, program counter, register set, stack 으로 구성되어 있음
(프로세스와 비슷하다.  )

그리고, 하나의 프로세스 안에 있는 여러개의 쓰레드들은, 프로세스 안에 담겨져있는 
code section (text section),  data section, 파일이나 signal 등과 같은 
프로세스에 할당된 OS 자원들 등을 공유한다. (같이 접근 가능)

![[Screenshot 2025-09-16 at 7.16.36 PM.png|600]]

(힙은 어떻게 되는거지...?)

스레드가 여러개임에 따라, 하나의 Web serve application Process 는 여러 사용자의 request 에 병렬적으로
처리할 수 있음.

--> 프로세스 여러개 만들면 되지않나 ?
--> 오버헤드의 차이.  일반적으로 쓰레드를 생성해서 처리하는게 더 resource 가 적게 든다
(위에도 얘기했던 것처럼, 자바에서 프로세스는 32MB, 쓰레드는 1~2MB)

#### Benefits using Thread

##### 1. Responsivness

##### 2. Resource Sharing

##### 3. Economy

##### 4. Scalability


-------------------

### 그래서, Process와 Thread의 차이점은 ?

글쎄, 뭔가 딱 짚어서 말하기가 힘들다.

프로세스는 프로그램의 active entity 이고, 프로그램으로 부터 생성된다.
프로세스가 single thread 이면 프로세스 하나에 stack, register 가 한 세트이지만

Process 가 multi-thread 이면 스레드 각자마다 register 와 스택이 있다.

그러니까 Process 는 메모리에 올려진 프로그램 코드 + 각종 자원의 집합.
쓰레드는 같은 프로세스 내에서 프로세스의 data section, code section, file 등을 공유하는
CPU 실행의 가장 작은 단위. 라고 말할 수 있으려나 ?



## 2의 보수, 1의 보수 이해 -> 왜 2의 보수를 사용하는가 ?

컴퓨터에서 수를 표현하는 방법 2가지 -> 1의 보수, 2의 보수

### 1의 보수

0101 의 음수를 구하려면, 1010. 비트를 반전시킨다.

#### pros
비트만 반전시키면 되니까 음수를 구하기 쉽다.

#### cons

1111 -> -0, 0000 -> 0 즉 0 이 두가지이다.
-0 에 대해 문제가 생기는데 

첫번째, 소프트웨어  0 을 표현할때 뭘로 표현할지 애매해진다. 0000 으로 할지, 1111로 할지 ?
그리고, 값이 1111 또는 0000 일때 모두 0으로 취급해야 하므로, 두번 체크 해야 한다. -> 즉 직관적이지 못함.

end-around carry 가 발생하면 1을 더해주어야 한다.

 3 + (-0) 을 더해보면
   0 0 1 1
   1  1  1 1 (-0)
1 0 0  1 0  -> +2 가 된다.

이를 위해선 1을 더해주어야 한다.

6 - 19
   0000 0 1  1  0   ( 6 )
   1 1 1 0  1  1  0 0  ( - 19 )
   1  1 1 1  0 0 1  0 
   -> 12 가 된다.

![[Screenshot 2025-09-16 at 10.06.29 PM.png|400]]

-> 즉, 연산이 복잡해진다.

그리고 2의 보수에 비해서 음수 1개가 빈다. 즉 표현할 수 있는 수가 한개 줄어든다.



### 2의 보수

음수를 구하기 위해서, 비트를 모두 반전하고 거기에 1을 더한다.

 0 0 1 0   -> 2
 1  1  0 1
 1  1  1  0    -> -2

( - 0 ) 의 경우

0 0 0 0
1  1  1  1
0 0 0 0   -> - 0 이 없음

그럼 최댓값은 ?

0 1 1 1   -> 7
1 0 0 0 
1 0 0 1  -> -7   -> 여전히 하나가 빈다.

1  1 1 1   -> 0 0 0 1  ->  1 1 1 1 은 -1
1  1 1 0   ->  0 0 1 0  -> 1 1 1 0 은 -2
이대로 가면
1 0 0 0   ->  8 개  ( 1 1 1 1 ~ 1 0 0 0 ) 에서 0 0 0 ~ 1 1 1 은 8개다.
즉 1 0 0 0 은 - 8 이라고 생각할 수 있다.
0 1 1 1 은 7.


그럼 위 방법으로 위의 경우를 계산해보면...
( - 0 ) 에 대한 경우에는 계산할 필요가 없으니

  0 0 0 0   0  1   1  0   ( 6 )
   1  1  1  0   1   1   0  1  ( - 19 )
   1  1  1   1    0  0  1   1 

음수니까 반전 + 1 하면

0 0 0 0  1 1 0 1   -> 13  -> 바로 딱 떨어진다

1 의 보수와 다르게 캐리 무시 가능.



## 부동 소수점 이해

floating 포인트는 2의 보수를 쓰지 않는다.











