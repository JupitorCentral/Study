# 질문 해결




# 자바의 신 2권

## History & JVM

### Compile at Java?

-> JIT : just in time 

##### 전통적인 컴파일 방식 2가지 

- 인터프리트 방식과 정적 컴파일 방식

- 인터프리트 -> 프로그램이 '실행' 할 때마다 언어 변환 -> 간편, 실행이 느림
- 컴파일 -> 미리 언어 변환

- 언어 변환 -> High level language 를 컴퓨터가 알아들을 수 있는 언어로 변환

-> JIT 는 이 두 가지 방식을  '혼합'
-> 변환작업은 지속적으로 수행되나, 필요한 코드의 정보는 캐시에 담아두었다가 재사용하게 됨.
-> 이것에 대한 구체적인 무언가가 필요할 듯.


#### javac - 자바에서의 컴파일

javac 를 쓰면 자바파일을 컴파일하는 것 처럼 보이지만, 만들어진 class 파일은 '바이트 코드'.
C++ 의 경우 컴파일 하면 obj 파일로 컴파일되고, 이를 다시 라이브러리와 빌드하여 실행가능한 exe 을 만들어낸다.
하지만 자바는 아님.

클래스파일 -> 어떤 환경에서든 동작 가능한 코드

그리고 이걸 가능하게 해주는 것이 바로 JVM. (Java Virtual Machine).

이 클래스파일을 각 OS 에 따라 재변환을 해주어야 하는데, 이를 바로 "JIT" 에서 수행한다. (어셈블리어든 뭐든 어떤걸로 변환해야 할 것 아닌가)


##### JIT 를 사용하는 것으로 인한 단점
-> 처음에는 변환단계를 많이 거쳐야 하므로 성능이 느림
-> 지금은 많이 개선됨


#### HotSpot

-> 서로 다른 2가지의 컴파일러 : 클라이언트, 서버

##### 나누는 것에 대한 기준 
-> 2개 이상의 물리적 cpu, 2GB 이상의 물리적 메모리
-> 이것을 충족시키면 서버 컴파일러로 자동 설정된다.

##### 사용 이유
-> cpu 1개밖에 없던 시절
-> 어플리케이션 실행속도, 메모리 사용량의 최적화를 위해 사용됨


### java 를 쓰기위해선 반드시 알아야 하는 용어


#### JVM

-> 자바 프로그램이 수행되는 프로세스.


#### GC (Garbage collector)

-> 자바는 불필요한 자원을 알아서 처리해준다 


#### Process of GC

- G1 (Garbage First)
-> 자바 7부터 사용가능.

G1 외 나머지 JVM은 (말이 좀 이상한데...)
영역을 나누어서 사용한다. (이 아래가 전부 '힙' 이다.)

![[Screenshot 2025-09-12 at 6.42.12 PM.png|350]]

##### Young
- Eden : 새로 생성된 객체들이 최초로 할당됨
- S0 (Survivor 0) -> Minor GC 후 살아남은 객체들이 이동하는 첫번째 공간
- S1 -> 두번째 생존 객체 공간. S0 과 S1 중 둘 중은 항상 비어있음.
- Virtual : Young 공간의 확장 가능한 가상 공간


객체가 Eden 에 생성 -> Eden 이 꽉차면 살아있는 객체만 S0 또는 S1 으로 이동
-> S0 또는 S1 이 꽉차면 다른 Survivor 공간으로 이동. 이때 Eden에 있던 객체들도 같이 이동함.
(이 행동이 Minor GC. 아마 Survivor 에서 이동할때 안쓰는 객체도 사라질 듯 하다.)

-> S0 S1 둘 중 하나는 항상 비어있어야 함.


이후 여기서도 오래 살아남는 객체들은 Major(Full) GC 가 발생하며, Old 공간으로 이동한다.


##### Old 
- Old/Tenured : 여러번의 Minor GC 를 거쳐 살아남은 오랜 객체들의 공간
- Virtual : 확장 가능한 가상 공간

##### Perm
- 클래스 메타데이터, 상수 등이 저장되는 공간 (Java 8 이후로는 Metaspace로 대체됬다고 ? Perm 이 대체 됬다는 말인가 ?)


##### Execution speed comparison of Young(minor) GC and Full (Major) GC

-> 당연히 Young GC가 더 빠르지 않을까 ? 
-> 맞다. 왜냐하면 일반적으로 더 작은 공간 + 객체처리 방식의 차이
-> 객체 처리방식의 차이 ...? -> 알아야 하나 ? 알면 좋겠지 ?



- TPS 란 ?
-> Transactions per second


#### About GC

-> GC 의 핵심은 deallocaiton & compaction
-> Compaction 이 이루어져야 남은 공간을 잘 쓸 수 있게 된다.

-> 그 객체가 사용중인지 아닌지, 단순히 그 객체를 가리키는 것이 있냐라고만 판단하면 안된다.
-> Circular Linked List 는 어쩔건데 ?

##### Generational Grabaga Collectors

자바의 GC 는 Heap 공간이 다 찼을때 한꺼번에 처리를 하는 것이 아니다. 
Young, Old Generation 으로 나누며, 이렇게 하는 것에 대한 사고의 밑바탕은,
Java 의 많은 객체들은 빠르게 사라진다는 사실에 있다. (짧은 순간안에만 사용된다).

For 문안의 지역변수들이 예를들어 천개씩 생성이 되어도, For 문이 종료되면 그 천개가 한꺼번에 사라진다.
이때 Generational Design 이 효과적. Young generation은 Entire heap의 Subset 이며, 
Young Generation 이 꽉차면, GC 는 ==어플리케이션의 모든 쓰레드를 중지시키고== Young Generation 을 비운다.
쓸모 없어진 객체는 소멸되고, 아직 사용중인 객체는 Suvivor 0 , 1 에 이동된다. 이게 Minor GC.

##### Advantages of Generational Design

첫째, 부분만 비우기때문에 힙 전체를 처리하는 것보다 속도가 빠르다.
Trade off - 대신, 부분이라는 것은 힙전체보다 용량이 적다는 것이고, 곧 힙 전체를 비우는 것보다 더 빈번하게 일어나는 것이며,
곧 힙 전체를 비울때보다 Stop-the-World (어플리케이션의 모든 쓰레드의 중지) 이 일어나는 빈도가 더 높다는 것.

둘째, Minor GC 가 일어날때마다 Eden 의 모든 객체는 사라지거나 이동한다.
따라서 자동적으로 Compaction 이 일어난다.

모든 GC 알고리즘은 Young Generation 의 처리때 Stop-the-World 가 일어나기 마련.

그리고 Old generation 도 언젠간 비워야 하는데, 이 부분이 GC 알고리즘이 가장 차이가 나는 부분.
간단한 알고리즘은 Stop the World 하고 처리.

그런데 복잡한 알고리즘을 사용하면 application thread 가 돌고 있는데도 사용하지 않는 객체를 처리할 수 있는데,
G1, CMS 등이 그러하게 접근한다. 
-> thread 를 유지하면서 객체를 처리하므로, concurrent collectors 라고 부름. 
	또는, low-pause  (pauseless 가 아니다!) collectors.
-> 이의 반대는 throughput collectors

low-pause collector 의 trade off 는 그만큼 CPU 자원을 많이 소모한다는 것이다.
그리고 얘네라고 full GC 를 안하는 것도 아니다. 할 수도 있음.

##### considering trade off and choose right GC

1. 반응시간
각각의 request 는 긴 일시정지 시간에 (특히나 full gc 때) 에 영향을 받을 것. 
그러한 pause 로부터의 영향을 최소화하고 싶다면 concurrent collector를.

“If the average response time is more important than the outliers (i.e., the 90th% response time), ”
다른 무엇보다 평균 반응시간이 중요하다면 Throughput 을. (근데 )
-> i.e : id est -> 다시 말해, 즉.

-> 이때 outliers 는 보통 값들과 동떨어진 값을 의미함.

-> 그러니까 위의 말은, 10% 가 느린 것을 희생하여 90% 가 평균적으로 빨라지는 것이 더 중요하다면, 이라는 말.

2. CPU

cpu 가 부족한데 concurrent collector 를 쓰면 그만큼 batch job 이 느려진다.


##### Four different GC algorithms at JVM

- The Serial garbage collector

가장 간단한 알고리즘. client-class machine (아마 클라이언트 핫스팟 컴파일러를 사용하는 jvm 을 지칭하는 것으로 보임) 에 default 로 설정.

heap 을 처리하는데 cpu thread 한개 사용. 그리고 heap 처리시에, 모든 스레드를 stop 시킴.


- The throughput collector

server class machine 에 기본적으로 설정되어 있음.
minor gc 를 하는데 여러개의 thread 를 사용하여 더 빠르게 실행.
full gc 에도 여러개 사용할 수 있음.

여러개의 쓰레드를 쓰기 때문에 throughput collector 는 종종 parallel collector 라고도 불림.

얘는 minor gc , full gc 할 것 없이 할때마다 모든 쓰레드를 정지시키고,
full gc 때 old generation 을 완전히 압축시킨다.


- The CMS collector

CMS collector 는 full gc 때 long pause 가 발생하는 Serial, Throughput collector 를 대체하기 위해 디자인 되었다.
쓰레드를 minor GC 때는 여러개 사용하고 마찬가지로 모든 쓰레드를 중지시킴. 

full gc 때 모든 스레드를 중지시키는게 아니라, background 로 한개이상의 쓰레드를 이용해 old generation 을 처리한다.
-> 즉, minor gc 때만 all stop. 
-> 그런데 이게 compaction은 안한다. 즉, empty heap 이 점점더 파편화된다.
-> 이게 더 심해져서 더 이상 객체를 옮길 수 없게되면, serial collector 처럼 모든 스레드를 stop 하고 full gc 를 수행 - heap 을 압축한다.
 (이때는 한개의 쓰레드만 사용)

cpu 사용량 증가.


- The G1 collector

큰 heap (4gb 이상의) 에서의 pause 를 최소화하기 위한 알고리즘. 
generation 을 여전히 유지하지만, heap 을 여러개의 region 으로 나눔. 
여러개의 region 들이 young generation 을 이루고, 여전히 minor gc 가 일어날때 모든 스레드가 중지됨. 
(when minor gc occured - when young generation is collected)
그리고 CMS 와 똑같이 여러개의 스레드가 실행됨.

G1 collector 는 서바이버와 유사하게, region 으로 나뉜 old generation 를 백그라운드로 collect 하면서, 
동시에 남은 객체는 다른 region 으로 옮김으로써 full gc 시에는 프로세스가 일시정지 할일이 없도록 만듦.
즉, compaction 이 thread stop 없이 이루어짐.



## java.lang package

import 를 안해도 사용가능!

### 가끔 나타나는 에러


#### OutOfMemoryError (OOME)

-> 잘못 프로그래밍되어, 메모리가 부족한 경우

#### StackOverflowError

-> stack 에는 ==어떤 메소드가 어떤 메소드를 호출했는지== 에 대한 정보를 관리함.
-> 이를 통해, 메소드의 깊이가 너무 깊으면 발생하는 에러.


### Classes related to Number

-> ==기본 자료형 (primitive Type) 은 Heap 이 아니라, stack 에 저장된다==
-> 따라서, 계산시 빠른 처리가 가능.

-> Byte, Short, Integer ... (앞글자가 대문자)
-> 겉으로 보기에 참조자료형이지만, 컴파일러에서 자동으로 primitive type으로 형변환 해준다 -> 기본자료형 처럼 쓸 수 있다.
(그래서 앞전에 call by value 가 되었던 것.)


#### wrapper class
-> Character , Boolean 을 제외한 숫자를 처리하는 클래스들은 감싼 클래스라고 불림
-> Number 라는 abstract class 를 확장함.

-> 값이 너무 커서 보기 힘들면
```java
Integer.toBinaryString(Integer.MAX_VALUE);
Integer.toHexString(Integer.MAX_VALUE);
```





