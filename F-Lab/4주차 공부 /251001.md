

## 부동 소수점과 -0

[[250916#^b79a6d]] 에 이어서


부동 소수점은 부호 + 지수 + 가수 부분으로 나누어져 있다.
부호 가있기때문에 -0이 표현 가능하다.

-0을 가질 수 있는 1의 보수에서는 -0 때문에 하드웨어 구현 난이도의 증가, 불필요한 연산 등 안좋은 점이 많았지만
부동소수점의 -0은 유용한 기능을 가진다. 

부동 소수점은 소수를 나타내기때문에, 아주 작은 수를 표현할 수 있다.
이는 근사치를 표현할 수 있다는 얘기.
즉 극한을 표현할 수 있는데
-0 이 표현 가능하다는 것은 그 극한을 완성하는, 즉 -inf 을 표현할 수 있는 근거가 된다.

이는 수치해석이나 물리 시물레이션 등에서 '방향성 정보'를 나타낼 수 있는 것이다.

### 왜 +0과 -0이 유용한가?


IEEE 754 표준에서는 +0 과 -0을 구분해서 저장하므로

  $\lim _{x\to 0+\:}\left(\frac{1}{x}\right)=+∞$ , $\lim _{x\to 0-\:}\left(\frac{1}{x}\right)=-∞$ 

 등의 0에 "어느 방향에서 접근했는지"를 코드로도 표현할 수 있음.

실제로, 
$\frac{1}{+0}=+\infty$, $\frac{1}{-0}=-\infty$ 

가 나오고, 이건 수치해석이나 물리 시뮬레이션 등에서 방향성 정보를 보존하는 데 매우 유용하다.

```python
// python
print(1.0 / 0.0)   # inf
print(1.0 / -0.0)  # -inf
```

```java
// java
System.out.println(1.0 / 0.0);   // Infinity
System.out.println(1.0 / -0.0);  // -Infinity

```

#### 마인크래프트에서

(0, 0) 좌표는 4개의 블록이 교접하는 공간이 된다.
이때, 0,0 에 캐릭터가 접근할때, 어떤 방향에서 접근하는지를 알기 위해서는 -0, +0 의 구분이 필요함. 
어느쪽에서 접근했는지를 알아야 하기 때문.
그게 안된다면 정확한 위치 판정이 어렵다.

또한 블록의 표시에서

```javascript
function isNegZero(x) {
  return x === 0 && (1 / x === -Infinity);
}

function blockPosition(x, y) {
  // -0.0은 왼쪽/아래 블록, +0.0은 오른쪽/위 블록으로 판정
  const xSide = isNegZero(x) ? 'left' : 'right';
  const ySide = isNegZero(y) ? 'bottom' : 'top';
  return `${xSide} ${Math.abs(x)}, ${ySide} ${Math.abs(y)}`;
}

console.log(blockPosition(-0.0, 0.0)); // left 0, top 0
console.log(blockPosition(0.0, -0.0)); // right 0, bottom 0
```
즉 +0, -0 이 있어야 0,0 지점에서 맞물려있는 블록 4개를 정확하게 표현할 수 있음.
그렇지 않으면 버그 발생.


#### 수학 - 허수에서

```python
import cmath
z = complex(-1, 0.0)
print(cmath.sqrt(z))      # 0j + 1j

z_neg = complex(-1, -0.0)
print(cmath.sqrt(z_neg))  # 0j - 1j
```

```python
import cmath
z1 = complex(-2.0, 0.0)    # branch cut 위, 위에서 접근
z2 = complex(-2.0, -0.0)   # branch cut 위, 아래에서 접근

print(cmath.sqrt(z1))      # 1.4142135623730951j
print(cmath.sqrt(z2))      # -1.4142135623730951j
```

허수부의 −0.0−0.0이 실제로 결과의 방향을 결정한다.
-> 복소수의 제곱근을 몰라 이해 못했음.



## ThreadLocal

ThreadLocal 이란, 쓰레드가 공통된 객체를 통해 다른 쓰레드와는 공유되지 않는 독자적인 공간에 값을 저장할 수 있게 만들어 주는 도구라고 볼 수 있다.

Spring 을 예시로 들자면, Thread 는 Request 가 들어오면 Tomcat 의 Thread Pool 에서 해당 request 를 위한 Thread 가 생성된다. (이 Thread 를 WorkThread 라고 부름)

이 workThread 는 하나의 스프링어플리케이션에서 여러개 있을 수 있고, 이 쓰레드들은 static 으로 선언된 ThreadLocal 변수에 대해

Thread 객체의 set, get 을 호출하여 쓰레드마다 임의의 객체를 저장할 수 있고,
이 객체들은 각자의 Thread 메모리 공간에 저장되며, 다른 쓰레드와 그 공간을 공유하지 않는다.

ThreadLocal 을 사용할 경우 각 쓰레드에는 ThreadLocalMap 이라는 곳에 관련된 정보가 저장된다.

### spring  예시

```java
@Component
public class MyWorker {
    public static ThreadLocal<String> threadLocal1 = new ThreadLocal<>();
    public static ThreadLocal<Integer> threadLocal2 = new ThreadLocal<>();

    public void process(String str, Integer num) {
        threadLocal1.set(str);
        threadLocal2.set(num);
        // 실제 작업
    }

    public String fetchThreadLocal1() {
        return threadLocal1.get();
    }
    public Integer fetchThreadLocal2() {
        return threadLocal2.get();
    }
}
```

MyWorker 는 @Component 이기때문에 Spring의 singleton bean 으로 spring 어플리케이션동안 객체가 존재한다.

```java
@Service
public class MainService {
    @Async
    public void workInThread(String name, Integer count) {
        MyWorker worker = new MyWorker();
        worker.process(name, count);
        // ThreadLocal 값 사용
    }
}

...
mainService.workInThread("foo", 100); // worker thread-1
mainService.workInThread("bar", 200); // worker thread-2
...

```

결과값.

| ThreadName      | Key (ThreadLocal instance) | Value |
| --------------- | -------------------------- | ----- |
| worker-thread-1 | threadLocal1               | "foo" |
|                 | threadLocal2               | 123   |
| worker-thread-2 | threadLocal1               | "bar" |
|                 | threadLocal2               | 456   |
각 쓰레드에 대해서, ThreadLocalMap 에는 ThreadLocal 변수 명이 Key, Value 는 그 변수에 저장된 객체가 된다.


### 의문점 - Thread instance variable

Runnable interface 를 구현하는 Thread 의 객체에는 instance variable 을 설정해
각 객체마다 다른 쓰레드 객체와는 공유하지 않은 고유의 변수, 즉 메모리 - 객체를 저장할 수 있는데
왜 굳이 ThreadLocal 을 쓰는가?

왜냐하면, Spring Application 과 같은 다중 쓰레드 환경에서는
적어도 Spring 에서는, Framework 에서 쓰레드를 설정하지 쓰레드 자체를 개발자가 개조하지 않기 떄문이다.

Tomcat Thread Pool 에서 Request 에 생성되는 쓰레드에 대해서 개발자가 해당 쓰레드의 instance variable 을 추가할 수가 없다.

Spring Aplpication 에서는 ThreadPool 이 Thread 를 직접 생성 및 관리한다.
Spring이 일아서 한다. (개발자가 `new Thread()` 로 선언하여 생성하지 않는다는 얘기.)

만약 Spring Application code 에서 new Thread() 를 사용하면,
일반적인 하나의 자바 소스코드와는 다르게 

WorkThread 에서 해당 Thread 를 호출, 생성하는 것이므로
Request 2개에 대해 각 workThread 가 임의의 쓰레드를 2개씩 생성하면
총 6개의 쓰레드가 생성이 되나
이 새로 생성된 쓰레드는 사실상 의미가 없다.
그리고 사용하더라도 관리가 힘들다 (그럴 것으로 예상된다. 그리고 어따가 써먹게?)

또한, Spring 빈/컨트롤러/서비스는 싱글톤 개념을 기반으로 사용되며 Thread 생명주기와 별도로 관리된다.
만약 Thread 객체에 직접 인스턴스 변수를 넣으면, Spring 구조(빈, DI, IoC)와 전혀 상관없으므로 프레임워크 설계상 추천되지 않는다.
(즉 앞뒤가 안맞는다.)


즉, Spring Application 에서 어떤 쓰레드가 쓰레드만의 변수, 메모리 공간을 가지기 위해서는
ThreadLocal 이 가장 크게 유용한 수단이다.

다른 수단들도 있긴한데 ThreadLocal 에 비해서 단점이 명확하고 크다.

#### Spring 에서의 다른 수단

- **Request/Session/Prototype Scope Bean**  
    Spring에서 @Scope("request") 또는 @Scope("prototype")을 사용하면 요청마다 혹은 인스턴스마다 새로운 bean을 생성할 수 있음.
    단, child thread에는 scope가 전파되지 않아 한계가 명확.
    
- **동기화 (synchronized, Lock)**  
    멤버 변수 공유를 막으려면 동기화 기법, java.util.concurrent 컬렉션 등으로 동시에 한 쓰레드만 접근하도록 제어할 수 있음.
    그러나, thread별로 분리되는 게 아니고 state 자체가 공유되어 thread 안전만 보장하는 수준.
    
- **불변 객체(Immutable Object) 활용**  
    상태를 아예 변경 불가능하게 두고, 필요한 새 값을 복사해 전달함.  
    단, 각 thread별로 상태값이 달라야 하는 상황에서는 실질적으로 곤란.
    
- **JDK 20+ ScopedValue**  
    ThreadLocal을 대체하는 ScoppedValue라는 새로운 기능(JDK20 이상)이 존재하며, 지정된 코드 block 내에서 thread별로 값을 세팅할 수 있습니다.  
    아직 Spring 등에서 상용패턴으로는 널리 쓰이지 않습니다.
    
- **Actor/Message Passing 방식 적용**  
    Akka 등 Actor 모델을 써서, 아예 상태 공유하지 않고 메시지 패싱으로 격리.  
    Spring 기존 구조와는 동떨어져 있고, 전면 아키텍처 대체에 가까움.

-> 각 방법에 대해서는 아직 잘 모른다.

