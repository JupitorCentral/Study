## Map 

3주차 공부 [[250922]] 에 이어서

From neetcode top-k-elements solution
[[250922 needcode top-k-elements]]

```java
public int[] topKFrequent(int[] nums, int k) {  
  
    int[] answer = new int[k];  
  
    Map<Integer, Integer> map = new HashMap<>();  
    for (int i=0; i<nums.length; i++) {  
        int x = nums[i];  
        map.merge(x, 1, Integer::sum);  
    }  
  
    List<Integer> sorted = map.entrySet()
						.stream()
						.sorted(
							Map.Entry.<Integer, Integer>comparingByValue()
								.reversed()
								)  
					    .map(Map.Entry::getKey)  
					    .toList();            // 수정
  
    for (int i=0; i<k; i++) {  
        answer[i] = sorted.get(i);  
    }  
    return answer;  
}
```

```java

1. map -> Map <Integer, Integer> 

2. map.entrySet() -> Set<Map.Entry<K, V>> 
   (Map.entrySet)
   
3. stream() -> Stream<Entry<Integer, Integer>>
   (Set.stream)

4. Map.Entry.<Integer, Integer>comparingByValue().

5. Stream.sorted()
```


### 중첩 interface

```java
interface Outer {
    interface Inner {
        void method();
    }
}
// 구현할 때: class MyClass implements Outer.Inner { ... }
```

중첩된 interface 는 하나의 정의된 interface 단순히 안에 선언된 interface 이다.
이 interface 들은 자동적으로 static interface 가 된다.

#### 그러면 top-level interface 는 static 이 아닌가 ?

아니다. 하지만, interface 안에는 static method 를 선언함과 동시에 구현할 수 있으며, 이는
interface 에 대한 instance 가 존재하지 않아도 호출할 수 있다.

```java
interface MyInterface {
    static void hello() {
        System.out.println("Hello!");
    }
}
MyInterface.hello(); // 인스턴스 없이 호출 가능
```
실험해봤는데 진짜 그렇다.

이 내용들을 이해하기 위해선, interface 와 abstract class 에 관한 공부가 필요하다.

#### 왜 쓰는가 ? 

- 캡슐화와 네이밍 스페이스의 쉬운 관리
- 인터페이스나 기능을 논리적으로 묶어 코드관리를 쉽게하기 위함

위 예시 Map.Entry 는 오직 Map 과 관련된 key-value 쌍을 의미하므로 Map 안에 중첩되서 선언함.


### interface


#### method 

interface 는 기능 명세서와 비슷하다. 어떤 것을 구현하고자 하는지 메서드들을 선언할 수 있고,
이의 쓰임새는 interface 를 상속받은 클래스에서 선언되어 있는 메서드를 구현한다.

근데 자바 8 에서부터는 interface 에서도 구현이 가능한 것이었다. 위의 예시처럼.

##### default method vs static method

default method 는 구현이 가능하며, override 될 수 있다.
instance method 이기 때문에, 구현체에서 객체를 만들어야 사용할 수 있다.
그리고 당연한 얘기지만, default method 를 override 할때 public 이나 static 같은 modifier 를 추가/변경할 수는 없다.


반면 static method 는 구현해야 하며 (must have body), override 될 수 없다.
대신, 클래스의 static method 처럼 import 만 하면 사용할 수 있다.

| Feature         | Default Method  | Static Method        |
| --------------- | --------------- | -------------------- |
| Can override?   | Yes             | No                   |
| Called on       | Instance        | Interface            |
| Must implement? | No (optional)   | Yes (must have body) |
| Purpose         | Common behavior | Utility/helper       |


#### field

그리고 상수를 선언할 수 있는데, 암묵적으로 public static final 타입이 되며, 
final 이므로 선언과 동시에 값을 선언, 즉 상수가 된다.



#### import

인터페이스는 같은 패키지에 있으면 import 없이 사용가능하고, 
다른 패키지에 있으면 import 를 해야 한다.



#### difference between interface and class

interface 는 static variable, static method 를 가질 수 있기때문에
static class 와 비슷한 점이 있고, 무슨 차이점이 있는지 궁금하게 될만 하다.

interface 의 static method 는 선언과 동시에 반드시 구현해야 하며 (must have body),
interface 를 상속한 구현체의 instance 에서 호출할 수 없음.
```java
MyInterfaceImpl impl = new MyInterfaceImpl();  
impl.hello();          -> 'compile ERROR'
```

interface 는 '상태', 즉 변경되는 값을 가질 수 없음 (무조건 public static final)

또 interface 는 다중 구현 가능 (implements multiple interfaces), 
클래스는 상속 한개만 가능 (물론 클래스도 여러개의 interface 를 implements 할 수 있음)


### abstract class

-> interface 내부에서 정의가 가능하고, 그때는 'public' 이 무의미하다 (어쨌든 무조건 public 하다는 의미)

상속 : 하나의 abstract class 만 가능. 그리고 일반 class 를 상속할 수 있음. 
	그리고 마찬가지로 여러개의 interface 를 implements 할 수 있음

상태 : 일반 class 와 마찬가지
메소드 : 일부 메소드를 abstract, 즉 body 없이 정의할 수 있음 (interface 처럼).
	그런데 일부 메소드는 구현 가능
	__
	static method 의 경우, interface 처럼 반듯 구현해야 함. 
	즉  abstract static method 가 불가능.

참고로 abstract class 는 abstract static method 선언이 불가능하다.

```java
abstract class foo {
    abstract void bar( );                  // <-- this is ok
    abstract static void bar2();        //<-- compile error
}
```

사실 따지고 보면 당연한 이야기이다. 'abstract' 로 선언하겠다는건 구현을 하지 않겠다는 의미인데,
(구현을 구현체에 맡기겠다는 의미인데)
static 메서드 자체는 선언과 동시에 구현을 해야하니 말이다.

static method 와는 다르다 !

#### hiding vs overriding

그리고 static method 는 overriding 이 불가능하고 '숨김' 만 가능함.

> If a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass _hides_ the one in the superclass.
> 
> The distinction between hiding a static method and overriding an instance method has important implications:
>
> - The version of the overridden instance method that gets invoked is the one in the subclass.
> - The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.

(from docs.oracle.com, Java tutorial)

만약 subclass 가 상위 클래스의 동일한 signature 로 static method 를 호출하면, 하위 클래스의 method 가 상위 클래스의 것을 'hide' 함.

static method 를 hiding 것과, instance method 를 overring 하는 것은 2가지 중요한 차이점이 있는데

- override 된 메서드 (instance method) 는 호출이 될때 subclass 의 것이 호출됨
- hide 된 static method 의 version 은, 그것이 superclass 에서 호출됬는지 아님 상위클래스에서 호출되었는지에 달려있다.


```java
class Animal {  
    public void testInstanceMethod() { System.out.println("Animal"); }  
    public static void testClassMethod() { System.out.println("Animal"); }  
}  
class Cat extends Animal {  
    public void testInstanceMethod() { System.out.println("Cat"); }  
    public static void testClassMethod() { System.out.println("Cat"); }  
}  
  
  
public void test () {  
    Animal animal = new Cat();  
    Cat cat = new Cat();  
  
    animal.testInstanceMethod();  
    cat.testInstanceMethod();  
  
    animal.testClassMethod();  
    cat.testClassMethod();  
  
    Animal.testClassMethod();  
    Cat.testClassMethod();  
}
```

```java
Cat
Cat
Animal
Cat
Animal
Cat
```


1. 첫번째 줄 출력 : Cat -> `animal.testInstanceMethod();`
    - `animal`의 실제 객체는 `new Cat()`이므로, 오버라이딩된 Cat의 인스턴스 메서드가 호출됨. (다형성, 런타임 객체 기준)
        
2. 두번째 줄 출력 : Cat -> `cat.testInstanceMethod();
    - `cat`은 Cat 타입이면서 Cat 객체이므로, Cat의 인스턴스 메서드가 호출됨.
        
3. 세번째 줄 출력 : Animal -> `animal.testClassMethod();`
    - static method는 참조 변수 타입(`Animal`) 기준으로 호출됨. hiding 현상. (오버라이딩 아님)
        
4. 네번째 줄 출력 : Cat -> `cat.testClassMethod();`
    - static method는 참조 변수 타입(`Cat`) 기준으로 호출됨. hiding 현상.
        
5. 다섯번째 줄 출력 : Cat -> `Animal.testClassMethod();`
    - 클래스명으로 직접 호출하므로 Animal의 static method가 호출됨.
        
6. 여섯번째 줄 출력 : Cat -> `Cat.testClassMethod();`
    - 클래스명으로 직접 호출하므로 Cat의 static method가 호출됨.


즉 method 가 참조 객체의 타입 (객체가 선언된 타입) 을 따라가느냐, 아니면
실제 객체의 것을 따라가느냐 (런타임, 다형성) 가 hiding 과 overriding 의 차이인 것.



#### overriding or hiding at interface ?


그리고 interface 에 있는 static method 와 같은 signature 를 갖는 static method 를
구현체에서 선언하는 것은 overriding 이나 hide 와 전혀 관계가 없음. 둘 다 불가능.

```java
interface MyInterface {
    static void hello() { System.out.println("Interface static"); }
}
class MyClass implements MyInterface {
    static void hello() { System.out.println("Class static"); }
}
MyInterface.hello(); // "Interface static"
MyClass.hello();     // "Class static"
```
-> 전혀 독립적으로 동작.




### 그럼 import 할때 일어나는 일들은...

패키지의 클래스를 로딩하는 것은 compiler 의 작업이다. 
그리고 자바에서 컴파일 과정을 좀 공부해야 할 것 같다.






### 다시 Map.Entry.<Integer, Integer>comparingByValue() 로 돌아와서...





## JIT


CPU 는 비교적 적은, 특정한 명령어만 실행이 가능하며, 이는 assembly 또는 binary 코드등이다.
CPU 가 실행하는 모든 프로그램은 결국 이러하나 코드들로 변환되어야 한다.

C++ 같은 언어는 compiled language 라고 불리는데, 왜나하면 생성된 프로그램은 binary code 들로 전달되기 때문.

### C/C++ 의 컴파일 과정

#### **1단계: 전처리 (Preprocessing)**
- `#include`, `#define` 등 전처리기 지시문 처리

(main.c)
```c
#include <stdio.h>
#define PI 3.14159
#define SQUARE(x) ((x) * (x))

int main() {
    printf("Area of circle: %f\n", PI * SQUARE( 5 ));
    return 0;
}
```

전처리 후 ( main.i )
```c
// stdio.h의 모든 내용이 여기에 삽입됨 (약 1000줄)
extern int printf (const char *__restrict __format, ...);
// ... 수백 줄의 stdio.h 내용들 ...

int main() {
    printf("Area of circle: %f\n", 3.14159 * (( 5 ) * ( 5 ));
    return 0;
}
```

전처리가 여기서 하는 행동

- `#include <stdio.h>` → stdio.h 파일 내용 전체 삽입
- `#define PI 3.14159` → PI를 3.14159로 치환
- `#define SQUARE(x) ((x) * (x))` → SQUARE(5)를 ((5) * (5))로 치환
-  주석 제거, 공백 정리


#### **2단계: 컴파일 (Compilation)**
- 전처리된 소스 코드 → 어셈블리 코드 변환

(main.s)
```c
.text
.globl main
main:
    pushq   %rbp              # 스택 프레임 설정
    movq    %rsp, %rbp        # 베이스 포인터 설정
    
    movl    $78, %esi         # 78.539750 (PI * 25)를 정수부분만
    movl    $.LC0, %edi       # "Area of circle: %f\n" 문자열 주소
    movl    $1, %eax          # printf 호출을 위한 레지스터 설정
    call    printf            # printf 함수 호출
    
    movl    $0, %eax          # return 0
    popq    %rbp              # 스택 정리
    ret                       # 함수 종료

.section .rodata
.LC0:
    .string "Area of circle: %f\n"
```

아직 사람이 binary 에 비해서 좀 더 잘 읽을 수 있음

컴파일러가 수행하는 작업:

- 구문 분석: C 문법 검사, AST(추상 구문 트리) 생성
- 의미 분석: 타입 체킹, 변수 범위 검사
- 최적화: 상수 계산 미리 수행 (PI * 25 = 78.539...)
- 코드 생성: CPU 명령어(어셈블리)로 변환

여기서 최적화가 되어있는지 확인할 수가 있다.

#### **3단계: 어셈블링 (Assembling)**

- 어셈블리 코드 → **오브젝트 파일(.obj 또는 .o)**로 변환    
- 이때 ==기계어==로 번역되지만 실행 불가능한 상태

(main.o)
```c
ELF Header (바이너리):
7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00

Machine Code Section (.text):
55                           pushq %rbp
48 89 e5                movq %rsp, %rbp  
be 4e 00 00 00  movl $78, %esi
bf 00 00 00 00  movl $.LC0, %edi
b8 01 00 00 00  movl $1, %eax
e8 00 00 00 00  call printf
b8 00 00 00 00  movl $0, %eax
5d                           popq %rbp
c3                           ret

Data Section (.rodata):
41 72 65 61 20 6f 66 20 63 69 72 63 6c 65 3a 20
25 66 0a 00     # "Area of circle: %f\n"

Symbol Table:
Name: main, Section: .text, Offset: 0x0
Name: printf, Section: UNDEFINED, Offset: 0x0  # 외부 함수
```

어셈블러가 수행하는 작업:

- **명령어 인코딩**: `pushq %rbp` → `55` (1바이트 기계어)    
- **주소 계산**: 레이블들을 실제 오프셋으로 변환
- **심볼 테이블 생성**: 함수명, 변수명과 주소 매핑
- **재배치 정보**: 아직 확정되지 않은 주소들 표시


#### **4단계: 링킹 (Linking)**

- 여러 오브젝트 파일들을 하나로 합침
- **정적 라이브러리(.lib 또는 .a)** 코드와 병합
- 외부 함수 참조를 실제 주소로 연결
- 최종 **실행 파일(.exe)**을 생성

```c
// 링커가 결합하는 파일들
main.o          # 우리가 만든 오브젝트 파일
libc.a          # C 표준 라이브러리 (printf 함수 포함)
crt0.o          # 프로그램 시작 코드
```

(main.exe)
```c
ELF Header + Program Headers:
Entry Point: 0x401000  # main 함수 시작 주소

.text Section (Virtual Address: 0x401000):
401000: 55                             pushq %rbp
401001: 48 89 e5                   movq %rsp, %rbp
401004: be 4e 00 00 00    movl $78, %esi
401009: bf 10 20 40 00      movl $0x402010, %edi  # 문자열 실제 주소
40100e: b8 01 00 00 00     movl $1, %eax
401013: e8 20 00 00 00      call 0x401033        # printf 실제 주소
401018: b8 00 00 00 00     movl $0, %eax
40101d: 5d                              popq %rbp
40101e: c3                               ret

401033: # printf 함수 기계어 코드 (라이브러리에서 복사됨)
...

.rodata Section (Virtual Address: 0x402010):
402010: "Area of circle: %f\n"

```

링커가 수행하는 작업:

- 심볼 해결: printf → 실제 주소 0x401033으로 연결
- 주소 재배치: 모든 상대 주소를 절대 주소로 변환
- 정적 라이브러리 코드 삽입: libc.a에서 printf 코드 복사
- 메모리 레이아웃 결정: 각 섹션의 가상 메모리 주소 할당


#### 각 단계별 파일크기 변화

```java
main.c        →  약 150 바이트
main.i        →  약 50,000 바이트 (헤더 파일 포함)
main.s        →  약 500 바이트
main.o        →  약 2,000 바이트 (메타데이터 포함)
main.exe      →  약 20,000 바이트 (라이브러리 코드 포함)
```

#### 정적 링킹 특징

- 컴파일 시점에 라이브러리 코드가 실행 파일에 완전히 포함됨
- 실행 파일 크기가 커지지만 독립적으로 실행 가능
- 런타임에 추가 외부 라이브러리 파일이 필요 없음


그래서 c/cpp 는 source code -> 전처리 ->  assembly code -> assembling (실제 주소 계산 등, 기계어 이나 실행 불가능)
-> 링킹 (여러 라이브러 합침 등) -> exe 파일

그러니까 cpu 가 직접 실행할 수 있는 기계어의 집합

그렇다면 Java 의 compile 과 무슨 차이가 있을까?
Java 는 JVM 이라는 미들웨어가 JIT 를 이용하여, Java 파일이 컴파일되어 나온 class 파일을
JVM 이 실행 , JVM이 JIT 를 이용하여 기계어로 변환하여 CPU 가 실행하게 된다.

