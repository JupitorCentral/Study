## Map.EntrySet

3주차 공부 [[250922]] 에 이어서

From neetcode top-k-elements solution
[[250922 needcode top-k-elements]]

```java
public int[] topKFrequent(int[] nums, int k) {  
  
    int[] answer = new int[k];  
  
    Map<Integer, Integer> map = new HashMap<>();  
    for (int i=0; i<nums.length; i++) {  
        int x = nums[i];  
        map.merge(x, 1, Integer::sum);  
    }  
  
    List<Integer> sorted = map.entrySet()
						.stream()
						.sorted(
							Map.Entry.<Integer, Integer>comparingByValue()
								.reversed()
								)  
					    .map(Map.Entry::getKey)  
					    .toList();            // 수정
  
    for (int i=0; i<k; i++) {  
        answer[i] = sorted.get(i);  
    }  
    return answer;  
}
```

```java

1. map -> Map <Integer, Integer> 

2. map.entrySet() -> Set<Map.Entry<K, V>> 
   (Map.entrySet)
   
3. stream() -> Stream<Entry<Integer, Integer>>
   (Set.stream)

4. Map.Entry.<Integer, Integer>comparingByValue().

5. Stream.sorted()
```


### 중첩 interface

```java
interface Outer {
    interface Inner {
        void method();
    }
}
// 구현할 때: class MyClass implements Outer.Inner { ... }
```

중첩된 interface 는 하나의 정의된 interface 단순히 안에 선언된 interface 이다.
이 interface 들은 자동적으로 static interface 가 된다.

#### 그러면 top-level interface 는 static 이 아닌가 ?

아니다. 하지만, interface 안에는 static method 를 선언함과 동시에 구현할 수 있으며, 이는
interface 에 대한 instance 가 존재하지 않아도 호출할 수 있다.

```java
interface MyInterface {
    static void hello() {
        System.out.println("Hello!");
    }
}
MyInterface.hello(); // 인스턴스 없이 호출 가능
```
실험해봤는데 진짜 그렇다.

이 내용들을 이해하기 위해선, interface 와 abstract class 에 관한 공부가 필요하다.

#### 왜 쓰는가 ? 

- 캡슐화와 네이밍 스페이스의 쉬운 관리
- 인터페이스나 기능을 논리적으로 묶어 코드관리를 쉽게하기 위함

위 예시 Map.Entry 는 오직 Map 과 관련된 key-value 쌍을 의미하므로 Map 안에 중첩되서 선언함.


### interface

^5a027d

#### method 

interface 는 기능 명세서와 비슷하다. 어떤 것을 구현하고자 하는지 메서드들을 선언할 수 있고,
이의 쓰임새는 interface 를 상속받은 클래스에서 선언되어 있는 메서드를 구현한다.

근데 자바 8 에서부터는 interface 에서도 구현이 가능한 것이었다. 위의 예시처럼.

##### default method vs static method

default method 는 구현이 가능하며, override 될 수 있다.
instance method 이기 때문에, 구현체에서 객체를 만들어야 사용할 수 있다.
그리고 당연한 얘기지만, default method 를 override 할때 public 이나 static 같은 modifier 를 추가/변경할 수는 없다.


반면 static method 는 구현해야 하며 (must have body), override 될 수 없다.
대신, 클래스의 static method 처럼 import 만 하면 사용할 수 있다. (소스 코드에서 해당 interface 를 import 만 하면 된다는 소리)

| Feature         | Default Method  | Static Method        |
| --------------- | --------------- | -------------------- |
| Can override?   | Yes             | No                   |
| Called on       | Instance        | Interface            |
| Must implement? | No (optional)   | Yes (must have body) |
| Purpose         | Common behavior | Utility/helper       |


#### field

그리고 상수를 선언할 수 있는데, 암묵적으로 public static final 타입이 되며, 
final 이므로 선언과 동시에 값을 선언, 즉 상수가 된다.



#### import

인터페이스는 같은 패키지에 있으면 import 없이 사용가능하고, 
다른 패키지에 있으면 import 를 해야 한다.



#### difference between interface and class

interface 는 static variable, static method 를 가질 수 있기때문에
static class 와 비슷한 점이 있고, 무슨 차이점이 있는지 궁금하게 될만 하다.

interface 의 static method 는 선언과 동시에 반드시 구현해야 하며 (must have body),
interface 를 상속한 구현체의 instance 에서 호출할 수 없음.
```java
MyInterfaceImpl impl = new MyInterfaceImpl();  
impl.hello();          -> 'compile ERROR'
```

interface 는 '상태', 즉 변경되는 값을 가질 수 없음 (무조건 public static final)

또 interface 는 다중 구현 가능 (implements multiple interfaces), 
클래스는 상속 한개만 가능 (물론 클래스도 여러개의 interface 를 implements 할 수 있음)


### abstract class

-> interface 내부에서 정의가 가능하고, 그때는 'public' 이 무의미하다 (어쨌든 무조건 public 하다는 의미)

상속 : 하나의 abstract class 만 가능. 그리고 일반 class 를 상속할 수 있음. 
	그리고 마찬가지로 여러개의 interface 를 implements 할 수 있음

상태 : 일반 class 와 마찬가지
메소드 : 일부 메소드를 abstract, 즉 body 없이 정의할 수 있음 (interface 처럼).
	그런데 일부 메소드는 구현 가능
	__
	static method 의 경우, interface 처럼 반듯 구현해야 함. 
	즉  abstract static method 가 불가능.

참고로 abstract class 는 abstract static method 선언이 불가능하다.

```java
abstract class foo {
    abstract void bar( );                  // <-- this is ok
    abstract static void bar2();        //<-- compile error
}
```

사실 따지고 보면 당연한 이야기이다. 'abstract' 로 선언하겠다는건 구현을 하지 않겠다는 의미인데,
(구현을 구현체에 맡기겠다는 의미인데)
static 메서드 자체는 선언과 동시에 구현을 해야하니 말이다.

static method 와는 다르다 !

#### hiding vs overriding

그리고 static method 는 overriding 이 불가능하고 '숨김' 만 가능함.

> If a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass _hides_ the one in the superclass.
> 
> The distinction between hiding a static method and overriding an instance method has important implications:
>
> - The version of the overridden instance method that gets invoked is the one in the subclass.
> - The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.

(from docs.oracle.com, Java tutorial)

만약 subclass 가 상위 클래스의 동일한 signature 로 static method 를 호출하면, 하위 클래스의 method 가 상위 클래스의 것을 'hide' 함.

static method 를 hiding 것과, instance method 를 overring 하는 것은 2가지 중요한 차이점이 있는데

- override 된 메서드 (instance method) 는 호출이 될때 subclass 의 것이 호출됨
- hide 된 static method 의 version 은, 그것이 superclass 에서 호출됬는지 아님 상위클래스에서 호출되었는지에 달려있다.


```java
class Animal {  
    public void testInstanceMethod() { System.out.println("Animal"); }  
    public static void testClassMethod() { System.out.println("Animal"); }  
}  
class Cat extends Animal {  
    public void testInstanceMethod() { System.out.println("Cat"); }  
    public static void testClassMethod() { System.out.println("Cat"); }  
}  
  
  
public void test () {  
    Animal animal = new Cat();  
    Cat cat = new Cat();  
  
    animal.testInstanceMethod();  
    cat.testInstanceMethod();  
  
    animal.testClassMethod();  
    cat.testClassMethod();  
  
    Animal.testClassMethod();  
    Cat.testClassMethod();  
}
```

```java
Cat
Cat
Animal
Cat
Animal
Cat
```


1. 첫번째 줄 출력 : Cat -> `animal.testInstanceMethod();`
    - `animal`의 실제 객체는 `new Cat()`이므로, 오버라이딩된 Cat의 인스턴스 메서드가 호출됨. (다형성, 런타임 객체 기준)
        
2. 두번째 줄 출력 : Cat -> `cat.testInstanceMethod();
    - `cat`은 Cat 타입이면서 Cat 객체이므로, Cat의 인스턴스 메서드가 호출됨.
        
3. 세번째 줄 출력 : Animal -> `animal.testClassMethod();`
    - static method는 참조 변수 타입(`Animal`) 기준으로 호출됨. hiding 현상. (오버라이딩 아님)
        
4. 네번째 줄 출력 : Cat -> `cat.testClassMethod();`
    - static method는 참조 변수 타입(`Cat`) 기준으로 호출됨. hiding 현상.
        
5. 다섯번째 줄 출력 : Cat -> `Animal.testClassMethod();`
    - 클래스명으로 직접 호출하므로 Animal의 static method가 호출됨.
        
6. 여섯번째 줄 출력 : Cat -> `Cat.testClassMethod();`
    - 클래스명으로 직접 호출하므로 Cat의 static method가 호출됨.


즉 method 가 참조 객체의 타입 (객체가 선언된 타입) 을 따라가느냐, 아니면
실제 객체의 것을 따라가느냐 (런타임, 다형성) 가 hiding 과 overriding 의 차이인 것.



#### overriding or hiding at interface ?


그리고 interface 에 있는 static method 와 같은 signature 를 갖는 static method 를
구현체에서 선언하는 것은 overriding 이나 hide 와 전혀 관계가 없음. 둘 다 불가능.

```java
interface MyInterface {
    static void hello() { System.out.println("Interface static"); }
}
class MyClass implements MyInterface {
    static void hello() { System.out.println("Class static"); }
}
MyInterface.hello(); // "Interface static"
MyClass.hello();     // "Class static"
```
-> 전혀 독립적으로 동작.




### 그럼 import 할때 일어나는 일들은...

패키지의 클래스를 로딩하는 것은 compiler 의 작업이다. 
그리고 자바에서 컴파일 과정을 좀 공부해야 할 것 같다.



## JIT - Compilation of JAVA


CPU 는 비교적 적은, 특정한 명령어만 실행이 가능하며, 이는 assembly 또는 binary 코드등이다.
CPU 가 실행하는 모든 프로그램은 결국 이러하나 코드들로 변환되어야 한다.

C++ 같은 언어는 compiled language 라고 불리는데, 왜나하면 생성된 프로그램은 binary code 들로 전달되기 때문.

### C/C++ 의 컴파일 과정

#### **1단계: 전처리 (Preprocessing)**
- `#include`, `#define` 등 전처리기 지시문 처리

(main.c)
```c
#include <stdio.h>
#define PI 3.14159
#define SQUARE(x) ((x) * (x))

int main() {
    printf("Area of circle: %f\n", PI * SQUARE( 5 ));
    return 0;
}
```

전처리 후 ( main.i )
```c
// stdio.h의 모든 내용이 여기에 삽입됨 (약 1000줄)
extern int printf (const char *__restrict __format, ...);
// ... 수백 줄의 stdio.h 내용들 ...

int main() {
    printf("Area of circle: %f\n", 3.14159 * (( 5 ) * ( 5 ));
    return 0;
}
```

전처리가 여기서 하는 행동

- `#include <stdio.h>` → stdio.h 파일 내용 전체 삽입
- `#define PI 3.14159` → PI를 3.14159로 치환
- `#define SQUARE(x) ((x) * (x))` → SQUARE(5)를 ((5) * (5))로 치환
-  주석 제거, 공백 정리


#### **2단계: 컴파일 (Compilation)**
- 전처리된 소스 코드 → 어셈블리 코드 변환

(main.s)
```c
.text
.globl main
main:
    pushq   %rbp              # 스택 프레임 설정
    movq    %rsp, %rbp        # 베이스 포인터 설정
    
    movl    $78, %esi         # 78.539750 (PI * 25)를 정수부분만
    movl    $.LC0, %edi       # "Area of circle: %f\n" 문자열 주소
    movl    $1, %eax          # printf 호출을 위한 레지스터 설정
    call    printf            # printf 함수 호출
    
    movl    $0, %eax          # return 0
    popq    %rbp              # 스택 정리
    ret                       # 함수 종료

.section .rodata
.LC0:
    .string "Area of circle: %f\n"
```

아직 사람이 binary 에 비해서 좀 더 잘 읽을 수 있음

컴파일러가 수행하는 작업:

- 구문 분석: C 문법 검사, AST(추상 구문 트리) 생성
- 의미 분석: 타입 체킹, 변수 범위 검사
- 최적화: 상수 계산 미리 수행 (PI * 25 = 78.539...)
- 코드 생성: CPU 명령어(어셈블리)로 변환

여기서 최적화가 되어있는지 확인할 수가 있다.

#### **3단계: 어셈블링 (Assembling)**

- 어셈블리 코드 → **오브젝트 파일(.obj 또는 .o)**로 변환    
- 이때 ==기계어==로 번역되지만 실행 불가능한 상태

(main.o)
```c
ELF Header (바이너리):
7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00

Machine Code Section (.text):
55                           pushq %rbp
48 89 e5                movq %rsp, %rbp  
be 4e 00 00 00  movl $78, %esi
bf 00 00 00 00  movl $.LC0, %edi
b8 01 00 00 00  movl $1, %eax
e8 00 00 00 00  call printf
b8 00 00 00 00  movl $0, %eax
5d                           popq %rbp
c3                           ret

Data Section (.rodata):
41 72 65 61 20 6f 66 20 63 69 72 63 6c 65 3a 20
25 66 0a 00     # "Area of circle: %f\n"

Symbol Table:
Name: main, Section: .text, Offset: 0x0
Name: printf, Section: UNDEFINED, Offset: 0x0  # 외부 함수
```

어셈블러가 수행하는 작업:

- **명령어 인코딩**: `pushq %rbp` → `55` (1바이트 기계어)    
- **주소 계산**: 레이블들을 실제 오프셋으로 변환
- **심볼 테이블 생성**: 함수명, 변수명과 주소 매핑
- **재배치 정보**: 아직 확정되지 않은 주소들 표시


#### **4단계: 링킹 (Linking)**

- 여러 오브젝트 파일들을 하나로 합침
- **정적 라이브러리(.lib 또는 .a)** 코드와 병합
- 외부 함수 참조를 실제 주소로 연결
- 최종 **실행 파일(.exe)**을 생성

```c
// 링커가 결합하는 파일들
main.o          # 우리가 만든 오브젝트 파일
libc.a          # C 표준 라이브러리 (printf 함수 포함)
crt0.o          # 프로그램 시작 코드
```

(main.exe)
```c
ELF Header + Program Headers:
Entry Point: 0x401000  # main 함수 시작 주소

.text Section (Virtual Address: 0x401000):
401000: 55                             pushq %rbp
401001: 48 89 e5                   movq %rsp, %rbp
401004: be 4e 00 00 00    movl $78, %esi
401009: bf 10 20 40 00      movl $0x402010, %edi  # 문자열 실제 주소
40100e: b8 01 00 00 00     movl $1, %eax
401013: e8 20 00 00 00      call 0x401033        # printf 실제 주소
401018: b8 00 00 00 00     movl $0, %eax
40101d: 5d                              popq %rbp
40101e: c3                               ret

401033: # printf 함수 기계어 코드 (라이브러리에서 복사됨)
...

.rodata Section (Virtual Address: 0x402010):
402010: "Area of circle: %f\n"

```

링커가 수행하는 작업:

- 심볼 해결: printf → 실제 주소 0x401033으로 연결
- 주소 재배치: 모든 상대 주소를 절대 주소로 변환
- 정적 라이브러리 코드 삽입: libc.a에서 printf 코드 복사
- 메모리 레이아웃 결정: 각 섹션의 가상 메모리 주소 할당


#### 각 단계별 파일크기 변화

```java
main.c        →  약 150 바이트
main.i        →  약 50,000 바이트 (헤더 파일 포함)
main.s        →  약 500 바이트
main.o        →  약 2,000 바이트 (메타데이터 포함)
main.exe      →  약 20,000 바이트 (라이브러리 코드 포함)
```

#### 정적 링킹 특징

- 컴파일 시점에 라이브러리 코드가 실행 파일에 완전히 포함됨
- 실행 파일 크기가 커지지만 독립적으로 실행 가능
- 런타임에 추가 외부 라이브러리 파일이 필요 없음


그래서 c/cpp 는 source code -> 전처리 ->  assembly code -> assembling (실제 주소 계산 등, 기계어 이나 실행 불가능)
-> 링킹 (여러 라이브러 합침 등) -> exe 파일

그러니까 cpu 가 직접 실행할 수 있는 기계어의 집합

그렇다면 Java 의 compile 과 무슨 차이가 있을까?
Java 는 JVM 이라는 미들웨어가 JIT 를 이용하여, Java 파일이 컴파일되어 나온 class 파일을
JVM 이 실행 , JVM이 JIT 를 이용하여 기계어로 변환하여 CPU 가 실행하게 된다.

### java 의 컴파일 과정

https://www.geeksforgeeks.org/java/compilation-execution-java-program/

#### javac - compilation

##### 컴파일 내부 세부 단계

- **파싱(Parsing):** 소스코드를 토큰화하고, 구문 트리(AST) 생성    
	  Reads a set of *.java source files and maps the resulting token sequence into AST (Abstract Syntax Tree)-Nodes.
	  
- **심볼 등록(Enter):** 클래스, 변수, 메서드 등의 심볼을 심볼 테이블에 등록
	  Enters symbols for the definitions into the symbol table.

- **어노테이션 처리(Process annotations):** 어노테이션이 있으면 처리
	  If Requested, processes annotations found in the specified compilation units.
  
- **속성 부여(Attribute):** 이름 해석, 타입 체크, 상수 계산
	  Attributes the Syntax trees. This step includes name resolution, type checking and constant folding.
  
- **데이터 흐름 분석(Flow):** 변수 할당, 도달성 검사
	  Performs dataflow analysis on the trees from the previous step. This includes checks for assignments and reachability.
  
- **설탕 제거(Desugar):** 문법적 설탕(예: for-each)을 기본 구조로 변환 
	  Rewrites the AST and translates away some syntactic sugar.
  
- **바이트코드 생성(Generate):** `.class` 파일로 바이트코드 생성
	  Generates '.Class' files.

일단 이런게 있다 정도만 알아두자.

#### JVM - JIT : execution 

##### 실행 내부 세부 단계

compile 된 클래스 파일은 OS-independent 하고, 이 덕분에 어떤 OS 든간에 JVM 을 통해서 실행이 가능하다.
실행하기 위해선, main class file (! 그러니까 시작점이 되는 class 파일 말하는듯.) 이 JVM 으로 넘어 가야 하고,
3가지의 스테이지를 통과해야 한다. 실질적으로 CPU 에 의해 실행되기 전에.

###### ClassLoader

JVM 이 동작되면서, main class의 클래스 파일이 JVM 에게 넘겨지고 그게 메모리에 로드된다.
(The main class is loaded into the memory bypassing its '.class' file to the JVM, through invoking the latter.
-> latter 는 나중의 것, 즉 JVM 을 뜻함.)
main class 가 아닌, 그리고 main class 에 의해 참조되는 다른 class file 들은 class loder 에 의해 메모리에 로드된다.

class loader 는 신기하게도 그 자체로 object, 즉 객체이다. 
클래스 로더는 각 클래스의 실제 내용(구현부)들을 문자열 이름으로 구분해서, 계층 구조 없이 한 공간(네임스페이스)에 관리한다.
(A class loader, itself an object, creates a flat namespace of class bodies that are referenced by a string name.)

예를 들어,
```java
com.example.Foo
org.test.Foo
```

이 둘은 이름만 보면 "Foo"로 같지만,
클래스 로더는 각각 "com.example.Foo"와 "org.test.Foo"라는
서로 다른 문자열 이름으로 관리함.

flat 하다는게 그냥 한줄로 표현되서 그렇게 말하는건가 ?

com.example.Foo 도 com 이라는 폴더 아래 example 이라는 폴더 아래에 선언된 Foo 클래스가 아니냐 라고 볼 수 있는데

클래스 로더의 네임스페이스 입장에서는 이 폴더 구조 자체를 하나의 '문자열' 로 취급.
즉 디렉토리 구조로 접근하지 않는다라고 함.

-> '클래스 로더나 네임스페이스 관점에서는 전체 이름을 **하나의 문자열 키**로 취급해서 flat하게 관리'
물리적으로는 계층이지만 말이다.

###### ClassLoader 의 종류

1. primordial

- [ ] primordial #EnglishWord ➕ 2025-09-28 
      (adj) existing at or from the beginning of time; primeval.
      (adj) (especially of a state or quality) basic and fundamental.
      __
      그러니까 원래 존재 했었던 ? 근본적인 ?

primordial 클래스 로더는 모든 JVM 에 내장되어 있고 default  클래스 로더이다.


2. non-primordial

user-defined, 즉 개발자가 임의로 만든 클래스 로더.
개발자가 직접 손대므로 클래스 로딩의 프로세스를 바꿀 수 있음.
선언되면 default class loader 대신에 사용됨.


###### Bytecode Verifier

^c9e3f8

클래스의 바이트 코드가 클래스 로더에 의해 로딩되면, (메모리에 적재되면)
bytecode verifier 에 의해 검사되어야 하는데,
bytecode verifier 의 역할은 instruction (실행 코드, behavior 를 말하는듯) 들이
시스템에 (또는 JVM 의 실행에) 데미지를 가하는 동작인지 검사하는 것이다.

예를 들면

- 변수가 사용되기 전에 초기화 되는지
- method 콜이 object reference 의 타입에 matching 되는지 
  (여기서 object reference 란, object 를 가리키는 것을 말한다. String a1 = "This is My name" 라는 코드에서 a1 는 Object reference 이다.)
  -> 즉 어떤 참조 타입을 쓰느냐에 따라 어떤 메소들을 호출할지를 판단하는 것.
  (메소드가 overriding 될 수도 있지만, 현재 참조하는 객체의 타입에 정의된 메소드를 호출. 아니면 부모 클래스의 메소드를 호출하겠지.)
- private data 나 method 에 접근하는 rule 에 코드가 위반되지는 않는지

등등..

하는 기능이 language server 와 매우 흡사하고
큰 차이점이라면 language server 는 실행 전, Bytecode Verifier 는 실행 직전에 검사되는 것.

###### Just-in-Time Compiler

JVM 에서의 마지막 스테이지로, 메모리에 로드 된 Bytecode 들을 기계어로 바꾸는 역할을 한다.

JIT 컴파일러를 사용하면, 바이트코드가 네이티브 코드(기계어)로 변환되어 하드웨어가 직접 실행함.
반면, JIT 없이 JVM이 같은 바이트코드 시퀀스를 계속 "interpret"(해석)하면, 상대적으로 긴 해석 과정 때문에 성능 저하(패널티)가 생긴다.
( JVM 자체에는 interpreter 가 내장되어 있음. )

Java는 원래 "Write once, run anywhere"를 위해 바이트코드(bytecode)를 생성하고,
JVM이 이 바이트코드를 **한 줄 한 줄 해석(interpret)**해서 OS/CPU에 맞는 동작을 하게 만듦.

-> JIT이 없으면(초기 JVM)
	JVM은 바이트코드를 읽고
	한 명령씩 그때그때 해석해서(HW가 이해할 수 있는 저수준 명령으로 변환) 실행
	이 과정이 느리고 반복 수행이 많아질수록 오버헤드가 큼




![[Pasted image 20250928033315.png|700]]

