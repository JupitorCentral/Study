## Map 

3주차 공부 [[250922]] 에 이어서

From neetcode top-k-elements solution
[[250922 needcode top-k-elements]]

```java
public int[] topKFrequent(int[] nums, int k) {  
  
    int[] answer = new int[k];  
  
    Map<Integer, Integer> map = new HashMap<>();  
    for (int i=0; i<nums.length; i++) {  
        int x = nums[i];  
        map.merge(x, 1, Integer::sum);  
    }  
  
    List<Integer> sorted = map.entrySet()
						.stream()
						.sorted(
							Map.Entry.<Integer, Integer>comparingByValue()
								.reversed()
								)  
					    .map(Map.Entry::getKey)  
					    .toList();            // 수정
  
    for (int i=0; i<k; i++) {  
        answer[i] = sorted.get(i);  
    }  
    return answer;  
}
```

```java

1. map -> Map <Integer, Integer> 

2. map.entrySet() -> Set<Map.Entry<K, V>> 
   (Map.entrySet)
   
3. stream() -> Stream<Entry<Integer, Integer>>
   (Set.stream)

4. Map.Entry.<Integer, Integer>comparingByValue().

5. Stream.sorted()
```


### 중첩 interface

```java
interface Outer {
    interface Inner {
        void method();
    }
}
// 구현할 때: class MyClass implements Outer.Inner { ... }
```

중첩된 interface 는 하나의 정의된 interface 단순히 안에 선언된 interface 이다.
이 interface 들은 자동적으로 static interface 가 된다.

#### 그러면 top-level interface 는 static 이 아닌가 ?

아니다. 하지만, interface 안에는 static method 를 선언함과 동시에 구현할 수 있으며, 이는
interface 에 대한 instance 가 존재하지 않아도 호출할 수 있다.

```java
interface MyInterface {
    static void hello() {
        System.out.println("Hello!");
    }
}
MyInterface.hello(); // 인스턴스 없이 호출 가능
```
실험해봤는데 진짜 그렇다.

이 내용들을 이해하기 위해선, interface 와 abstract class 에 관한 공부가 필요하다.

#### 왜 쓰는가 ? 

- 캡슐화와 네이밍 스페이스의 쉬운 관리
- 인터페이스나 기능을 논리적으로 묶어 코드관리를 쉽게하기 위함

위 예시 Map.Entry 는 오직 Map 과 관련된 key-value 쌍을 의미하므로 Map 안에 중첩되서 선언함.


### interface


#### method 

interface 는 기능 명세서와 비슷하다. 어떤 것을 구현하고자 하는지 메서드들을 선언할 수 있고,
이의 쓰임새는 interface 를 상속받은 클래스에서 선언되어 있는 메서드를 구현한다.

근데 자바 8 에서부터는 interface 에서도 구현이 가능한 것이었다. 위의 예시처럼.

##### default method vs static method

default method 는 구현이 가능하며, override 될 수 있다.
instance method 이기 때문에, 구현체에서 객체를 만들어야 사용할 수 있다.
그리고 당연한 얘기지만, default method 를 override 할때 public 이나 static 같은 modifier 를 추가/변경할 수는 없다.


반면 static method 는 구현해야 하며 (must have body), override 될 수 없다.
대신, 클래스의 static method 처럼 import 만 하면 사용할 수 있다.

| Feature         | Default Method  | Static Method        |
| --------------- | --------------- | -------------------- |
| Can override?   | Yes             | No                   |
| Called on       | Instance        | Interface            |
| Must implement? | No (optional)   | Yes (must have body) |
| Purpose         | Common behavior | Utility/helper       |


#### field

그리고 상수를 선언할 수 있는데, 암묵적으로 public static final 타입이 되며, 
final 이므로 선언과 동시에 값을 선언, 즉 상수가 된다.



#### import

인터페이스는 같은 패키지에 있으면 import 없이 사용가능하고, 
다른 패키지에 있으면 import 를 해야 한다.



#### difference between interface and class

interface 는 static variable, static method 를 가질 수 있기때문에
static class 와 비슷한 점이 있고, 무슨 차이점이 있는지 궁금하게 될만 하다.

interface 의 static method 는 선언과 동시에 반드시 구현해야 하며 (must have body),
interface 를 상속한 구현체의 instance 에서 호출할 수 없음.
```java
MyInterfaceImpl impl = new MyInterfaceImpl();  
impl.hello();          -> 'compile ERROR'
```

interface 는 '상태', 즉 변경되는 값을 가질 수 없음 (무조건 public static final)

또 interface 는 다중 구현 가능 (implements multiple interfaces), 
클래스는 상속 한개만 가능 (물론 클래스도 여러개의 interface 를 implements 할 수 있음)


### abstract class

-> interface 내부에서 정의가 가능하고, 그때는 'public' 이 무의미하다 (어쨌든 무조건 public 하다는 의미)

상속 : 하나의 abstract class 만 가능. 그리고 일반 class 를 상속할 수 있음. 
	그리고 마찬가지로 여러개의 interface 를 implements 할 수 있음

상태 : 일반 class 와 마찬가지
메소드 : 일부 메소드를 abstract, 즉 body 없이 정의할 수 있음 (interface 처럼).
	그런데 일부 메소드는 구현 가능
	__
	static method 의 경우, interface 처럼 반듯 구현해야 함. 
	즉  abstract static method 가 불가능.

참고로 abstract class 는 abstract static method 선언이 불가능하다.

```java
abstract class foo {
    abstract void bar( );                  // <-- this is ok
    abstract static void bar2();        //<-- compile error
}
```

사실 따지고 보면 당연한 이야기이다. 'abstract' 로 선언하겠다는건 구현을 하지 않겠다는 의미인데,
(구현을 구현체에 맡기겠다는 의미인데)
static 메서드 자체는 선언과 동시에 구현을 해야하니 말이다.

static method 와는 다르다 !

#### hiding vs overriding

그리고 static method 는 overriding 이 불가능하고 '숨김' 만 가능함.

> If a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass _hides_ the one in the superclass.
> 
> The distinction between hiding a static method and overriding an instance method has important implications:
>
> - The version of the overridden instance method that gets invoked is the one in the subclass.
> - The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.

(from docs.oracle.com, Java tutorial)

만약 subclass 가 상위 클래스의 동일한 signature 로 static method 를 호출하면, 하위 클래스의 method 가 상위 클래스의 것을 'hide' 함.

static method 를 hiding 것과, instance method 를 overring 하는 것은 2가지 중요한 차이점이 있는데

- override 된 메서드 (instance method) 는 호출이 될때 subclass 의 것이 호출됨
- hide 된 static method 의 version 은, 그것이 superclass 에서 호출됬는지 아님 상위클래스에서 호출되었는지에 달려있다.


```java
class Animal {  
    public void testInstanceMethod() { System.out.println("Animal"); }  
    public static void testClassMethod() { System.out.println("Animal"); }  
}  
class Cat extends Animal {  
    public void testInstanceMethod() { System.out.println("Cat"); }  
    public static void testClassMethod() { System.out.println("Cat"); }  
}  
  
  
public void test () {  
    Animal animal = new Cat();  
    Cat cat = new Cat();  
  
    animal.testInstanceMethod();  
    cat.testInstanceMethod();  
  
    animal.testClassMethod();  
    cat.testClassMethod();  
  
    Animal.testClassMethod();  
    Cat.testClassMethod();  
}
```

```java
Cat
Cat
Animal
Cat
Animal
Cat
```


1. 첫번째 줄 출력 : Cat -> `animal.testInstanceMethod();`
    - `animal`의 실제 객체는 `new Cat()`이므로, 오버라이딩된 Cat의 인스턴스 메서드가 호출됨. (다형성, 런타임 객체 기준)
        
2. 두번째 줄 출력 : Cat -> `cat.testInstanceMethod();
    - `cat`은 Cat 타입이면서 Cat 객체이므로, Cat의 인스턴스 메서드가 호출됨.
        
3. 세번째 줄 출력 : Animal -> `animal.testClassMethod();`
    - static method는 참조 변수 타입(`Animal`) 기준으로 호출됨. hiding 현상. (오버라이딩 아님)
        
4. 네번째 줄 출력 : Cat -> `cat.testClassMethod();`
    - static method는 참조 변수 타입(`Cat`) 기준으로 호출됨. hiding 현상.
        
5. 다섯번째 줄 출력 : Cat -> `Animal.testClassMethod();`
    - 클래스명으로 직접 호출하므로 Animal의 static method가 호출됨.
        
6. 여섯번째 줄 출력 : Cat -> `Cat.testClassMethod();`
    - 클래스명으로 직접 호출하므로 Cat의 static method가 호출됨.


즉 method 가 참조 객체의 타입 (객체가 선언된 타입) 을 따라가느냐, 아니면
실제 객체의 것을 따라가느냐 (런타임, 다형성) 가 hiding 과 overriding 의 차이인 것.



#### overriding or hiding at interface ?


그리고 interface 에 있는 static method 와 같은 signature 를 갖는 static method 를
구현체에서 선언하는 것은 overriding 이나 hide 와 전혀 관계가 없음. 둘 다 불가능.

```java
interface MyInterface {
    static void hello() { System.out.println("Interface static"); }
}
class MyClass implements MyInterface {
    static void hello() { System.out.println("Class static"); }
}
MyInterface.hello(); // "Interface static"
MyClass.hello();     // "Class static"
```
-> 전혀 독립적으로 동작.




### 그럼 import 할때 일어나는 일들은...






### 다시 Map.Entry.<Integer, Integer>comparingByValue() 로 돌아와서...



