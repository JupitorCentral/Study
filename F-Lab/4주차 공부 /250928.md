
## How the JIT compiler boosts Java performance in OpenJDK

https://developers.redhat.com/articles/2021/06/23/how-jit-compiler-boosts-java-performance-openjdk#how_a_jit_compiler_works


JIT 는 현대시대의 가상 머신가 낼 수 있는 최고의 퍼포먼스의 핵심을 차지하고 있지만, trade-off 가 있다.

### How JIT compiler works

JIT 는 내부적으로, GCC (GNU Compiler Collection) 이 사용하는 것과 같이, 잘 알려진 compilation 테크닉에 그 핵심을 두고 있다.
가장 큰 차이점은 JIT 는 어플리케이션과 같은 프로세스로 동작하고, 리소스를 두고 어플리케이션과 경쟁한다는 점에 있다.

#### 어플리케이션과 같은 프로세스로 동작한다 ?

JIT compiler 와 application 이 동일한 메모리를 공유
둘 다 같은 운영체제 프로세스에서 실행됨 (그러니까 JIT 가 active entity of a program 처럼 동작한다는 의미)
CPU, 메모리 등을 appliation 과 경쟁하며 사용함.

이는 기존 AOT (Ahead of Time) 컴파일러와 큰 차이를 둔다.

AOT -> 프로그램 실행 전에 별도의 컴파일 과정. 즉, 프로그램과 같이 실행되지 않음. 시간적으로 분리되기 때문.

따라서 다른 trade-off 들이 이 디자인에 존재한다.
주로 compilation 속도가 오프라인 컴파일러보다 JIT 에게 더 큰 이슈인데, 하지만 대신 최적화를 위한 새로운 가능성이 있음.
deoptimization 이나 speculation 같은.

deoptimization ...??


### The JIT Compiler in OpenJDK

JIT 의 역할은 javac 에 의해 변환된 .class 파일을 CPU 가 직접 실행할 수 있는 기계어로 변환하는 것.
JIT 가 오프라인 컴파일러와 또다른 점은 class file 을 runtime 에 verify 한다는 것. (ByteCode Verifier [[250927#^c9e3f8]])
컴파일 할 때가 되면, parsing 이나 verification 을 해야할 필요가 좀 있다.

다른 성능적인 다양함을 뒤로하고, JIT compiler 의 실행은 엔드유저에게 투명하다. 
java 명령어의 옵션으로 컴파일러가 어떻게 동작하는지 볼 수 있음.


```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello world!");
    }
}

```

```java
$ java -XX:+PrintCompilation HelloWorld
     50    1       3       java.lang.Object::<init> (1 bytes)
     50    2       3       java.lang.String::hashCode (55 bytes)
     51    3       3       java.lang.String::indexOf (70 bytes)
     51    4       3       java.lang.String::charAt (29 bytes)
     51    5     n 0       java.lang.System::arraycopy (native)   (static)
     52    6       3       java.lang.Math::min (11 bytes)
     52    7       3       java.lang.String::length (6 bytes)
     52    8       3       java.lang.AbstractStringBuilder::ensureCapacityInternal (27 bytes)
     52    9       1       java.lang.Object::<init> (1 bytes)
     53    1       3       java.lang.Object::<init> (1 bytes)   made not entrant
     55   10       3       java.lang.String::equals (81 bytes)
     57   11       1       java.lang.ref.Reference::get (5 bytes)
     58   12       1       java.lang.ThreadLocal::access$400 (5 bytes)
Hello world!
```

여기서 눈여겨볼 것은 , main 이나 println 이 컴파일되지 않고, 
Helloworld 에 선언되지 않은 수많은 method 들이 대신 컴파일 된다는 것이다.

#### Questions from above result

- 그것들은 도대체 어디서 올까?
  JVM 의 기동 (startup) 을 지원하는 몇몇 코드들은 다른 대부분의 java standard library 와 같이,
  자바에 이미 구현되어 있고 (자바로 써져있고) 그래서 JIT compilattion 의 대상이 된다.
  __
  Some code supporting the JVM startup, as well as most of the Java standard library, is implemented in Java, so it is subject to JIT compilation.
  (is subject to -> ~의 대상이 된다, ~에 적용된다.)
  __
  그러니까 JVM 의 시작을 돕는 몇몇 메소드, 코드들은 당연히도 JIT compilation 의 대상이 된다 이 의미인듯.
  당연히 미리 구현되어 있을 것이고.


- 그리고, 만약 메서드들 중에 아무것도 컴파일되지 않는다면, 어떻게 HelloWorld class 가 실행될 수 있는 것일까?
  Hotspot (=implementation of JVM. JVM 대신에 핫스팟이라고 불린다) 은 JIT compiler 뿐만 아니라, 
  각각의 bytecode 의 실행을 가장 범용적인 방식 으로 처리하는 인터프리터도 내장되어 있다.
  (HotSpot embeds an interpeter, which encodes the execution of each JVM bytecode in the most generic way)
	  -> 여기서 'encode' 는 일상적으로 암호화하다라는 뜻이지만,
	  컴퓨터 문맥에서는 정보를 특정 형식으로 바꾸다 또는 '규칙대로 처리하다', 실행을 특정 방식대로 처리한다 라는 의미.
	__

All methods start executing interpreted, where each bytecode is executed one at a time.
-> 문법적으로는 "method"가 주어이지만 실질적으로 "JVM이 method를 해석한다"라는 의미가 들어 있다.
	기술 영어에서는 이렇게 주체(JVM, 시스템)를 생략하고 "코드 또는 객체가 ~된다" 식으로 쓰는 경우가 많다.
	__	
	예를 들어 "The file opens encrypted" = "그 파일은(을) 암호화된 상태로 연다" → "시스템이 파일을 그런 방식으로 연다"라는 뜻.
	그래서 실제로 메서드를 실행시키는 건 JVM(혹은 HotSpot)이지만,
	여기서 "method가 interpreted로 실행을 시작한다"는 식으로 주어를 method로 잡고, 수동적으로 "실행이 된다"는 의미로 표현한 것.
	__
-> 그래서, 모든 메서드들은 그것들의 실행이 interpreted 가 되어 시작하면서 각각의 바이트코드들이 한번에 하나씩 실행된다.
-> JVM 이 바이트코드로 변환된 메서드 바디를 한줄씩 interpreting 하면서 메소드를 실행한다라는 의미.

> 여기서 '범용적인' 방식 이란, 특정 코드, 특정 최적화에 맞춰 동작하는게 아니라
> 모든 바이트코드에 대해 항상 정해진 롤대로 해석되서 실행되는 것을 말함.
> 
> 인터프리터의 경우, 자주 실행되는 코드를 캐싱한다거나 빠른 기계어로 변환한다거나 하지 않고
> 다른 덜 실행되는 코드와 동일하게 실행을 함.


- 왜 JIT 는 더 빠른 속도를 위해 미리 코드들을 준비하지 않는걸까? (여기서 코드들은 AOT 하게 컴파일된 코드들을 말하는 듯)
  -> 그렇게 하면 사용자는 JIT'ed (JIT 처리된) 코드들이 준비되기를 기다리게 될 것이고, 
  시간을 잡아먹는 컴파일로 인한 눈에 띄는 지연이 발생하는 것이기 때문이다.
	__
	-> 쉽게 말해서 code를 준비한다는것은 컴파일한다는것이고, 사용자는 컴파일이 되기까지 기다려야 하기때문에 interpreter 가 바로바로 실행할 수 있게 한다는 것.

