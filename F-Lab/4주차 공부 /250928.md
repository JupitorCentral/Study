
## How the JIT compiler boosts Java performance in OpenJDK

https://developers.redhat.com/articles/2021/06/23/how-jit-compiler-boosts-java-performance-openjdk#how_a_jit_compiler_works


JIT 는 현대시대의 가상 머신가 낼 수 있는 최고의 퍼포먼스의 핵심을 차지하고 있지만, trade-off 가 있다.

### How JIT compiler works

JIT 는 내부적으로, GCC (GNU Compiler Collection) 이 사용하는 것과 같이, 잘 알려진 compilation 테크닉에 그 핵심을 두고 있다.
가장 큰 차이점은 JIT 는 어플리케이션과 같은 프로세스로 동작하고, 리소스를 두고 어플리케이션과 경쟁한다는 점에 있다.

#### 어플리케이션과 같은 프로세스로 동작한다 ?

JIT compiler 와 application 이 동일한 메모리를 공유
둘 다 같은 운영체제 프로세스에서 실행됨 (그러니까 JIT 가 active entity of a program 처럼 동작한다는 의미)
CPU, 메모리 등을 appliation 과 경쟁하며 사용함.

이는 기존 AOT (Ahead of Time) 컴파일러와 큰 차이를 둔다.

AOT -> 프로그램 실행 전에 별도의 컴파일 과정. 즉, 프로그램과 같이 실행되지 않음. 시간적으로 분리되기 때문.

따라서 다른 trade-off 들이 이 디자인에 존재한다.
주로 compilation 속도가 오프라인 컴파일러보다 JIT 에게 더 큰 이슈인데, 하지만 대신 최적화를 위한 새로운 가능성이 있음.
deoptimization 이나 speculation 같은.

deoptimization ...??


### The JIT Compiler in OpenJDK

JIT 의 역할은 javac 에 의해 변환된 .class 파일을 CPU 가 직접 실행할 수 있는 기계어로 변환하는 것.
JIT 가 오프라인 컴파일러와 또다른 점은 class file 을 runtime 에 verify 한다는 것. (ByteCode Verifier [[250927#^c9e3f8]])
컴파일 할 때가 되면, parsing 이나 verification 을 해야할 필요가 좀 있다.

다른 성능적인 다양함을 뒤로하고, JIT compiler 의 실행은 엔드유저에게 투명하다. 
java 명령어의 옵션으로 컴파일러가 어떻게 동작하는지 볼 수 있음.


```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello world!");
    }
}

```

```java
$ java -XX:+PrintCompilation HelloWorld
     50    1       3       java.lang.Object::<init> (1 bytes)
     50    2       3       java.lang.String::hashCode (55 bytes)
     51    3       3       java.lang.String::indexOf (70 bytes)
     51    4       3       java.lang.String::charAt (29 bytes)
     51    5     n 0       java.lang.System::arraycopy (native)   (static)
     52    6       3       java.lang.Math::min (11 bytes)
     52    7       3       java.lang.String::length (6 bytes)
     52    8       3       java.lang.AbstractStringBuilder::ensureCapacityInternal (27 bytes)
     52    9       1       java.lang.Object::<init> (1 bytes)
     53    1       3       java.lang.Object::<init> (1 bytes)   made not entrant
     55   10       3       java.lang.String::equals (81 bytes)
     57   11       1       java.lang.ref.Reference::get (5 bytes)
     58   12       1       java.lang.ThreadLocal::access$400 (5 bytes)
Hello world!
```

여기서 눈여겨볼 것은 , main 이나 println 이 컴파일되지 않고, 
Helloworld 에 선언되지 않은 수많은 method 들이 대신 컴파일 된다는 것이다.

#### Questions from above result

- 그것들은 도대체 어디서 올까?
  JVM 의 기동 (startup) 을 지원하는 몇몇 코드들은 다른 대부분의 java standard library 와 같이,
  자바에 이미 구현되어 있고 (자바로 써져있고) 그래서 JIT compilattion 의 대상이 된다.
  __
  Some code supporting the JVM startup, as well as most of the Java standard library, is implemented in Java, so it is subject to JIT compilation.
  (is subject to -> ~의 대상이 된다, ~에 적용된다.)
  __
  그러니까 JVM 의 시작을 돕는 몇몇 메소드, 코드들은 당연히도 JIT compilation 의 대상이 된다 이 의미인듯.
  당연히 미리 구현되어 있을 것이고.


- 그리고, 만약 메서드들 중에 아무것도 컴파일되지 않는다면, 어떻게 HelloWorld class 가 실행될 수 있는 것일까?
  JIT compiler 뿐만 아니라, HotSpot 


- 왜 JIT 는 더 빠른 속도를 위해 미리 코드들을 준비하지 않는걸까? (여기서 코드들은 AOT 하게 컴파일된 코드들을 말하는 듯)



