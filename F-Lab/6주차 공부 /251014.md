
## Spring boot 의 @Component 로 등록한 객체가 Bean 으로 등록되는 과정


알기 위해서는
- IoC, DI
-> `@Component` 로  객체를 등록한다는 것은, Spring IoC 컨테이너가 해당 객체의 생명주기를 관리한다는 뜻.

-  Bean 개념과 생명주기
-> `@Component` 로 등록된 객체는 @Bean 이 되기 때문에, Beab의 정의와 생명 주기를 알아야 함

-  Component 와 Component Scanning
-> `@Component` 가 붙은 클래스가 Beab 으로 등록되는 핵심 매커니즘이 바로 `Component Scanning`.

-  Bean 등록 과정과 세부단계
-> 단순히 `@Component` 어노테이션만 붙인다고 Bean 이 되는게 아니라,
Spring 이 내부적으로 어떤 순서로 Bean 을 등록하고, 
확장 포인트 (BeanFactoryPostProcessor, BeanPostProcessor) 등을 어떻게 활용하는지 알아야 함

- Spring 의 Auto configuration
-> Spring Boot 에서는 추가적으로 자동 설정 (Auto-Configurationn)이 개입되어, Bean 등록 및 설정이 저 자동화 됨,
`@SpringApplication` 이 내부적으로 어떤 역할을 하는지, Auto-Configuration 이 어떻게 동작하는지 알아야 전체 흐름을 설명할 수 있음

-> Spring Boot  에서는 Bean 등록 과정이 더 복잡해질 수 있음.


- 대략적 전체 과정

Spring 이 Component 를 스캔 -> Bean 을 생성 -> IoC 컨테이너에 등록 -> DI 로 주입.


### IoC (inversion of Control) 과 DI (Dependency Injection)

- DI
->  Spring Framework 가 객체에 인스턴스를 주입해주는 것으로, IoC 를 구현하는 방식 중의 하나임 (다른 하나는 DL)

- IoC
-> 제어의 역전. 객체의 생성과 의존성 관리를 외부 프로세스 (컨테이너) 가 담당하는 것.
-> IoC 의 구현은 2가지 방식이 있음 : Dependency Injection, Dependency Lookup

- DL (Dependency LookUp)
의존성 조회.
IoC 의 한 형태로, 컴포넌트가 필요할때 의존성을 레지스트리나 컨테이너에서 직접 조회해 가져오는 방식. 
그 구현으로 dependency pull 과 CDL이 있음.


> Dependency : 어떤 객체가 자신의 작업을 수행하기 위해서 필요로 하는 다른 객체.
> -> an Object's collaborators. 어디서 왔는지 (같은 패키지, 다른패키지, 외부 라이브러리) 는 중요하지 않음. 
> -> 즉 어떤 패키지에 국한되지 않음.

그러니까, DL 은 어떠한 객체가 그 객체의 역할을 하기 위해서 필요한 참조를
레지스트리나 컨테이너에서
(여기서 레지스트리라 함은, 컨테이너의 일종이 아니라 의존성을 저장하고 관리하는 저장소를 가리키는 추상적인 표현임)

객체가 '능동적으로' 참조를 획득 (acquire) 하는 것을 말함.

즉 개발자가 코드로 직접적으로 저장소에서 참조함.

즉 DI 와는 다르다. DI 는 참조를 IoC 컨테이너가 대신 주입, 즉 수동적으로 얻음.

- 레지스트리
레지스트리는 의존성이 저장되어 있는 중앙 저장소 라는 추상적인 표현임.
런타임에 객체 인스턴스를 저장하고 조회할 수 있는 장소.

일반적으로 Bean 조회는 `ApplicationContext` 를 통해 관리되지만, 
`Registry` 라는 표현은 조금 더 특정 범위의 객체 관리 구조를 지칭함.

Maven Respository 와는 아예 다른 개념. 빌드 타임에 라이브러리 (jar) 를 다운로드 하는 곳.



- 컨테이너
컨테이너는 리소스를 관리하는 주체. Spring 의 경우 `ApplicationContext` 가 IoC 컨테이너 역할을 하고,
빈의 생성, 관리, 주입을 담당한다.

조회 및 저장만 할수 있는 JNDI 와는 달리 `ApplicationContext` 는 객체의전체 생명주기를 관리함.


- IoC 컨테이너 ?

IoC 를 구현하기 위한 구현체. 객체를 관리하는 의미에서 Container 로 칭하는 듯.
IoC 의 컨셉대로 수행하는 요소로
객체를 생성하고
객체에 의존성 주입을 하고,
객체의 생명주기 (Life Cycle) 를 관리함.
여기서 말하는 객체는 'Bean'.

IoC is a technique that externalizes the creation and management of component dependencies.

'외부화' -> 전통적인 방식에서는 어떠한 클래스가 내부에서 new 를 사용해
필요한 클래스의 인스턴스를 생성해서 외부 의존성을 참조하였지만

IoC 가 적용된 환경에서는 외부 프로세스 (컨테이너) 가 그 인스턴스를 제공한다는 의미.

여기서 외부 프로세스란 객체 외부의 어떤 것을 지칭하는 비유적 표현임.

그러니까 어떤 객체가 작업을 위해 필요한 외부 객체 인스턴스를
해당 객체가 직접 생성하는 전통적인 환경과 달리
IoC 컨테이너가 런타임에 그 객체 인스턴스를 대신 생성 및 주입해준다는 얘기.


- 책에서 말하는 의존성 관리 (헷갈리니까 나중에 볼 것)

1. 생성 : 컴포넌트 의존성의 생성을 외부화
2. 공급 (Provisioning) : 컴포넌트 의존성을 제공하는 매커니즘
3. 생명주기관리 (Life Cycle Management) : 의존성들을 그들의 생명주기 전반에 걸쳐 관리


---
DL 은 또 2가지로 나뉜다.

- Dependency Pull
레지스트리에서 필요할 때 의존성을 끌어오는 방식.
JNDI 의 방식 (Java Naming and Directory Interface)

```java
// Pro Spring 5 예시: ApplicationContext에서 빈을 '끌어오는' dependency pull
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class DependencyPull {
  public static void main(String... args) {
    ApplicationContext ctx =
        new ClassPathXmlApplicationContext("spring/app-context.xml");
    MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
    mr.render();
  }
}
```



이쯔음에서 JDNI 가 나오는데,
JDNI 를 이해하려면 JEE 와 JEE Application, JEE Server Application 에 대해 알아야 한다.

JEE 는 Java Enterprise application 을 위한 표준 명세인거고, JEE 는 JEE 를 따르는 API 를 개발자에게 제공하여 JEE Application 을 만들고, 그 JEE Application 을 JEE를 따라 만들어진 서버 어플리케이션에다가 탑재해서 돌린다. 
그럼 이 JEE application 에서, 개발자가 EJB Component 를 선언하면 EJB Contrainer 가 EJB 를 생성해서 
EJB Container 에서 생성 및 관리하고, 이 EJB 를 개발자가 JNDI 를 통해 접근한다.
(참고로 EJB 고 IoC 를 구현한게 맞다.)


그리고 Spring 은 JEE 의 일부 표준을 차용하여 단점을 개선하고 경량화한, Java Application 을 만들기 위한 프레임워크이다.
(JEE 도 Java Application 을 만들기 위한 명세이긴하지만 프레임워크는 아님)

명세는 말 그대로 어떻게 만들어져야 한다는 개념. 구현을 포함하지 않음.
프레임워크는 어플리케이션을 만들때 바로 사용하는 실행 가능한 코드와 런타임을 제공하여 어떻게 구현할지를 돕는 도구.
구현을 포함함.



Spring 은 필요시 DL 도 제공함.
Spring 은 놀랍게도 pull 을 쓴다. CDL 이 아니라.


- Contextualized Dependency Lookup (CDL)
중앙 레지스트리가 아닌, 리소스를 관리하는 컨테이너에 대해 조회를 수행하는 방식.

```java
// 컨테이너가 제공하는 진입점에서 조회를 수행하는 CDL 개념 예시
package com.apress.prospring5.ch3;

public interface ManagedComponent {
  void performLookup(Container container);
}

public interface Container {
  Object getDependency(String key);
}

public class ContextualizedDependencyLookup implements ManagedComponent {
  private Dependency dependency;

  @Override
  public void performLookup(Container container) {
    this.dependency = (Dependency) container.getDependency("myDependency");
  }

  @Override
  public String toString() { return dependency.toString(); }
}
```

여기서 레지스트리는 객체를 만들지 않고 이미 관리 중인 객체의 참조를 이름으로 바인딩하고,
조회만 하는 중앙 조회 저장소임.
즉 객체 저장 및 조회만 하는 서비스.

EJB 컨테이너도 객체를 생성하고 관리함.

컨테이너는 객체 인스턴스를 생성하고 의존성을 연결하며 객체생명주기를 관리.
필요시 자신이 관리하는 객체 참조를 레지스트리에 게시해 클라이언트가 조회할 수 있도록 함.
-> 위에는 JNDI 의 방식으로 되어있는데, JNDI 는 API 이자 네이밍 서비스로써,
EJB 컨테이너는 자신이 관리하는 객체의 참조를 JNDI 네이밍 서비스에 바인딩하고,
클라이언트는 JDNI API 를 이용해 이를 조회함.

#### Dependency pull vs CDL

- Dependency pull
-> 필요한 순간에 개발자가 이름으로 참조를 끌어옴.


- CDL
-> 중앙 레지스트리가 아니라 리소스를 관리하는 컨테이너가 정한 시점 (set point) 에 콜백을 통해 컨테어네에서 의존성을 조회함.


-> pull 예시
```java
ApplicationContext ctx =
    new ClassPathXmlApplicationContext("spring/app-context.xml");
MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
```

-> CDL 예시
```java
public interface ManagedComponent {
  void performLookup(Container container);
}
public interface Container {
  Object getDependency(String key);
}
public class ContextualizedDependencyLookup implements ManagedComponent {
  private Dependency dependency;
  @Override
  public void performLookup(Container container) {
    this.dependency = (Dependency) container.getDependency("myDependency");
  }
}
```

누가 타아밍의 주도권이 있고 어디서 조회하느냐가 다름.

-> 여전히 이해하기 힘들다.

#### DI vs CDL

```java
// DI: 컨테이너가 넣어줌
public class ConstructorInjection {
  private final Dependency dependency;
  public ConstructorInjection(Dependency dependency) { // 컨테이너가 주입
    this.dependency = dependency;
  }
}
```


```java
// CDL: 컨테이너 콜백 시점에 '직접 조회'
public interface ManagedComponent {
  void performLookup(Container container);
}
public interface Container {
  Object getDependency(String key);
}
public class ContextualizedDependencyLookup implements ManagedComponent {
  private Dependency dependency;
  @Override
  public void performLookup(Container container) { // 컨테이너가 이 메서드를 호출
    this.dependency = (Dependency) container.getDependency("myDependency"); // 스스로 꺼냄
  }
}
```


```java
// Dependency pull: 필요할 때 레지스트리/컨테이너에서 끌어옴
ApplicationContext ctx = new ClassPathXmlApplicationContext("spring/app-context.xml");
MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
```

DI는 수동 수령(컨테이너가 전달), CDL은 능동 수령(컨테이너 콜백 시 스스로 조회), pull은 아무 때나 스스로 중앙 레지스트리에서 끌어오기.
라는데 여전히 무슨 소리인지 잘 모르겠다.

어쨌든 Spring 에서는 DI 를 쓰며, 일단 DL - Dependency pull 을 제공을 하기는 한다.




### ApplicationContext vs BeanFactory

#### 공통점

둘 다 Spring 의 IoC Container Interface 이다.

#### 관계

ApplicationContext 는 BeanFactory 를 확장한 인터페이스이다.

>In Spring, the ApplicationContext interface is an extension to BeanFactory. In addition to DI services, ApplicationContext provides other services, such as transaction and AOP service, message source for internationalization (i18n), and application event handling, to name a few.


#### BeanFactory

BeanFactory 는 Spring 의 가장 기본적인 IoC 컨테이너.

- Bean 생성 및 관리
- 의존성 주입
- Bean 라이프사이클 관리

-> 기본적인 DI 기능만 제공

#### ApplicationContext 


- **국제화(i18n)** 지원 - MessageSource
- **이벤트 발행** 메커니즘
- AOP 통합
- 트랜잭션 관리
- **리소스 로딩** 기능
- 웹 애플리케이션 지원

-> BeanFactory 기능에 추가적인 기능 제공


#### ApplicationContext 와 BeanFactory 의 차이점

Bean 을 Lazy 하게 loading 한다.

즉, `getBean()`메서드가 호출될때야 비로소 Bean 을 생성한다 (instantiate)
-> 따라서 메모리가 더 효율적.

반면, ApplicationContext 는 컨텍스트 시작 시
모든 Singleton Bean 을 즉시 (eagerly) 초기화 한다.
-> 초기 메모리 사용량이 좀 있지만, 런타임 성능이 더 좋음




### Component Scanning

Spring 이 어플리케이션의 classpath 에서 자동으로
component 들을 발견하고, 이를 Spring ApplicationContext 에 beans 로 생성하는 작업.

##### Stereotype Annotations

@Component, @Service, @Repository, @Controller 등의 어노테이션이
Spring Beans 가 자동으로 생성되는데에 사용됨.

##### Component Scanning 활성화

순수 Spring Framework 에서는 component scanning 이 비활성화 되어 있고,
SpringBoot 에서는 자동으로 활성화가 되어 있음
-> main 함수에 붙이는 @SpringBootApplication 은 여러 어노테이션의 조합임.
@SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan


@ComponentScan 의 기본 동작은
@SpringBootApplication 이 있는 클래스의 package 와 그 하위 packges 를 자동으로 스캔한다.
그런데 다른 package 를 scan 하고 싶으면 코드를 추가해야 함.

```java
@SpringBootApplication
@ComponentScan(basePackages = {"com.example", "com.other"})
public class MyApplication {
    // ...
}
```

@ComponentScan 을 쓰거나 xml 로 활성화
```java
<context:component-scan base-package="com.packt.patterninspring.chapter4.bankapp"/>
```


##### 스캔 프로세스

지정된 base package 부터 시작해서, 모든 하위 패키지를 재귀적으로 탐색하고,
`.class` 파일을 읽어서 어노테이션을 확인함.

##### 결과

스캔된 클래스들의 메타 데이터들을 수집하며,
이들이 곧 Bean Definition 을 위한 준비가 됨.

이 단계에서는 Bean 객체를 생성하지 않고,

Bean Definition 생성을 위한 후보 클래스들을 식별하는 단계.



### Bean 등록 과정의 단계별 분석

#### 클래스 스캔 단계

바로 위, Component Scanning  으로 Bean의 대상이 될 candidate 클래스들을 선별한다.
(어노테이션으로)


#### Bean Definition 생성 단계

위에서 선별된 클래스들의 Bean Definition 을 생성함.

Bean Definition 은 실제 객체가 아니라, 이 객체를 어떻게 만들 것인지에 대한 정보를 담음 (메타데이터)

이 정보에는 클래스 타입, 생성자/프로퍼티 정보, 스코프 (Singleton, Prototype 등),
초기화/소멸 메서드, 의존성 등이 포함됨.

모든 Bean Definition 은 Spring Container 에 등록됨.

이 과정에서 BeanFactoryPostProcessor 같은 확장 포인트를 통해 Bean Definition 을 수정할 수 있다.


이 Bean Definition 들이 BeanFactory Class 로 들어감. 

---
\[이 부분은 사실 확인이 필요함. AI 가 내린 결론임.]
엄연히 말하자면, BeanDefinition 은 ApplicationContext 가 보유한 내부의
BeanFactory 에 Bean Definition 이 넘어가고,
그 다음 ApplicationContext 가 초기화 단계에서 Bean 들을 미리 생성하는 일을 트리거 함.

Definition 은 BeanFactory 에, 선생성 여부의 결정과 트리거는 ApplicationContext에서.

---
근거는 Spring Framework 공식 Javadoc에 명시되어 있으며, 컴포넌트 스캐너가 BeanDefinitionRegistry에 빈 정의를 등록하고(ApplicationContext가 넘겨주는 레지스트리), ApplicationContext가 내부 BeanFactory 초기화를 마치면서 lazy가 아닌 싱글톤을 선(미리) 생성함을 확인할 수 있습니다.[spring+3](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html)​  
즉 “정의는 BeanFactory(= BeanDefinitionRegistry)에 저장되고”, “선생성 트리거는 ApplicationContext의 컨텍스트 초기화 단계에서 수행된다”가 공식 문서 레벨에서 확인됩니다.[enterprise.spring+3](https://docs.enterprise.spring.io/spring-framework/docs/6.1.22/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html)​

- 정의 등록 근거

	- “A bean definition scanner that detects bean candidates on the classpath, registering corresponding bean definitions with a given registry.”라는 Javadoc 문구가 스캐너가 레지스트리에 BeanDefinition을 등록함을 직접적으로 말합니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html)​
	    
	- 같은 Javadoc에서 생성자 파라미터에 “registry — the BeanFactory to load bean definitions into, in the form of a BeanDefinitionRegistry”라고 적시되어 ApplicationContext가 제공하는 레지스트리(보통 DefaultListableBeanFactory)에 정의를 ‘넣는다’는 점을 분명히 합니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html)​
    

- 레지스트리 구현체 근거

	- DefaultListableBeanFactory Javadoc은 “A full-fledged bean factory … and BeanDefinitionRegistry”로 자기 자신이 BeanDefinitionRegistry를 구현한다고 밝히며, “Typical usage is registering all bean definitions first … before accessing beans.”로 정의가 먼저 레지스트리에 등록되는 사용 패턴을 기술합니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
	    
	- BeanDefinitionRegistry Javadoc 또한 “Known implementors … DefaultListableBeanFactory”로 명시해, 정의 저장소(레지스트리)의 대표 구현이 DefaultListableBeanFactory임을 확인시켜 줍니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/BeanDefinitionRegistry.html)​
    

- ApplicationContext와 내부 BeanFactory

	- AbstractApplicationContext Javadoc은 “Finish the initialization of this context’s bean factory, initializing all remaining singleton beans.”라고 하여 ApplicationContext가 자신의 내부 BeanFactory 초기화를 마무리하며 남은 싱글톤들을 초기화함을 명시합니다.[enterprise.spring](https://docs.enterprise.spring.io/spring-framework/docs/6.1.22/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html)​
	    
	- 같은 Javadoc은 “Modify the application context’s internal bean factory …” 등의 표현으로 ApplicationContext가 ‘내부 BeanFactory’를 보유·관리한다는 점을 직접적으로 언급합니다.[enterprise.spring](https://docs.enterprise.spring.io/spring-framework/docs/6.1.22/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html)​
    

- 선생성 트리거 근거

	- DefaultListableBeanFactory의 preInstantiateSingletons() Javadoc은 “Ensure that all non-lazy-init singletons are instantiated”라고 적시하여 lazy가 아닌 싱글톤이 선(미리) 생성됨을 정확히 규정합니다.[spring](https://docs.spring.io/spring-framework/docs/1.0.2/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
	    
	- AbstractApplicationContext 측 설명(위 인용)과 함께 보면, 컨텍스트 refresh 과정의 마무리 단계에서 이 preInstantiateSingletons 흐름이 수행되며 그 대상이 “non-lazy-init singletons”임이 일치합니다.[spring+1](https://docs.spring.io/spring-framework/docs/1.0.2/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
    

- 흐름 요약(EN/KR)

	- Component scanning → register BeanDefinitions into BeanDefinitionRegistry(= DefaultListableBeanFactory)라는 책임 분리가 Javadoc에 명시되어 있습니다.[spring+2](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
	    
	- ApplicationContext refresh → finishBeanFactoryInitialization → initialize remaining singleton beans(= non-lazy)로, 선생성 트리거가 ApplicationContext 초기화 단계에 있음을 확인할 수 있습니다.[spring+1](https://docs.spring.io/spring-framework/docs/1.0.2/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
	    
---

#### Bean 인스턴스화 단계

이전 단계에서 만들어 둔 Bean Definition 을 이용해 실제 객체가 생성됨.
Spring Container 가 new keyword 또는 Reflection 을 사용해
해당 클래스를 메모리에 올린다.

>Each Bean is eagerly instantiated by default. It is created in the right order with its dependencies injected unless marked as lazy

각 Bean 들은 기본적으로 eagerly 하게 생성됨. 

생성자 주입의 경우 인스턴스화(생성) 와 의존성 주입이 이 단계에서 일어남
Setter 주입의 경우 다음 단계에서 의존성 주입이 일어남 
(Class 의 Autowired 어노테이션이 붙은 필드도 Setter Injection pattern 의 dependency injection 때 일어남)

##### Constructor-based dependency injection pattern

(by Book - Spring 5 Design Patterns)

- Constructor-based dependency injection pattern

Dependency injection is a design pattern to resolve the dependencies of dependent classes, 
and dependencies are nothing but object attributes. 

##### Setter-based dependency injection

The injector of the container has another way to wire the dependency of the dependent object. In setter injection, one of the ways to fulfil these dependencies is by providing a setter method in the dependent class. ”

```java
@Component
public class UserService {
    private final UserRepository userRepository;
    private EmailSender emailSender;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository; // Constructor-based dependency injection pattern
    }

    @Autowired
    public void setEmailSender(EmailSender emailSender) {
        this.emailSender = emailSender; // Setter-based dependency injection
    }
}
```


#### 의존성 주입 단계

`@Autowired`가 붙은 setter는 직접 호출하지 않아도 Spring이 자동으로 호출해서 의존성을 주입.    
즉, 개발자가 setUserRepository를 직접 호출하지 않아도, Spring이 bean을 생성한 후 해당 메서드를 자동으로 실행해서 의존성을 넣어줌

> “The @Autowired annotation is not limited to the construction; it can be used with the setter method, 
> and can also be used directly in the field, that is, an autowired class property directly.”

그러니까 이 단계에서는
@Autowired 가 붙은 field 의 dependency 를 해결하고
또 @Autowired 가 붙은 method 의 의존성을 해결한다 (물론 이 해결하는 과정에서 어떤 field 에 필요한 instance 를 개발자가 대입할 것.)

위 예시에서 setEmailSender 의 parameter 에 대한 dependency 가 resolve 되면서 setEmailSender method 가 실행됨.
-> UserService Bean의 emailSender field 의 의존성 해결.

#### 초기화 단계


이제 이렇게 의존성이 해결된 Bean 에 대해서 초기화를 실행.

이 과정에서 개발자가 지정한 초기화 메서드가 호출되거나, 
Spring이 제공하는 다양한 콜백 인터페이스/어노테이션이 동작함.

```java
@Component
public class UserService implements InitializingBean {
    @Override
    public void afterPropertiesSet() {
        // 초기화 로직
    }
    @PostConstruct
    public void init() {
        // 또 다른 초기화 로직
    }
}
```

>Spring provides three mechanisms a bean can use to hook into each of these events and perform some additional processing: 
>interface-based, method-based, and annotation-based mechanisms

BeanPostProcessor 의 `postProcessBeforeInitialization`과 `postProcessAfterInitialization` 메서드가 이 단계에서 호출.



### 관련 Class, topic


- `ClassPathBeanDefinitionScanner`
    
- `AnnotationConfigApplicationContext`
    
- `BeanDefinitionRegistry`
    
- `BeanFactoryPostProcessor`
    
- `BeanPostProcessor`

- `@SpringBootApplication`은 어떻게 Component Scanning을 활성화하는가?

- `@EnableAutoConfiguration`의 역할은?

#### From the beginning to Bean initialization By AI

한 줄 답: main 이후 컨텍스트가 올라오면 컴포넌트 스캔으로 BeanDefinition을 레지스트리에 등록하고, 
레지스트리/팩토리 후처리기를 모두 적용한 뒤, 
refresh의 finishBeanFactoryInitialization 단계에서 non‑lazy 싱글톤을 preInstantiateSingletons로 선생성하며 
bean 초기화가 마무리됩니다.[spring+4](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/BeanDefinitionRegistryPostProcessor.html)​  
아래는 main 직후부터 컴포넌트 스캔 시작에서 싱글톤 선생성까지의 Bean 관련 클래스/인터페이스 호출 흐름을 한 줄씩 요약한 것입니다.[spring+1](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html)​

##### 호출 흐름

1. AbstractApplicationContext — 애플리케이션 컨텍스트 수명주기(refresh)를 지휘하며 내부 BeanFactory를 준비/초기화하는 상위 구현입니다.[spring+1](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html)​
    
2. BeanDefinitionRegistry — 빈 정의를 보관·수정하는 레지스트리 SPI로, 인스턴스화 전 정의 등록의 진입점입니다.[spring+1](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/BeanDefinitionRegistry.html)​
    
3. DefaultListableBeanFactory — 대표 BeanFactory 구현이자 BeanDefinitionRegistry로, 정의를 보관하고 싱글톤 선생성을 수행합니다.[spring+1](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
    
4. ClassPathBeanDefinitionScanner — 클래스패스를 스캔해 컴포넌트 후보를 찾고 해당 BeanDefinition을 주어진 레지스트리에 등록합니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html)​
    
5. ConfigurationClassPostProcessor — @Configuration/@ComponentScan을 처리해 추가 BeanDefinition(@Bean 등)을 레지스트리에 도출·등록하는 RegistryPostProcessor입니다.[spring+1](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ConfigurationClassPostProcessor.html)​
    
6. BeanDefinitionRegistryPostProcessor — 일반 BeanFactoryPostProcessor 탐지 전 단계에서 추가 BeanDefinition을 등록할 수 있는 확장 지점입니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/BeanDefinitionRegistryPostProcessor.html)​
    
7. BeanFactoryPostProcessor — 빈 인스턴스가 아니라 빈 정의를 수정하며, 다른 빈이 생성되기 전에 ApplicationContext가 자동 적용합니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html)​
    
8. BeanPostProcessor — 새로 생성된 빈 인스턴스에 대해 초기화 전후 후킹하여 검사/프록시 래핑 등을 수행합니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html)​
    
9. InstantiationAwareBeanPostProcessor — 대상 빈이 인스턴스화되기 전/후(프로퍼티 주입 전) 단계에 개입하여 기본 인스턴스화를 대체하거나 추가 주입 전략을 구현합니다.[spring+1](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/InstantiationAwareBeanPostProcessor.html)​
    
10. MergedBeanDefinitionPostProcessor — 병합된 빈 정의(RootBeanDefinition)를 후처리하여 캐시 메타데이터 준비 등 정의 수준의 보강을 수행합니다.[spring+1](https://docs.spring.io/spring-framework/docs/2.5.6/javadoc-api/org/springframework/beans/factory/support/MergedBeanDefinitionPostProcessor.html)​
    
11. AbstractApplicationContext.finishBeanFactoryInitialization — 컨텍스트의 BeanFactory 초기화를 마무리하며 남아 있는 싱글톤 빈을 초기화합니다.[javadoc](https://www.javadoc.io/static/org.springframework/spring-context/4.3.20.RELEASE/org/springframework/context/support/AbstractApplicationContext.html)​
    
12. DefaultListableBeanFactory.preInstantiateSingletons — lazy가 아닌 모든 싱글톤의 인스턴스화를 보장하여 선생성을 완료합니다.[spring+1](https://docs.spring.io/spring-framework/docs/1.0.2/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
    


##### From main To ApplicationContext -> BeanDefinitionRegistryPostProcessor

main function 이 담긴 Application Class 의 이름을 DemoApplication 이라고 했을 경우

1. **DemoApplication (main method)**
    
    - 자바 entry point. Spring Boot 앱을 시작하는 main 함수.
        
2. **SpringApplication**
    
    - Spring Boot 앱의 전체 lifecycle을 관리하는 런처. 환경, 컨텍스트 타입, 초기화 등 결정.
        
3. **SpringBootApplication (annotation)**
    
    - 실제로는 `@SpringBootConfiguration`, `@EnableAutoConfiguration`, `@ComponentScan`을 포함. 자동 설정, 컴포넌트 스캔, 자바 기반 설정을 트리거.
        
4. **SpringBootConfiguration (annotation)**
    
    - `@Configuration`의 alias. 자바 기반 Bean 설정 클래스로 인식됨.
        
5. **EnableAutoConfiguration (annotation)**
    
    - classpath, 설정, 의존성에 따라 자동으로 Bean을 등록하는 AutoConfiguration 클래스들을 import.
        
6. **ComponentScan (annotation)**
    
    - 지정된 패키지에서 `@Component`, `@Service`, `@Repository`, `@Controller` 등 Bean 후보 클래스를 스캔.
        
7. **SpringApplication.run() 내부**
    
    - 환경(Environment) 준비, Banner 출력, ApplicationContext 타입 결정(Web/Reactive/None), 초기화.
        
8. **ApplicationContext (ConfigurableApplicationContext)**
    
    - BeanFactory를 포함하는 Spring 컨테이너. 실제로는 `AnnotationConfigServletWebServerApplicationContext` 등 구체 클래스가 생성됨.
        
9. **BeanDefinitionRegistry (interface)**
    
    - Bean 정의를 등록/관리하는 SPI. ApplicationContext 내부의 BeanFactory가 구현체(DefaultListableBeanFactory)로 사용됨.
        
10. **DefaultListableBeanFactory**
    
    - BeanDefinitionRegistry의 대표 구현. BeanDefinition을 보관하고, 이후 Bean 인스턴스화를 담당.
        
11. **ClassPathBeanDefinitionScanner**
    
    - ComponentScan에 의해 트리거. 지정 패키지에서 Bean 후보 클래스를 찾아 BeanDefinitionRegistry에 등록.
        
12. **ConfigurationClassPostProcessor**
    
    - `@Configuration`, `@ComponentScan`, `@Bean` 등 자바 기반 설정을 처리. 추가 BeanDefinition을 Registry에 등록.
        
13. **BeanDefinitionRegistryPostProcessor**
    
    - BeanFactoryPostProcessor보다 먼저 실행. BeanDefinitionRegistry에 추가 정의를 등록할 수 있는 확장 지점.

-> 이건 맞는지 확인이 필요하다.



## Proxy 와 Spring 에서의 Proxy


### Proxy Pattern

프록시는 원본 객체의 대리자 역할을 하고, 요청을 전달하기 전, 후로 어떠한 동작이나 정책을 수행해 접근을 제어함.

쉽게 말하면 클라이언트와 실제 객체 사이에서 대신 받아주고 넘겨주는 '중간매개체(stand-in, intermediary)'로,
같은 인터페이스를 유지한 채 접근을 간접화하고 필요하면 호출 (call) 전 후에 정책 (policy) 를 수행함.
-> substitute or placeholder for another object.
	접근 제어·지연 로딩·캐싱·로깅 같은 부가기능을 끼워 넣기 위해 호출을 '가로채고' 실제 객체로 위임하는 구조

Core mechanism of Proxy
-> Use the same interface, intercept, then delegate

#### 왜 쓰는가?

- 접근 제어
민감한 리소스에 대한 권한 검사 등의 정책을 호출 경계에서 강제함
-> 이게 뭔 개소리야? 호출경계가 그러니까 해당 오브젝트가 호출될때 호출직전을 말하는거겠지?

- 비용 지연/절감
무거운 객체는 실제로 필요할때 생성 및 로딩 (virtual proxy) 하고, 반복 호출 결과는 캐싱하여 비용을 줄임
-> 아, lazy loading 을 프록시가 하는건가?

#### 간단한 예

- Virtual Proxy
큰 이미지/데이터를 '필요 시' 로딩해 초기비용을 늦춤 (lazy loading)

- Protection Proxy
호출자 자격을 검사하여 허용된 메서드만 실행

- Remote Proxy
로컬 객체처럼 보이지만 실제로는 원격 개체를 호출해 네트워크 세부를 숨김.

- caching/logging Proxy
동일 파라미터 결과 캐싱/호출 로그를 남겨 성능과 추적성을 확보.



### Spring AOP

####  AOP ?

AOP는 cross-cutting concerns (공통관심사)를 분리해 모듈화하여
핵심 비즈니스 코드에 섞이지 않게 하고, 정해둔 지점에서 공통 로직을 자동으로 끼워넣는 프로그래밍 패러다임.

어려운 말로 하면
Aspect-Oriented Programming은 “separation of cross‑cutting concerns”를 통해 모듈성을 높이고, 
pointcut으로 지정된 지점에서 advice를 적용하여 기존 코드를 바꾸지 않고 동작을 추가함.

- pointcut
-> 어디에 적용할지 (which join points) 를 골라내는 조건/표현식.
-> 어떤 메서드에 적용할지 고르는 필터

- join point
-> Aspect 의 로직 (advice) 이 Application 실행 흐름과 '합류(join)' 하는 지점을 뜻하는 AOP 용어.

- advice
-> 무엇을/언제 (what/when) 실행할지 정한 부가 로직.
-> 그 메서드를 호출할때 앞뒤로 무엇을 할지 적어둔 스크립트.

쉬운 말로, 서비스 메서드마다 똑같이 써야 하는 로깅/권한체크 같은 코드를 한 곳(aspect)에 모아두고, 
“어디서 실행할지(pointcut)”만 지정하면 스프링이 호출 시 자동으로 끼워 넣어줌.

#### at Spring

AOP 를 프록시 기반으로 런타임에 적용하는 Spring 의 AOP 구현 (implementation) 임.
(구현 방식이 Proxy)

런타임에 대상 Bean 주변에 프록시를 두고 메서드 호출을 가로채 advice 를 실행함.



## spring-data 의 @Transactional annotation 붙인 메소드에 트랜잭션이 작동하는 방식

(가능한한 상세히)

### What is @Transactional ?

- spring-data ?

-> 여러 종류의 DB 에 똑같은 방식으로 접근할 수 있게 해주는 도구의 집합.
-> JPA, JDBC, MongoDB 등 여러 데이터 저장소에 대해 일관된 Repository 패턴과 트랜잭션, 쿼리 추상화 기능을 제공하는 "프로젝트군"
-> Spring Data JPA, Spring Data JDBC 등을 포함
-> 핵심 기능으로, Repository 패턴, 트랜잭션 관리, 쿼리 자동생성, 페이징/정렬 등이 있음

@Transactional 은 Spring Data 의 일종이 아니라,
Spring 전체에서 데이터 접근과 트랜잭션을 관리하는 공통 기능임.

그리고 Spring Data 가 내부적으로 활용하는 Spring  의 트랜잭션 관리 기능.


### Declaring of @Transactional Annotation on Class

클래스에 @Transactional 을 선언하면 
해당 클래스의 모든 method 와 그의 서브 클래스에 
이 설정이 default 값으로 설정됨 (@Transactional 의 동작이)

-> 그럼 method 에다가만 설정하면? (내가 개발때 그렇게 썼으니깐)

#### Declaring of @Transactional Annotation on method, not class

클래스의 메서드 중 하나의 메서드에만 @Transactional 을 선언해도
해당 클래스 Bean 에 Proxy 가 둘러 쌓이는가 ?

한 줄 답: @Transactional은 스프링의 “annotation‑driven, proxy‑based” 트랜잭션 인프라에 의해 처리되며, 이 인프라는 @Transactional 메서드를 찾아내는 트랜잭션 어드바이저(포인트컷)를 등록하고, 그 포인트컷이 해당 빈의 메서드 중 하나라도 매칭되면 그 빈 전체를 프록시로 대체한 뒤, 실제 트랜잭션 적용은 매칭된 메서드 호출에 한해서 수행합니다.[spring+3](https://docs.spring.io/spring-framework/reference/core/aop-api/autoproxy.html)​  
즉, “프록시는 빈 단위로 생성되지만, 트랜잭션 적용 여부는 메서드 단위 포인트컷 매칭으로 결정”되며, 프록시 기반인 탓에 self‑invocation은 가로채지 못합니다.[spring+1](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html)​

##### 왜 auto‑proxy와 연결되는가

- 트랜잭션 기능을 켜면(@EnableTransactionManagement, tx:annotation‑driven), 스프링은 @Transactional 메타데이터를 읽는 TransactionAttributeSource와 그를 사용하는 트랜잭션 어드바이저(BeanFactoryTransactionAttributeSourceAdvisor) 및 인터셉터를 인프라 빈으로 등록합니다(“proxy‑based annotation‑driven transaction management”).[spring+2](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/BeanFactoryTransactionAttributeSourceAdvisor.html)​
    
- 그런 다음 스프링의 auto‑proxy 메커니즘(DefaultAdvisorAutoProxyCreator/InfrastructureAdvisorAutoProxyCreator)이 모든 빈을 훑어보며 “어떤 어드바이저의 포인트컷이라도 이 빈의 메서드 중 하나에 매칭되는가?”를 평가하고, 하나라도 매칭되면 그 빈을 프록시로 감쌉니다(없으면 프록시 생성 자체가 없음).[spring](https://docs.spring.io/spring-framework/reference/core/aop-api/autoproxy.html)​
    
- 따라서 @Service 클래스의 “일부 메서드”에만 @Transactional이 있어도, 그 메서드가 존재하는 한 해당 서비스 빈은 “프록시 대상”이 되고, 호출 시 프록시는 “이 메서드가 트랜잭션 매칭 대상인가?”를 확인해 매칭된 메서드에만 TransactionInterceptor를 적용합니다(클래스의 다른 메서드는 평범히 통과).[spring+1](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/BeanFactoryTransactionAttributeSourceAdvisor.html)​
    

##### 핵심 Excerpts

- “The default advice mode for processing @Transactional annotations is proxy, which allows for interception of calls through the proxy only.”[spring](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html)​  
    쉬운 설명: @Transactional은 기본적으로 프록시 기반 AOP로 동작하며, 프록시를 통해 들어오는 호출만 가로챌 수 있다는 뜻입니다(그래서 프록시가 필수).[spring](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html)​
    
- “@EnableTransactionManagement … registers the Spring infrastructure beans necessary to enable proxy‑based annotation‑driven transaction management.”[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html)​  
    쉬운 설명: 트랜잭션 관리를 켜면 프록시 기반의 어노테이션 처리 인프라(어드바이저/인터셉터 등)를 자동으로 등록합니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html)​
    
- “BeanFactoryTransactionAttributeSourceAdvisor … Advisor driven by a TransactionAttributeSource, used to include a transaction advice bean for methods that are transactional.”[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/BeanFactoryTransactionAttributeSourceAdvisor.html)​  
    쉬운 설명: 이 어드바이저는 @Transactional 메타데이터를 읽는 소스에 의해 “트랜잭션 대상 메서드”를 포인트컷으로 잡아 트랜잭션 어드바이스를 적용하게 합니다(메서드 단위 매칭).[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/BeanFactoryTransactionAttributeSourceAdvisor.html)​
    
- “This class [AnnotationTransactionAttributeSource] reads Spring’s @Transactional annotation and exposes corresponding transaction attributes to Spring’s transaction infrastructure.”[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/AnnotationTransactionAttributeSource.html)​  
    쉬운 설명: 어떤 메서드/클래스에 @Transactional이 붙었는지 읽어 트랜잭션 속성으로 노출해주는 컴포넌트입니다.[spring](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/AnnotationTransactionAttributeSource.html)​
    
- “DefaultAdvisorAutoProxyCreator automatically evaluates the pointcut contained in each advisor, to see what (if any) advice it should apply to each business object… If no pointcut in any of the advisors matches any method in a business object, the object is not proxied.”[spring](https://docs.spring.io/spring-framework/reference/core/aop-api/autoproxy.html)​  
    쉬운 설명: 하나라도 매칭되는 메서드가 있으면 그 “빈 전체를 프록시로” 만들고, 매칭이 전혀 없으면 아예 프록시를 만들지 않습니다(즉, 프록시 생성 판단은 ‘빈 단위’, 매칭 판단은 ‘메서드 단위’).[spring](https://docs.spring.io/spring-framework/reference/core/aop-api/autoproxy.html)​
    
- “Spring AOP is proxy‑based… self invocation is not going to result in the advice… only external method calls coming in through the proxy are intercepted.”[spring+1](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html)​  
    쉬운 설명: 같은 클래스 내부에서 자기 메서드를 직접 호출하면 프록시를 거치지 않으므로 트랜잭션 어드바이스가 적용되지 않습니다.[spring+1](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html)​
    

##### 요점 정리

- 네, @Transactional 선언은 auto‑proxy와 직접 연결됩니다: 트랜잭션 어노테이션을 읽는 TransactionAttributeSource + 이를 사용하는 트랜잭션 어드바이저가 등록되고, auto‑proxy가 “매칭되는 메서드가 하나라도 있는 빈”을 통째로 프록시로 대체합니다.[spring+3](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/AnnotationTransactionAttributeSource.html)​
    
- 그러므로 “메서드 일부만 @Transactional인 경우”에도 그 서비스 빈은 프록시 대상이 되며, 실제 트랜잭션 적용은 호출된 메서드가 포인트컷에 매칭되느냐로 결정됩니다(빈 단위 프록시, 메서드 단위 적용).[spring+1](https://docs.spring.io/spring-framework/reference/core/aop-api/autoproxy.html)​
    

##### 실무 Tip

- 외부 호출만 인터셉트되므로, 같은 클래스 내부에서 @Transactional 메서드를 부르는 설계를 피하고, 필요하면 메서드를 다른 빈으로 분리하거나 self‑invocation 회피 전략을 쓰세요(AspectJ 모드 등).[spring+1](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html)​
    
- 클래스 레벨 @Transactional은 모든 public 메서드가 기본 매칭 대상이 되어 호출마다 트랜잭션 속성 평가를 거치고, 메서드 레벨은 지정한 메서드에만 매칭되지만 “프록시 생성” 자체는 둘 다 동일하게 이루어집니다(매칭이 하나라도 있으면 프록시 생성).[spring+1](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html)​


-> 솔직히 잘 모르겠다. 나중에 이해가 필요함.



### 동작 방식

@Transactional 어노테이션이 붙은 메소드가 호출 될때,
AOP 프록시가 해당 call 을 가로채 Transaction 을 시작.
정상 종료시 커밋, 런타임 Exception 발생시 롤백. (이래서 RuntimeException 써야지 Known Exception 쓰면 rollback 이 안됨)

그리고 이 흐름은 PlatformTransactionManager로 구현되고 스레드에 바인딩된 리소스와 동기화됨.

 또한 이 프록시는 JDK 동적 프록시 또는 CGLIB로 생성되며, 
 트랜잭션 속성(전파, 격리, readOnly, timeout, 롤백 규칙)에 따라 기존 트랜잭션 참여/중단 여부와 커밋/롤백 동작을 결정


- "스프링의 `@Transactional`은 AOP 기반 프록시를 통해 메서드 실행 전후에 트랜잭션 경계를 자동으로 설정합니다. 트랜잭션 매니저(PlatformTransactionManager)가 실제 트랜잭션의 시작, 커밋, 롤백을 담당하며, 트랜잭션의 전파(propagation), 격리(isolation), 타임아웃(timeout), readOnly 등의 속성도 어노테이션 파라미터로 세밀하게 제어할 수 있습니다."
    
- "이 방식은 선언적 트랜잭션 관리(declarative transaction management)로, 비즈니스 로직과 트랜잭션 관리 코드를 분리하여 유지보수성과 확장성을 높입니다."

```java
@Service
public class AccountService {
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
    public void transfer(Long amount, Account from, Account to) {
        // ... 비즈니스 로직 ...
    }
}
```


\[나의 답변]


---
@Transactional 어노테이션이 클래스 또는 메서드에 붙으면, 그 메서드를 포함하는 클래스 또는 적용된 클래스 - 그에 해당하는 빈을 AOP proxy 가 감쌈.  
이때, method 에만 Transactional 이 선언되면, 그 메서드를 포함하는 빈 자체를 AOP Proxy 가 감싸더라도 해당 method 에만 @Transacitonal 어노테이션이 적용됨.  

그리고 @Transactional 은 public 메소드에만 적용되며 그외, non-public 한 메서드에는 적용되지 않음
  
그래서 @Transacitonal 이 적용된 메서드를 호출하게 되면, 메서드의 호출을 AOP Proxy 가 뺏어서 트랜잭션을 시작함. 이는 즉 롤백포인트를 메서드가 시작하기 전에 설정한다는 의미이기도 함.  
그리고 메서드가 실행되는 와중에 runtime Exception 이 발생하면 rollback 됨. 이때, Runtime Exception 이 아니라 known Exception 이면 rollback 이 발생하지 않음.  
  
메서드가 끝까지 실행이 되면, AOP Proxy 가 commit 을 실행함으로써 DB 에 저장을 완료함.

---

> 보완 : @EnableTransactionManagement 활성화로 BPP가 트랜잭션 빈을 프록시 처리해야 한다는 전제




#### PlatformTransactionManager로 구현되고 스레드에 바인딩된 리소스와 동기화된다?



#### JDK 동적 프록시 또는 CGLIB로 생성 ?

















## (By AI Research) From main to ApplicationContext initialization


`@SpringBootApplication`이 붙은 클래스에서 `SpringApplication.run()`이 호출되면 다음과 같은 순서로 ApplicationContext가 초기화됩니다.

### 1. **SpringApplication 인스턴스 생성 및 초기화**

#### 주요 클래스/인터페이스:

- **SpringApplication**: Spring Boot 애플리케이션의 부트스트랩 클래스
    
- **ApplicationContextInitializer**: 컨텍스트 초기화 콜백
    
- **ApplicationListener**: 애플리케이션 이벤트 리스너
    

**동작**: `@SpringBootApplication` 분석 → primary sources 결정 → WebApplicationType 추론(SERVLET/REACTIVE/NONE) → ApplicationContextInitializer와 ApplicationListener 로딩

---

### 2. **ApplicationContext 생성**

#### 주요 클래스/인터페이스:

- **AnnotationConfigServletWebServerApplicationContext**: Servlet 웹 애플리케이션용 컨텍스트
    
- **AnnotationConfigApplicationContext**: 비웹 애플리케이션용 컨텍스트
    
- **GenericApplicationContext**: 범용 ApplicationContext 구현체
    
- **DefaultListableBeanFactory**: 핵심 bean factory 구현체
    

**동작**: WebApplicationType에 따라 적절한 ApplicationContext 구현체 인스턴스 생성. 이 단계에서 BeanFactory도 함께 생성됨.

---

### 3. **Environment 준비 및 설정**

#### 주요 클래스/인터페이스:

- **ConfigurableEnvironment**: 환경 설정 인터페이스
    
- **PropertySource**: 프로퍼티 소스 추상화
    
- **ProfilesEnvironment**: 프로파일 관리
    

**동작**: application.properties/yml 로딩 → 환경 변수 및 시스템 프로퍼티 추가 → 프로파일 활성화

---

### 4. **BeanDefinition 로딩 (설정 클래스 스캔)**

#### 주요 클래스/인터페이스:

- **BeanDefinitionReader**: BeanDefinition을 읽어들이는 인터페이스
    
- **AnnotatedBeanDefinitionReader**: 애노테이션 기반 BeanDefinition 리더
    
- **ClassPathBeanDefinitionScanner**: 클래스패스 스캐너
    
- **ConfigurationClassParser**: `@Configuration` 클래스 파서
    
- **BeanDefinition**: Bean의 메타데이터 정의
    

**동작**:

1. Primary source(`@SpringBootApplication` 클래스) 등록
    
2. `@ComponentScan` 처리로 `@Component`, `@Service`, `@Repository`, `@Controller` 스캔Pro-Spring-Boot-3-with-Kotlin.pdf+1​
    
3. `@Configuration` 클래스 내 `@Bean` 메서드 파싱
    
4. `@Import` 처리
    
5. 각 BeanDefinition을 BeanDefinitionRegistry에 등록
    

---

### 5. **AutoConfiguration 처리**

#### 주요 클래스/인터페이스:

- **EnableAutoConfiguration**: Auto-configuration 활성화 애노테이션
    
- **AutoConfigurationImportSelector**: Auto-configuration 클래스 선택
    
- **SpringFactoriesLoader**: META-INF/spring.factories 로더
    
- **ConditionalOnClass/ConditionalOnBean/ConditionalOnMissingBean**: 조건부 설정 애노테이션
    

**동작**:

1. `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일 읽기Pro-Spring-Boot-3.pdf+1​
    
2. 약 146개의 AutoConfiguration 클래스 로딩
    
3. `@Conditional` 애노테이션 평가로 조건에 맞는 설정만 활성화
    
4. 예: `WebMvcAutoConfiguration`은 Servlet 클래스가 클래스패스에 있을 때만 활성화Pro-Spring-Boot-3-with-Kotlin.pdf+1​
    

---

### 6. **BeanFactoryPostProcessor 실행**

#### 주요 클래스/인터페이스:

- **BeanFactoryPostProcessor**: BeanFactory 후처리 인터페이스
    
- **BeanDefinitionRegistryPostProcessor**: BeanDefinition 등록 후처리자
    
- **ConfigurationClassPostProcessor**: `@Configuration` 클래스 후처리
    
- **PropertySourcesPlaceholderConfigurer**: 프로퍼티 플레이스홀더 해결
    

**동작**:

1. BeanDefinition 수정 가능
    
2. `${property}` 같은 플레이스홀더 해결
    
3. 추가 BeanDefinition 등록 가능Pro-Spring-5.pdf+1​
    

---

### 7. **Bean 인스턴스화 및 의존성 주입**

#### 주요 클래스/인터페이스:

- **AbstractAutowireCapableBeanFactory**: Bean 생성 및 의존성 주입 담당
    
- **InstantiationStrategy**: Bean 인스턴스화 전략
    
- **BeanWrapper**: Bean 프로퍼티 설정
    
- **AutowiredAnnotationBeanPostProcessor**: `@Autowired` 처리
    
- **CommonAnnotationBeanPostProcessor**: `@Resource`, `@PostConstruct`, `@PreDestroy` 처리
    

**동작**:

1. Constructor Injection 먼저 처리
    
2. Setter/Field Injection 처리
    
3. 의존성 순서에 따라 Bean 생성 (순환 참조 감지)
    

---

### 8. **BeanPostProcessor 실행**

#### 주요 클래스/인터페이스:

- **BeanPostProcessor**: Bean 초기화 전후 처리
    
- **ApplicationContextAwareProcessor**: Aware 인터페이스 처리
    
- **InitDestroyAnnotationBeanPostProcessor**: 초기화/소멸 메서드 처리
    

**동작**:

1. `postProcessBeforeInitialization()` 호출
    
2. Bean 초기화 (`@PostConstruct`, `InitializingBean.afterPropertiesSet()`, custom init-method)
    
3. `postProcessAfterInitialization()` 호출
    
4. AOP 프록시 생성 (필요시)Spring-5-Design-Patterns.pdf+1​
    

---

### 9. **ApplicationContext refresh() - 컨텍스트 새로고침**

#### 주요 클래스/인터페이스:

- **AbstractApplicationContext**: `refresh()` 메서드 구현
    
- **LifecycleProcessor**: 라이프사이클 관리
    
- **SmartLifecycle**: 라이프사이클 확장 인터페이스
    

**동작**:

1. 모든 singleton bean 초기화 완료
    
2. `LifecycleProcessor.onRefresh()` 호출
    
3. **ContextRefreshedEvent** 발행[stackoverflow](https://stackoverflow.com/questions/61248736/execution-process-in-spring-boot)​
    

---

### 10. **웹 서버 시작 (웹 애플리케이션인 경우)**

#### 주요 클래스/인터페이스:

- **ServletWebServerApplicationContext**: 서블릿 웹 서버 컨텍스트
    
- **WebServerStartStopLifecycle**: 웹 서버 라이프사이클
    
- **TomcatServletWebServerFactory**: 내장 Tomcat 서버 팩토리
    

**동작**:

1. 내장 웹 서버(Tomcat/Jetty/Undertow) 생성
    
2. 서블릿 컨텍스트 초기화
    
3. DispatcherServlet 등록
    
4. 웹 서버 시작
    

---

### 11. **ApplicationRunner/CommandLineRunner 실행**

#### 주요 클래스/인터페이스:

- **ApplicationRunner**: 애플리케이션 시작 후 실행할 로직 인터페이스
    
- **CommandLineRunner**: 커맨드라인 인자 기반 실행 로직[javacodemonk](https://www.javacodemonk.com/run-method-on-application-startup-in-spring-boot-75580658)​Pro-Spring-Boot-3-with-Kotlin.pdf​
    

**동작**: `ApplicationArguments` 전달하여 실행. `@Order` 애노테이션으로 순서 지정 가능Pro-Spring-Boot-3-with-Kotlin.pdf​

---

### 12. **ApplicationStartedEvent 및 ApplicationReadyEvent 발행**

#### 주요 클래스/인터페이스:

- **SpringApplicationRunListeners**: 이벤트 발행 관리
    
- **ApplicationStartedEvent**: 컨텍스트 refresh 완료 이벤트
    
- **ApplicationReadyEvent**: 애플리케이션 준비 완료 이벤트Pro-Spring-Boot-3-with-Kotlin.pdf​
    

**동작**: 외부 요청 수락 가능 상태 알림

---

### 주요 설정 관련 처리

#### **@Configuration + @Bean**

- **ConfigurationClassParser**: 파싱 담당
    
- **ConfigurationClassBeanDefinitionReader**: BeanDefinition 등록
    

#### **@ComponentScan**

- **ClassPathBeanDefinitionScanner**: 패키지 스캔
    
- **AnnotationTypeFilter**: 애노테이션 필터링
    
- `basePackages` 또는 `@SpringBootApplication` 패키지 기준 스캔Pro-Spring-Boot-3.pdf+1​
    

#### **@Conditional 처리**

- **ConditionEvaluator**: 조건 평가
    
- **OnClassCondition/OnBeanCondition/OnPropertyCondition**: 구체적 조건 구현
    
- AutoConfiguration 활성화 여부 결정Pro-Spring-Boot-3.pdf+1​
    

---

### 초기화 완료 후 상태

- 모든 singleton bean이 초기화되고 의존성이 주입된 상태
    
- ApplicationContext가 완전히 준비되어 `getBean()` 호출 가능Spring-in-Action-Sixth-Edition.pdf+1​
    
- 웹 애플리케이션은 HTTP 요청 수락 준비 완료
    
- 애플리케이션이 Use Phase에 진입
    

---

**핵심 포인트**:

Spring Core만 있다는 가정에서도 위 과정의 핵심 흐름은 동일하며, 웹 관련 부분(10번)만 제외됩니다. Spring Boot는 이 전통적인 Spring Framework의 초기화 과정을 자동화하고 간소화한 것입니다.Pro-Spring-5.pdf+2​



