## `@Transactional` 코드 열어보기 구현체 어떻게 되어있는지


나 솔직히 봐도 모르겠다. 무엇을 봐야하는지??


- 애너테이션 메타데이터는 AnnotationTransactionAttributeSource가 RuleBasedTransactionAttribute로 변환해 트랜잭션 속성(전파, 격리, 타임아웃, 롤백 규칙 등)을 제공합니다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html)​
    
- @EnableTransactionManagement가 켜지면 ProxyTransactionManagementConfiguration이 BeanFactoryTransactionAttributeSourceAdvisor를 등록하고, 이 Advisor의 포인트컷이 @Transactional 메서드만 골라 TransactionInterceptor 어드바이스를 적용합니다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/ProxyTransactionManagementConfiguration.html)​
    
- TransactionInterceptor는 TransactionAspectSupport.invokeWithinTransaction(...)에 위임하여 적절한 TransactionManager를 선택하고, 필요 시 트랜잭션을 시작하고, 정상 반환 시 커밋하고, 예외 시 롤백 규칙을 평가해 롤백을 수행합니다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/TransactionInterceptor.html)​


@Transactional annotation 을 사용하려면 반드시  반드시 `@EnableTransactionManagement`가 필요하다고 함. 
Spring boot  에서는 내부적으로 @EnableTransactionManagement 을 등록해줌.

@EnableTransactionManagement 를 등록해야 Transaction AOP 인프라가 등록이 됨.

### Transaction AOP 인프라 구성 요소

Spring의 트랜잭션 AOP 인프라는 아래와 같은 주요 컴포넌트로 구성됩니다:

1. BeanFactoryTransactionAttributeSourceAdvisor
    
    - @Transactional이 붙은 메서드를 포인트컷(Pointcut)으로 잡아내는 Advisor 역할을 합니다.
        
    - 내부적으로 TransactionAttributeSource를 사용해서 트랜잭션 속성을 읽어옵니다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/BeanFactoryTransactionAttributeSourceAdvisor.html)​
        
2. TransactionInterceptor
    
    - 실제 트랜잭션 관리 로직(시작, 커밋, 롤백 등)을 수행하는 Advice입니다.
        
    - 메서드 실행 전후로 트랜잭션을 시작/종료하며, 예외 발생 시 롤백 규칙을 적용합니다.[](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-decl-explained.html)​
        
3. PlatformTransactionManager (혹은 ReactiveTransactionManager)
    
    - 실제 트랜잭션을 관리하는 구현체입니다. DataSourceTransactionManager, JpaTransactionManager 등 다양한 구현이 있습니다.
        
    - TransactionInterceptor가 이 매니저를 통해 트랜잭션을 제어합니다.[](https://docs.spring.io/spring-framework/docs/4.1.0.RC2/spring-framework-reference/html/transaction.html)​
        
4. TransactionAttributeSource
    
    - @Transactional 애너테이션의 속성(전파, 격리, 롤백 규칙 등)을 읽어오는 역할을 합니다.
        
    - AnnotationTransactionAttributeSource가 대표적입니다.

### 동작 흐름

5. @EnableTransactionManagement가 활성화되면 위 Advisor/Interceptor/Manager가 빈으로 등록됨.
    
6. Advisor가 @Transactional이 붙은 메서드를 가진 빈을 프록시로 감쌈.
    
7. 프록시가 메서드 호출을 가로채서 TransactionInterceptor를 실행.
    
8. TransactionInterceptor가 TransactionManager를 통해 트랜잭션을 시작/커밋/롤백.


## java에서의 synchronized 사용법 3가지 케이스


### 인스턴스 메서드에 붙여 this 모니터를 잠그는 방법

```java

public class Counter {
  private int value;

  // 1) 인스턴스 메서드에 synchronized
  public synchronized void increment() {
    value++; // 이 메서드 전체가 this 모니터로 보호됨
  }

  public synchronized int get() {
    return value; // 가시성(visibility)도 보장됨
  }

  // 예: 여러 스레드가 같은 Counter 인스턴스를 공유
  public static void main(String[] args) throws InterruptedException {
    Counter c = new Counter();
    Thread t1 = new Thread(() -> { for (int i = 0; i < 1_000_000; i++) c.increment(); });
    Thread t2 = new Thread(() -> { for (int i = 0; i < 1_000_000; i++) c.increment(); });
    t1.start(); t2.start();
    t1.join(); t2.join();
    System.out.println(c.get()); // 2,000,000 보장
  }
}
```


-> method 에 synchonized 를 붙여서 어떤 스레드가 먼저 해당 메서드에 대한 락을 획득해서 실행하는 동안 다른 스레드는 해당 메서드의 락을 얻을때까지 기다려야한다.
그리고 스레드가 해당 메서드의 실행이 끝나면 반드시 락을 반환하게끔 되어있음.

메서드의 실행 자체를 막는 것이기때문에,
위 예시에서 value에 접근하는 다른 메서드가 있다면 increment에 적용한 의도가 망가져 꼬일 수 있게 됨.


get 에도 synchronized keyword 를 붙여 가시성을 확보 - 즉 최신값을 보게한다고 나와있는데, 이게 당연히 와닿지 않는다.

이걸 알면 된다 -> synchronized 메서드는 모두 this monitor 락으로 설정된다. this -> class.
그래서 increment 와 get 이 동시에 실행이 안된다.

instance method 에 synchronized keyword 가 붙으면, 객체마다의 this monitor 락이 설정되고
static method 이면 클래스 자체에 하나의 monitor lock 이 설정된다.



#### 작동 원리

- JLS는 “인스턴스 메서드가 synchronized이면 this의 모니터를 사용한다”고 명시하며, 메서드에 붙인 synchronized와 블록의 synchronized(o)가 동일한 종류의 모니터를 사용한다고 설명합니다.​
    
- JVM은 ACC_SYNCHRONIZED 플래그가 설정된 메서드 호출 시 모니터 진입/반환을 암묵적으로 수행하고, 예외로 비정상 종료해도 모니터를 자동으로 해제합니다.​
    
- 락 획득/해제는 메모리 가시성까지 보장하므로, 읽기/쓰기 순서 교란 없이 최신 값을 관찰하도록 합니다(락은 재진입 가능하며 happens-before를 성립시킴).​
    

#### 주의 사항

- 인스턴스 synchronized와 static synchronized는 서로 다른 모니터(this vs Class 객체)라 동시에 진입할 수 있으니 보호 대상이 인스턴스인지 클래스 정적 상태인지에 따라 올바른 락을 선택해야 합니다.​
    
- synchronized 블록을 쓰면 락 범위를 더 좁혀 과도한 임계 구역을 줄일 수 있으나, 반드시 동일 락 객체를 일관되게 사용해야 합니다(모니터엔터/엑시트는 컴파일러가 예외 시에도 짝을 보장).​
    
- Vector 등 외부 객체의 내부 락에 기대는 client-side locking은 구현 세부에 종속되어 깨지기 쉬우므로 권장되지 않습니다(라이브러리가 그 락 계약을 보장한다는 약속이 없음).



### static 메서드에 붙여 Class 객체 모니터를 잠그는 방법


static synchronized 메서드는 클래스 전체에 하나뿐인 락(`ClassName.class` 모니터)을 잡으며,
모든 인스턴스가 이 락을 공유한다.

### synchronized(expression) 블록으로 원하는 락 객체의 모니터를 잠그는 방법


```java
class BankAccount {
  private int balance;
  private final Object lock = new Object();

  // 임계 구역을 lock 객체로 보호
  public void deposit(int amount) {
    synchronized(lock) {
      balance += amount;
    }
  }

  // this 객체로 보호
  public void withdraw(int amount) {
    synchronized(this) {
      balance -= amount;
    }
  }

  // 클래스 전체 공유 상태 보호
  public static void log(String msg) {
    synchronized(BankAccount.class) {
      System.out.println(msg);
    }
  }
}
```

expression 에 어떤 락을 걸지 설정한다.

this 락의 경우 해당 객체의 모든 인스턴스 메서드와 락을 공유한다. 그말인 즉슨

```java

public void withdraw(int amount) {
    synchronized(this) {
      balance -= amount;
    }
  }

public synchronized withdraw(int amount) {
	this.balance -= amount;
}
```

위 2개가 동일한 방식으로 동작한다는 것.



BankAccount.class 는 클래스 자체의 락으로써 모든 인스턴스가 공유하는 락이므로,

```java
  public class BankAccount {
  // 1. static synchronized 메서드
  public static synchronized void logA(String msg) {
    System.out.println(msg);
  }

  // 2. synchronized(BankAccount.class) 블록
  public static void logB(String msg) {
    synchronized(BankAccount.class) {
      System.out.println(msg);
    }
  }
}
```

이렇게 선언된 두 함수는 똑같이 같은 락을 공유한다.


객체를 따로 선언해서 쓰는 방법은 나중에 lock 을 재설정할 수 있는 부분이 있다.
근데 이게 무턱대고 장점은 아니라고 함.

위 코드에서
```java
class BankAccount {
  private int balance;
  private final Object lock = new Object();
```
BankAccount 의 lock 참조에 다른 객체를 집어넣으면

```java
public void deposit(int amount) {
    synchronized(lock) {
      balance += amount;
    }
  }
```

deposit 이 실행시 대입한 lock 을 사용하게 된다. 즉 런타임에 락을 교체할 수 있음.
또, BankAccount 의 생성시점에도 lock 을 설정할 수 있다. (Constructor 에)

근데 런타임에 락을 교체하는건 권장하는 방법이 아니라고 함.







## Spring core 만으로 일체의 어노테이션 없이 DI 를 구현하려면 어떻게 해야 할까요?

### SmartInitializingSingleton 의 afterSingletonsInstantiated 을 구현

```java
@Component  
@Lazy(false)  
public class AfterAllSingletonsHook implements SmartInitializingSingleton {  
  
    private final ApplicationContext ctx;  
  
    public AfterAllSingletonsHook(ApplicationContext ctx) {  
        this.ctx = ctx;  
    }  
  
    @Override  
    public void afterSingletonsInstantiated() {  
        CustomService customService = new CustomService();  
  
        UserService userService = ctx.getBean(UserService.class);  
        userService.setCustomService(customService);  
    }  
}
```

-> SmartInitializingSingleton.afterSingletonsInstantiated()는 SpringApplication.run() 내부의 
ApplicationContext.refresh() 과정 중, finishBeanFactoryInitialization 단계에서 
“모든 일반 싱글톤이 사전 인스턴스화된 직후”에 호출되는 훅을 캡처. 
즉, ContextRefreshedEvent가 publish되기 “직전”이며, 
Boot의 ApplicationStartedEvent와 Runner, 그리고 ApplicationReadyEvent보다 이전 시점.

#### 수명주기에서의 위치

- ApplicationContext 리프레시 과정에는 finishBeanFactoryInitialization(...) 단계가 있으며, 이 단계에서 “남아 있는 싱글톤 초기화 마무리”가 진행된다(메서드 시그니처와 역할은 클래스 Javadoc/메서드 목록으로 명시).[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html)​  
    → 쉬운 말: refresh()의 막바지에 finishBeanFactoryInitialization가 호출되며, 여기서 싱글톤 초기화가 마무리된다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html)​
    
- DefaultListableBeanFactory.preInstantiateSingletons()는 “Ensure that all non‑lazy‑init singletons are instantiated”로 설명되며, non‑lazy 싱글톤들을 실제로 인스턴스화하는 루프를 돈다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​  
    → 쉬운 말: lazy가 아닌 싱글톤들을 전부 실제 객체로 만든다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​
    
- SmartInitializingSingleton.afterSingletonsInstantiated는 바로 이 “싱글톤 사전 인스턴스화(pre‑instantiation) 단계의 끝”에서 호출되는 것으로 문서화되어 있어, 컨테이너의 finishBeanFactoryInitialization → preInstantiateSingletons 흐름이 끝날 무렵 실행되는 후처리 콜백이라 보면 된다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/DefaultListableBeanFactory.html)​  
    → 쉬운 말: preInstantiateSingletons가 non‑lazy 싱글톤들을 다 만든 다음, 그 끝자락에 SmartInitializingSingleton 콜백이 불린다고 이해하면 정확하다.[](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html)​

쉽게 말해서 

근데 이건 @Component 와 @Override 를 사용하기 때문에 어떻게 보면 어노테이션을 사용한다고 볼 수 있다.

그리고 Annotation 을 쓰길래 실제로 테스트해보진 않음.


### Hook 을 main function 에서 설정.



```java
@RestController  
@RequestMapping("/api/users")  
@RequiredArgsConstructor  
@Slf4j  
public class UserController {  
  
    private final UserService userService;  
  
  
  
    /**  
     * CustomService 테스트 API  
     * GET /api/users/hello     ** @return CustomService의 hello() 메서드 실행 결과  
     */  
    @GetMapping("/hello")  
    public ResponseEntity<String> getHelloMessage() {  
        log.info("GET /api/users/hello - CustomService hello 메서드 호출 요청");  
          
        String message = executeCustomServiceHello();  
          
        return buildHelloSuccessResponse(message);  
    }
    
    ....
}
```

```java
@Service  
@RequiredArgsConstructor  
@Slf4j  
public class UserService {  
  
    private final UserRepository userRepository;  
  
    public CustomService customService;  
  
    public void setCustomService (CustomService customService) {  
        this.customService = customService;  
    }  
  
    public String customServiceHello () {  
        return customService.hello();  
    }
    
    ....
}
```

```java
package com.example.demo.service;  
  
public class CustomService {  
    public String hello () {  
        return "                                       Hello!";  
    }  
}
```


![[Screenshot 2025-10-15 at 1.16.08 PM.png]]

일단 이 상태에서 안되는거 확인.




```java
@SpringBootApplication  
public class DemoApplication {  
  
    public static void main(String[] args) {  
        SpringApplication app = new SpringApplication(DemoApplication.class);  
  
        app.addInitializers(ctx -> {  
            if (ctx instanceof GenericApplicationContext gac) {  
                gac.registerBean(SmartInitializingSingleton.class, () -> () -> {  
  
                    UserService userService = ctx.getBean(UserService.class);  
                    userService.setCustomService(new CustomService());  
  
                });  
            }  
        });  
  
        app.run(args);  
    }    
}
```

적용후.


![[Screenshot 2025-10-15 at 1.27.06 PM.png]]

성공.



컨텍스트가 만들어지기 전에 SpringApplication에 훅을 심고(addInitializers), 
run()이 컨텍스트를 생성·refresh하는 동안 그 훅이 실행되어 
콜백 빈(SmartInitializingSingleton)을 등록하고, 
모든 싱글톤 초기화 직후 그 콜백이 실행되면서 UserService를 조작하는 흐름.

