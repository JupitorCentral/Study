
## Blocking, non-blocking, Synchronize, Asynchronize

메시지 전달 문맥에서는 blocking≈synchronous, non-blocking≈asynchronous로 쓰이기도 하지만
I/O 문맥에선 non-blocking과 asynchronous를 명확히 구분함.

### blocking, non-blocking, asynchronous, synchronous

(공룡책에서)
system call interface 와 연관된 점에 있어서는 blocking i/o, non-blocking i/o 를 사용할 건지가 있다.

application 이 blocking system call 을 호출하면, application 의 실행이 멈춤/지연됨 (suspended)
application 이 OS 의 run queue 에서 wait queue 로 옮겨짐 (상태가 바뀐다는 얘기인듯)
blocking 시스템 콜이 끝난 후에야 다시 applicatioin 이 실행됨
system call 완료되면 실행 재개
실행이 재개되면 i/o 로부터 app 이 값을 전달받고 wait queue -> run queue

i/o device 의 물리적 동작은 일반적으로 asynchronous 하다 - 예측 불가능한 시간을 소모함.


어떤 user-level 프로세스는 non-blocking i/o 가 필요함 - 예를 들면 화면에 데이터를 보여주고 데이터를 처리하는 동안
keyboard 와 mouse input을 받는 user interface.
다른 예로는 동영상의 압축을 풀고 그 결과물을 화면에 표시하면서 동시에 디스크에 있는 파일로부터 프레임을 읽는 비디오 어플리케이션 등이 있음.

(non-blocking i/o request 는 i/o 의 return 을 기다리지 않고 다른 일을 하러 가는건가? 프로세스가 ?)
nonblocking (system) call 은 어떤 연장된 시간만큼 어플리케이션의 실행을 halt, 즉 중지 하지 않음.
대신에 그 call 은 재빨리, 얼마나 많은 bytes 가 전달됬는지를 알려주는 값을 return 함.
(그러니까 어느정도 시간이 지나고 나면 특정 시간동안 했던 결과물을 return 해 주는 것을 의미하는 듯 함)


---

non-blocking system 의 대안으로는 asynchronous system 이 있다.
asynchronous call 은 i/o 의 완료를 기다리는 것 없이 즉시 return 함.
어플리케이션 코드는 계속 자기 코드를 실행함.
그리고, i/o 가 미래에 완료되고 나면 그때 application 에 알려줌 - 
어플리 케이션의 선형의 흐름 밖에서 일어나는 -
어플리케이션의 주소 공간의 어떤 변수를 설정한다거나, signal 이나 software interrupt 나 call-back routine 등의 방법으로 말이다.


non-blocking system 과 asynchronous system 의 차이는
먼저 nonblocking read() 는 어떤 data 가 이용가능하던간에 일단 즉시 값을 읽어오는 것을 의미함.
-> full number of bytes requested, fewer, or none at all
-> 그러니까 요청한 데이터를 다 얻거나, 적게 얻거나 아니면 아예 아무것도 못 얻거나

반면 asynchronous 는 I/O 가 완전히 실행이 되긴 될건데 그게 어플리 케이션이 실행을 막지 않고
다 수행되면 나중에 application 에게 알려 돌려주는 것이 다름.


nonblokcing behavior 의 좋은 예시는 network 소켓에서의 select() system call 임.


동기적 시스템 콜(synchronous system call)은 호출된 작업이 끝날 때까지 
호출한 스레드/프로세스가 돌아오지 않는, 즉 완료 시점과 반환 시점이 일치하는 호출.

일반적으로는 blocking 이랑 synchronous call 이 같은 의미로 쓰인다는데...

그럼 도대체 아래의 조합은 뭐지?

서로 다른 프로세스에 대해서 한쪽은 blocking, 한쪽은 asynchronous 하게 뭐 그런건가?

일단 잘 모르겠다. 

근데 개념만 제대로 짚고 있으면 어떤 질문이 와도 해결 가능할듯.

- Blocking + Synchronize
- non-blocking + Synchronize
- Blocking + Asynchronize
- non-blocking + Asynchronize

---

Spring 에서는 또 애기가 다르다.

Blocking vs Non‑blocking은 “호출한 스레드가 자원/결과를 기다리며 멈추는가(wait) vs 기다리지 않고 다른 일을 계속하는가
Synchronous vs Asynchronous는 “호출이 완료 시점과 제어 흐름이 결합되어 즉시 결과를 받는가 vs 호출은 즉시 반환하고 완료 통지는 나중에 콜백/이벤트/퓨처 등으로 받는가”


>AsyncRestTemplate는 “non‑blocking interactions”를 제공하지만 근본적으로 InputStream/OutputStream 기반이라 non‑blocking streaming을 못함 → 비동기 API + 블로킹 I/O



Spring 5 Design patterns 에서는 먼저 Blocking calls 에 대해 얘기한다.

하나의 call 은 동일한 리소스에 대해 다른 쓰레드들이 기다리고 있을떄, 그 자원을 hold 할 수 있다.

> blocking a call means some operations in the application or system that take a longer time to complete, such as file I/O operations and database access using blocking drives.

blocking a call -> call 을 blocking 하는 것.


또 Spring 5 Design patterns 에서는 non-blocking calls 에 대해 이렇게 얘기한다.

>A non-blocking API for the resources allows calling the resources without 
>waiting for the blocked call such as database access and network calls. 

-> non-blocking api 는 db 접근이나 network call 과 같은 blocked call 을 기다리지 않고 resource 를 call 할 수 있게 해준다.
-> 그러니까 resource 가 blocked 이든 아니든 call  자체는 할 수 있지만, 해당 리소스가 blocked 됬다고 해서 
쓰레드가 그 resource 를 기다리지 않는 것.

그리고 resource 가 호출시 이용가능하지 않을때, thread 는 blocked 된 resource 를 기다리기 보다 다른 일을 하고,
그 blocked resources 가 이용가능해질때 notified, 즉 알람을 받는다.


드디어 알겠다.
blocking / non-blocking 은 스레드의 상태가 cpu 의 runnable 에서 벗어나는가 아닌가 이다.
즉 sleep 이냐 running 이냐의 차이이다.

synchronous / asynchronous 의 차이는 i/o 등의 요청에 대해서 기다리고 있느냐 아니냐의 차이이다.



### Blocking, Non-blocking, Synchronous, Asynchronous 조합별 결과 획득 방식과 사용 예시

아래 표는 각 조합별로 **결과를 획득하는 방식**(polling, callback 등)과 **적합한 사용 상황**, 그리고 **간단한 예시**를 정리한 것입니다.

|조합|결과 획득 방식|언제 쓰면 좋은가|예시|
|---|---|---|---|
|**Blocking + Synchronous**|직접 반환값을 기다림 (thread가 대기)|단순/순차적 작업, low traffic, 코드 단순성 중시|`read()`/`write()` system call, JDBC, `f.read()` in Python|
|**Blocking + Asynchronous**|callback 등록, 하지만 thread는 대기 (비효율적)|드물게 사용, 레거시 async API + 내부 blocking I/O|POSIX AIO + `aio_suspend()`, AsyncRestTemplate (Spring)|
|**Non-blocking + Synchronous**|polling (반복 상태 확인)|I/O multiplexing, 여러 작업 동시 polling, event loop|`select()`, `poll()`, Java NIO `Selector`, busy-waiting loop|
|**Non-blocking + Asynchronous**|callback, event, promise 등 (event-driven)|고성능 서버, high concurrency, event-driven, 리액티브|Node.js `fs.readFile()`, Python `asyncio`, Java WebFlux, Linux AIO + signal|

---

### 각 조합별 간단 설명 및 예시 코드

#### 1. **Blocking + Synchronous**

- **결과 획득:** 함수가 끝날 때까지 thread가 대기, 반환값 직접 사용
    
```java
/// JDBC로 DB 조회 (blocking + synchronous)
@Repository
public class UserRepository {
    public User findById(Long id) {
        String sql = "SELECT id, name, email FROM users WHERE id = ?";
        
        // Thread가 DB 응답까지 멈춰서 기다림 (blocking)
        // 결과를 직접 받아서 반환 (synchronous)
        return jdbcTemplate.queryForObject(sql, 
            (rs, rowNum) -> new User(
                rs.getLong("id"),
                rs.getString("name"),
                rs.getString("email")
            ),
            id
        );
    }
}

```

##### 🎯 무엇을 하는가?

- DB에 SQL 쿼리를 보내고, **결과가 올 때까지 thread가 멈춰서 기다림**​
    
- 결과가 도착하면 **그 자리에서 바로 User 객체로 변환해서 반환**​
    

##### ✅ 어떤 상황에 쓰면 좋은가?

- **게시판, 관리자 페이지** 같은 low traffic 서비스[](https://stackoverflow.com/questions/27991709/what-are-the-advantages-to-blocking-code-over-non-blocking-code)​
    
- **결제, 주문** 같은 순서가 중요한 transaction[](https://kissflow.com/application-development/asynchronous-vs-synchronous-programming/)​
    
- **배치 작업** (데이터 마이그레이션, 야간 정산)[](https://stackoverflow.com/questions/27991709/what-are-the-advantages-to-blocking-code-over-non-blocking-code)​
    
- **코드 단순성**이 중요하고, 트래픽이 낮을 때[](https://www.mendix.com/blog/asynchronous-vs-synchronous-programming/)​

#### 2. **Blocking + Asynchronous**

- **결과 획득:** polling (반복적으로 상태 확인)

```java
// WebFlux로 HTTP 요청 (non-blocking + async)
@Service
public class UserService {
    private final WebClient webClient;
    
    public void fetchUserAsync(Long id) {
        System.out.println("1. 요청 시작");
        
        // Thread는 즉시 반환 (non-blocking)
        // 결과는 나중에 callback으로 처리 (asynchronous)
        webClient.get()
            .uri("/users/" + id)
            .retrieve()
            .bodyToMono(User.class)
            .subscribe(
                user -> System.out.println("3. 결과 도착: " + user), // 성공 callback
                error -> System.err.println("에러: " + error)       // 실패 callback
            );
        
        System.out.println("2. Thread는 다른 일을 함");
        
        // 출력 순서: 1 → 2 → 3
    }
}
```
    
##### 🎯 무엇을 하는가?

- HTTP 요청을 보내고, **thread는 즉시 반환되어 다른 일을 함**​
    
- HTTP 응답이 도착하면, **미리 등록한 callback(람다식)이 실행**되어 결과 처리​
    

##### ✅ 어떤 상황에 쓰면 좋은가?

- **실시간 채팅, 알림, 스트리밍** 같은 event-driven 서비스​
    
- **마이크로서비스** 간 API 호출 (여러 서비스를 동시에 호출)​
    
- **높은 트래픽** (동시 접속자 만 명 이상)[](https://techblog.bozho.net/why-non-blocking/)​
    
- **외부 API 응답이 느린 경우** (200ms 이상 latency)​


#### 3. **Non-blocking + Synchronous**

```java
// NIO Selector로 여러 소켓 polling (non-blocking + sync)
public class NonBlockingSyncServer {
    public void handleConnections() throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.configureBlocking(false); // Non-blocking 설정
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        while (true) { // Polling loop (synchronous)
            // Thread는 멈추지 않고 즉시 반환 (non-blocking)
            int ready = selector.selectNow();
            
            if (ready == 0) {
                // 아직 준비된 소켓 없음
                Thread.sleep(10); // CPU 낭비 줄이기
                continue; // 다시 확인 (caller가 직접 polling)
            }
            
            // 준비된 소켓들 처리
            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            for (SelectionKey key : selectedKeys) {
                if (key.isAcceptable()) {
                    // 새 연결 수락
                }
            }
            selectedKeys.clear();
        }
    }
}
```

##### 🎯 무엇을 하는가?

- 여러 소켓을 **반복해서 확인(polling)**하며, 준비된 소켓이 있는지 체크[](https://01.me/en/2014/11/sync-async-blocked/)​
    
- Thread는 **멈추지 않고(non-blocking)** 계속 돌면서, **caller가 직접 상태 확인(synchronous)**[](https://stackoverflow.com/questions/26541119/whats-different-between-the-blocked-and-busy-waiting)​
    

##### ✅ 어떤 상황에 쓰면 좋은가?

- **Nginx, Redis** 같은 I/O multiplexing 서버[](https://01.me/en/2014/11/sync-async-blocked/)​
    
- **한 thread가 수천 개의 connection을 관리**할 때[](https://01.me/en/2014/11/sync-async-blocked/)​
    
- **게임 루프** (60 FPS로 상태 반복 체크)[](https://stackoverflow.com/questions/26541119/whats-different-between-the-blocked-and-busy-waiting)​
    
- **임베디드 시스템** (하드웨어 상태 polling)[](https://www.reddit.com/r/embedded/comments/1lmt5y3/blocking_vs_nonblocking_io/)​


#### 4. **Non-blocking + Asynchronous**

```java
// AsyncRestTemplate (Spring, deprecated - 비효율적)
@Service
public class UserService {
    private final AsyncRestTemplate asyncTemplate;
    
    public void fetchUserAsync(Long id) {
        String url = "http://api.example.com/users/" + id;
        
        // Callback 등록 (asynchronous)
        ListenableFuture<ResponseEntity<User>> future = 
            asyncTemplate.getForEntity(url, User.class);
        
        future.addCallback(
            user -> System.out.println("결과: " + user.getBody()), // Callback (async)
            ex -> System.err.println("에러: " + ex)
        );
        
        // 하지만 내부적으로 InputStream.read()는 blocking!
        // → Thread가 HTTP 응답까지 대기 (blocking)
    }
}

```


##### 🎯 무엇을 하는가?

- API 호출 후 **callback을 등록**(async처럼 보임)​
    
- 하지만 **내부 I/O(InputStream)는 blocking**이라 thread가 실제로는 **대기함**​
    
- **Async의 장점(thread 반환)도 없고, blocking의 단순함도 없는 비효율적 조합**[](https://dev-yyh.github.io/en/OS/9)​
    

##### ✅ 어떤 상황에 쓰면 좋은가?

- **거의 쓰면 안 됨!**[](https://dev-yyh.github.io/en/OS/9)​​
    
- 레거시 코드에서 **실수로** 이런 패턴이 나타날 수 있음
    
- **대안**: AsyncRestTemplate 대신 **WebClient** 사용​



## 어떻게 해야 synchronized 의 성능을 개선할 수 있을까 ?
-> java.util.concurrent

일단 synchronized 의 성능을 개선하려면

어떤 자원에 대해서 얘가 반드시 syncrhronized 가 필요한지, 또 어떻게 하면 가능한한 병렬적으로 처리할 수 있을지 고민
(병렬적 처리 -> 동시성)







## GC - Mark and Sweep, Card table, GC Root, MetaSpace


### Mark and Sweep

- 작동 개요: GC는 GC roots에서 시작해 살아있는 객체에 마크 비트를 세팅하고, 표시되지 않은 객체를 순회하며 메모리를 회수(sweep)한다.​
    
- 장단점: 구현이 단순하고 dangling pointer를 피하지만, “sweep만” 하면 단편화(fragmentation)가 남아 추가 compaction 또는 복사(evacuation)가 필요해질 수 있다.

(from Optimizing Cloud Native Java)

Mark and Sweep 의 구체적 프로세스를 많은 개발자들이 리콜하는데 어려움을 겪는다.

#### overall of Mark and Sweep algorithm
(여기서 안내하는 내용은 컨셉의 이해를 위해 의도적으로 간소화된 내용. 실제로 내부적으로 이렇게 동작하지는 않는다)

1. Loop through the allocated list, clearing the mark bit.
   -> 할당된 list 를 돌면서 mark bit 을 먼저 없앤다.
2. Starting from any pointers into the heap, find all the objects you can.
   -> heap 을 가리키는 포인터들 중 아무거나 하나로부터 시작해서, 모든 객체를 찾는다.
   -> heap 을 가리키는 포인터들은 stack 에 있을 것이다 (왜냐하면 보통 참조는 stack에 있으니까. method 에 대한 frame 이 생기면서.
   사실 따지고 보면 모든 pointer의 근본 pointer 들은 stack 에 있을 수 밖에 없음. stack 에 있는 어떠한 포인터로부터도 추적이 불가능한 heap 에 있는 객체는 소멸대상임. (사용을 안하고 있기 떄문))
3. Set a mark bit on each object reached.
   -> 닿는 객체들을 다 mark 한다
4. Loop through the allocated list, and for each object whose mark bit hasn’t been set:
   -> 다시 할당된 list 를 돌면서, mark bit 가 설정되지 않은 객체에 대해서
	a. Reclaim the memory in the heap and place it back on the free list.	
		메모리를 다시 reclaim 하고 해당 부분을 free list 에 돌려놓는다.
	b. Remove the object from the allocated list.
		allocated list 에서 해당 객체를 제거한다.

이 방식은 단편화 문제를 낳을 수 있다.

여기서 allicated list : 현재 힙에서 할당되어 사용중인 모든 객체들의 목록.

Free list : 빈 메모리 블록 목록
sweep 단계에서 객체의 메모리를 해제하고 이 메모리 블록을 여기에 등록


### Card Table

- 개념: HotSpot은 old 영역에 512바이트 단위 “카드”를 대응시키는 바이트 배열(card table)을 두고, old 객체의 참조 필드가 갱신될 때 write barrier가 해당 카드 바이트를 dirty로 표시한다.​
    
- 목적: young GC 시 전체 old를 스캔하지 않고 “dirty 카드만” 기억 집합으로 스캔해 old→young 참조를 빠르게 찾는다.


이 개념은 Hotspot Heap 에서부터 나온다.
(Optimizing cloud native Java > Understanding Garbage Collection > Production GC techniques in Hotspot > The "Classic HotSpot Heap")


#### The "Classic" HotSpot Heap

클래식한 Hotspot Heap 의 면모를 먼저 살피자면

- 객체마다 얼마나 살아남았는지에 대한 count 를 셈 (generational count)
- 큰 객체들은 제외하고 새로운 객체들은 Eden에 생성
- 충분히 오래 살았고 더 살아남을 것으로 예상되는 객체들을 모아둘 공간을 다른 공간과 분리 (Old, tenured generation)

이때, 외부에서 young generation 에 있는 객체를 참조하는 포인터들을 추적하는 것이 중요한 테크닉 중 하나이다.
이걸 잘해야 어떤 young 객체가 여전히 살아있는지 판단하기 위해 object graph를 traverse 할일이 적어짐.

그래서 이 프로세스를 위해서, card table 이라는 구조를 유지함.
old generation 객체가 young generation 객체를 참조할 수 있는 경우를 기록하는데 도움을 준다 -> 뭔소리야?
일단 JVM 이 관리하는 바이트 배열.

만약 old 객체가 young 객체를 가리키는 참조를 가지게 되면, 해당 512 바이트 구간에 대응하는 카드 테이블의 바이트가 dirty 로 mark 됨.

old 영역에 10,240바이트가 있다면, 카드 테이블은 10,240 / 512 = 20칸짜리 바이트 배열이 됨
old 객체가 young 객체를 참조하게 되면, 해당 객체가 속한 512바이트 구간의 카드가 dirty로 바뀜
 young GC가 돌 때, dirty 카드만 검사해서 old→young 참조를 빠르게 찾음.


-> 이걸 왜 하느냐.
young GC 는 old generation 전체를 scan 하는대신, (너무 효율 떨어짐) card table 을 이용한다.
young GC 를 가리키는 GC root 들로만 객체가 살아있는지 판단하면 실제로
old generation 객체에서 참조하는 객체를 잘못 삭제할 수 있음.
따라서 이를 위해 card table 을 만들어 둔 것.

즉 young GC 는 GC root 참조 + card table 참조 -> mark and sweep


### GC Root

- 정의: GC roots는 힙 외부에서 힙으로 들어오는 모든 앵커 포인터로, 스택 프레임의 지역 변수, JNI 참조, 레지스터, 코드 캐시의 코드 루트, VM 글로벌, 로드된 클래스의 메타데이터 등이 포함된다.​
    
- 직관: 애플리케이션 스레드 스택의 참조(예: 지역 변수)가 null이 아니면 그 객체는 루트로부터 도달 가능하므로 살아있다.

(from Optimizing Cloud Native Java > Understanding Garbage Collection > Introducing the HotSpot Runtime > GC Roots)

GC Roots 란 Known pointer 들의 집합, heap 외부 (outside a memory pool of interest - 우리가 관심을 갖는 메모리 영역) 에 있어서 그 메모리를 참조하는 포인터들을 의미함. extenral pointer 들이며, 내부에서 만들어져 다른 메모리 주소를 참조하는 internal pointer 들과 다름.

예를 들면 Stack frames, JNI, Registers, Code Roots, Globals , class metadata 등이 있음.


### MetaSpace


- **Metaspace**는 JVM이 클래스 메타데이터(klass 구조, 바이트코드, 상수풀, 어노테이션 등)를 저장하는 네이티브 메모리 영역입니다.
    
- Java 8부터 PermGen을 대체하며, OS가 제공하는 네이티브 메모리를 사용해 크기가 제한 없이 커질 수 있습니다.
    
- 클래스 로더가 도달 불가능해지면, 해당 로더가 소유한 모든 클래스의 메타데이터를 한 번에 회수(unload)합니다.
    
- GC는 메타스페이스의 메타데이터를 직접 추적하지 않고, 클래스 로더의 생명주기와 linkset graph(클래스 간 참조 관계 요약 그래프)를 활용해 효율적으로 관리합니다.


-> 클래스 로더 : jVM 이 클래스를 동적으로 로드할때 사용하는 객체.
.class 파일을 읽어 JVm 에 클래스를 등록함.

-> 아직 이해가 부족하지만, 클래스로더는 메모리 cleaning 에 큰 역할을 하므로 이해할 필요가 있다.