
## Annotation - 그제에 이어서


### 질문 

#### 어노테이션이 실제로 **어디에** 사용되는가? (예: 클래스, 메서드, 필드 등)

-> 설정 : @Target

- Package declarations
- Type = class, interface, enum and annotation type declarations
- Method declarations (including elements of annotation)
- Constructor declarations
- Type parameter declarations of generic classes, interfaces, method and constructos
- Field declarations
- Formal and exception parameter declarations
- Local variable declarations

#### Predefined Annotations

##### @Target

##### @Retention

SOURCE -> 바이너리 포함 x
ClASS -> 클래스 파일 포함, (.class), 런타임에 JVM 이 로드 X (기본값)
RUNTIME -> 런타임에 reflection API 로 접근

##### @inherited

메타어노테이션 으로, 어떤 어노테이션에 설정하면 
그 클래스를 상속받은 클래스에서 해당 어노테이션에 접근 가능.


```java
import java.lang.annotation.*;

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnnotation {}

@MyAnnotation
class Parent {}

class Child extends Parent {}

```

그래서 자식 클래스에서 부모 클래스에 설정된 어노테이션의 값도 접근 가능

##### @Override

해당 메소드가 super type 의메서드를 오버라이드 하는지 컴파일 타임에 검증

##### @SuppressWarnings

특정 경고 억제

##### @Deprecated

해당 요소가 더이상 권장되지 않음
(노후화되서 이제 나중 버전에 제외할 예정)

##### @SafeVarags

A variable arity parameter with a non-refiable element type can cause hap Pollution
and give rise to compile time unchecked warnings.

###### arity parameter 
-> 가변 인자 파라미터.
Arity 는 '개수' 라는 뜻.  `...`(varargs) 로 선언된 파라미터를 variable arity parameter 라 명함.

######  Reifiable 
-> 런타임에 타입정보를 완전히 알 수 있는 타입.
non-reifiable -> 런타임에 타입 정보가 사라지는 타입, 즉 generic 을 말함.

###### Type Erasure
Java 의 generic 은 타입 소거 (type erasure) 때문에 런타임에 타입 정보를 알 수 없음.
타입 소거(type erasure)란, 컴파일 시점에 제네릭 타입 정보(예: List\<String>)가 제거되고, 런타임에는 원시 타입(예: List)만 남는 것을 의미.

###### Heap Pollution

arity parameter 가 non-refiable 하면, 내부적으로 Object\[] 로 배열이 만들어지고, 타입정보가 사라짐.
이 배열에 잘못된 타입의 객체가 들어가면, 런타임에 오류가 발생할 수 있음
이를 Heap Pollution 이라 함.

> It is possible that a variable of a parameterized type will refer to an object that is
	not of that parameterized type. This situation is known as heap pollution.

###### unchecked warnings

따라서 non-reifiable arity paramter 를 사용하면 unchecked warning 을 발생시킬 수 있고
이 경고는 타입 안정성이 보장되지 않으니 주의하라는 뜻.
이를 묵음함.


###### 예시

```java
// UNSAFE - 제네릭 파라미터 배열에 대한 참조를 노출함!
static <T> T[] toArray(T... args) {
    return args;  // 위험!
}

// 위험한 예시
static <T> T[] pickTwo(T a, T b, T c) {
    switch(ThreadLocalRandom.current().nextInt(3)) {
        case 0: return toArray(a, b);
        case 1: return toArray(a, c);
        case 2: return toArray(b, c);
    }
    throw new AssertionError();
}

public static void main(String[] args) {
    String[] attributes = pickTwo("Good", "Fast", "Cheap");
    // ClassCastException 발생!
}

// 안전한 예시
@SafeVarargs
static <T> List<T> flatten(List<? extends T>... lists) {
    List<T> result = new ArrayList<>();
    for (List<? extends T> list : lists) {
        result.addAll(list);
    }
    return result;
}
```

###### 안전한 메서드의 조건

1. varargs 파라미터 배열에 아무것도 저장하지 않는다 (파라미터를 덮어쓰지 않음)

2. 배열(또는 복사본)의 참조가 외부로 노출되지 않는다 (신뢰할 수 없는 코드가 접근할 수 없음)

###### 사용 가능한 위치

static 메서드

final 인스턴스 메서드

private 인스턴스 메서드 (Java 9부터)

#####  @Repeatable

메타 어노테이션.
동일한 어노테이션을 한 프로그램의 요소에 여러번 붙일 수 있게 해줌.
컨테이너 어노테이션이 필요함.


```java
import java.lang.annotation.*;

// 컨테이너 어노테이션
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Schedules {
    Schedule[] value();
}

// 반복 가능한 어노테이션
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Repeatable(Schedules.class)  // 컨테이너 지정
public @interface Schedule {
    String dayOfMonth() default "";
    String dayOfWeek() default "";
    int hour() default 0;
}

// 사용 예
@Schedule(dayOfMonth = "last")
@Schedule(dayOfWeek = "Fri", hour = 23)
public class ScheduledClass {
    // ...
}
```

###### 쓰임새

-> 테스트 프레임워크 : 한 테스트가 여러 예외를 기대할때

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(ExceptionTests.class)
public @interface ExceptionTest {
    Class<? extends Exception> value();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTests {
    ExceptionTest[] value();
}

// 사용 예시
@ExceptionTest(IndexOutOfBoundsException.class)
@ExceptionTest(NullPointerException.class)
public void testMethod() {
    List<String> list = new ArrayList<>();
    list.get ( 1 ); // IndexOutOfBoundsException
    String s = null;
    s.length(); // NullPointerException
}
```

어떤 테스트 메서드가 여러 종류의 예외를 던질 수 있고, 이 예외들이 모두 "정상 동작"임을 검증하고 싶을 때
예를 들어, testMethod()가 IndexOutOfBoundsException 또는 NullPointerException을 던지면 테스트가 통과해야 한다고 가정.


-> 스케줄링 : 하나의 작업에 여러 스케줄을 지정할때

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Repeatable(Schedules.class)
public @interface Schedule {
    String cron();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Schedules {
    Schedule[] value();
}

// 사용 예시
@Schedule(cron = "0 0 * * *") // 매시간
@Schedule(cron = "0 0 1 * *") // 매일 1시
public class ScheduledJob {
    // ...
}
```

어떤 작업(Job)이 여러 시간대에 실행되어야 할 때가 있다. 
예를 들어, 매시간 한 번, 그리고 매일 새벽 1시에 한 번 실행해야 한다면?


-> 권한 부여 : 하나의 엔드포인트에 여러 권한을 부여할때

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Permissions.class)
public @interface Permission {
    String role();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Permissions {
    Permission[] value();
}

// 사용 예시
@Permission(role = "ADMIN")
@Permission(role = "USER")
public void securedEndpoint() {
    // ...
}

```

어떤 API 엔드포인트가 여러 역할(ADMIN, USER 등)에게 모두 허용되어야 할 때.



##### @FunctionalInterface

메타 어노테이션.
-> '함수형 인터페이스' 임을 명시적으로 선언.

###### 함수형 인터페이스 ?

추상 메서드(abstract method) 가 오직 하나만 존재하는 인터페이스.  ([[250927#^733ead]] 참조 )
람다식이나 메서드 참조의 대상이 될 수 있음.

추상 메서드가 2개 이상이면 컴파일 에러 발생.

###### 쓰임새

람다식과 메서드 참조의 대상이 되는 타입을 명확히 하기 위해서.
대표적으로 Runnable, Callable, Comparator\<T>, PredicateT> 등이 함수형 인터페이스.

```java
@FunctionalInterface
interface MyCalculator {
    int calculate(int a, int b);
}

public class Example {
    public static void main(String[] args) {
        // 람다식으로 함수형 인터페이스 구현
        MyCalculator adder = (x, y) -> x + y;
        int result = adder.calculate(3, 5);
        System.out.println(result); // 8
    }
}
```

-> main 메서드에서 람다식 (x, y) -> x + y로 인터페이스를 구현 가능.

###### 예시 : 왜이리 쓰는가?

그냥 method 하나 선언해서 return x + y 하면 되지 않는가 ?


-> 코드 간결성과 유연성

-> API 와 프레임워크의 안정성

-> 동작을 값처럼 전달

-> 자바의 타입 시스템과 안정성


## Serializable



## Network






## Generic

[[250913#^45e137]]

