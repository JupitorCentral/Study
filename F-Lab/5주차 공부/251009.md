## Generic - Type Parameter vs WildCard, PECS, @SafeVarargs


### Type Parameter vs WildCard

#### **와일드카드 제약:**

- **인스턴스 생성 불가**: `new ArrayList<?>()` ❌
    
- **제너릭 메서드 호출 시 명시 불가**: `List<?> list = Lists.<?>factory()` ❌
    
- **슈퍼타입에 사용 불가**: `class AnyList extends ArrayList<?> {}` ❌

>In a class instance creation expression, if the type is a parameterized type, then none of the type parameters may be wildcards.

-> Parameterized type : 제너릭타입에 구체적인 타입인자(type argument) 를 제공한 타입.
-> List\<T>  -> Generic Type
-> List\<String> -> String 이란 Type argument 를 준 Parameterized Type.



```java
// 잘못된 코드 - 컴파일 에러
List<?> list = new ArrayList<?>();  // ❌ 불가능 -> 인스턴스 생성 불가
Map<String, ? extends Number> map = new HashMap<String, ? extends Number>();  // ❌ 불가능 -> 인스턴스 생성 불가

// 올바른 코드
List<?> list = new ArrayList<String>();  // ✅ 가능 (구체적 타입으로 생성)
List<?> list = new ArrayList<>();  // ✅ 가능 (타입 추론)
Map<String, ? extends Number> map = new HashMap<String, Integer>();  // ✅ 가능
```

```java
class Lists {  
    public static <T> List<T> factory() {  
        return new ArrayList<T>();  
    }  
}

List<?> list = Lists.<?>factory(); // ❌ 컴파일 에러

List<?> list = Lists.<Integer>factory(); // ✅ 가능


class AnyList extends ArrayList<?> { // ❌ 컴파일 에러
}

class AnotherList implements List<?> { // ❌ 컴파일 에러
}
```

#### 읽기/쓰기



```java
// 와일드카드 사용 예시
void processNumbers(List<? extends Number> numbers) {
    for (Number n : numbers) {
        System.out.println(n.doubleValue());
    }
    // numbers.add(1); // 컴파일 에러: 값을 넣을 수 없음
}


// 타입 파라미터 사용 예시
<T extends Number> void processNumbers2(List<T> numbers) {
    for (T n : numbers) {
        System.out.println(n.doubleValue());
        // T 타입의 메서드, 필드 사용 가능
    }
    numbers.add(numbers.get(0)); // T 타입이 명확하므로 값 추가 가능
}

```


- `? extends T`는 "T 또는 그 하위 타입"을 받아서 **읽기만** 할 때 사용.


- `E extends T`는 "T의 하위 타입 E"를 명확히 지정해서 **읽기/쓰기 모두** 할 때 사용.



#### SubTyping

타입 파라미터는 타입을 선언하고 여러 곳에서 재 사용할떄,
API 의 유연성을 높이고 서브타이핑을 허용할때 와일드 카드를 쓰는게 좋다고 한다.

서브타이핑이란 ?

>"Subtyping is a key feature of object-oriented languages such as Java. In Java, 
>one type is a subtype of another if they are related by an extends or implements clause."

```java
Integer is a subtype of Number
Double is a subtype of Number
ArrayList<E> is a subtype of List<E>
List<E> is a subtype of Collection<E>
```
즉 subtype 은 transitive 하다.


> "Sometimes we would like lists to behave more like arrays, in that we want to accept not only a list with elements of a given type, but also a list with elements of any subtype of a given type. For this purpose, we use wildcards."

어떤 리스트에 대해서 그 리스트에 정의된 타입 뿐만 아니라,  그 타입의 subtype 까지 해당 리스트에 포함시키고 싶을떄, 와일드 카드를 쓸 수 있음.

##### Covariant ?

> "In Java, array subtyping is covariant, meaning that type `S[]` is considered to be a subtype of `T[]` whenever `S` is a subtype of `T`."

타입 관계가 같은 방향으로 변한다. (공변성)
위 예시에서, S 가 T 의 서브 타입일 경우, S 의 배열은 T 의 배열의 서브타입이라고 간주함.


```java
Integer[] ints = new Integer[]{1, 2, 3};
Number[] nums = ints;  // OK! Integer[]는 Number[]의 서브타입
```

##### Invariant vs Covariant

> "In contrast, the subtyping relation for generics is invariant, meaning that type `List<S>` is not considered to be a subtype of `List<T>`, except in the trivial case where `S` and `T` are identical."

Invariant (불변성) 은 타입 관계가 유지되지 않음을 의미.

```java
List<Integer> ints = Arrays.asList(1, 2, 3);
List<Number> nums = ints;  // compile-time error
```

이때, 와일드 카드가 Covariant 를 재적용할 수 있다.

```java
List<Integer> ints = Arrays.asList(1, 2);
List<? extends Number> nums = ints;  // OK!
```

##### 보통 제너릭은 Invariant 하다. (Type parameter)

왜 그렇냐면, 당연히 안정성 떄문이다.

```java
List<Integer> ints = new ArrayList<Integer>();
ints.add( 1 );
ints.add( 2 );
List<Number> nums = ints;  // compile-time error
nums.add(3.14);
assert ints.toString().equals("[1, 2, 3.14]"); // uh oh!
```

만약 위 상황에서 Generic 이 covariant 하다면,
List\<Integer> 가 List\<Number> 로 취급될 수 있게 되고,
그러면 nums 에 3.14 즉 다른 타입이 추가될 수 있음 (Number 를 상속받는).

하지만 실제로 nums 는 List\>Integer> 이므로 타입 안전성이 깨져버린다.


##### Contravariance (반공변)

> "Wildcards also introduce contravariant subtyping for generics, in that type `List<S>` is considered to be a subtype of `List<? super T>` when `S` is a supertype of `T` (as opposed to a subtype)."

와일드 카드는 또는 Contravariance 라는 속성을 제너릭에 부여할 수 잇는데,
S 가 T 의 super class 일 경우, List\<S> 는 List\<? super T> 의 subtype 이 된다. (놀랍군!)

```java
List<Number> nums = new ArrayList<Number>();
List<? super Integer> sink = nums;  // OK!
sink.add(42);  // Integer를 쓸 수 있음
```


##### 배열 vs 제너릭

> Wildcards also introduce contravariant subtyping for generics, in that type List\<S> is considered to be a subtype 
> of List\<? super T> when S is a supertype of T (as opposed to a subtype). 
> 
> Arrays do not support contravariant subtyping. For instance, recall that the method count accepted a 
> parameter of type Collection\<? super Integer> and filled it with integers. 
> There is no equivalent way to do this with an array, 
> since Java does not permit you to write (? super Integer)\[].


-> 잘 이해가 안간다.

### PECS


-> WildCard 를 사용 할 떄 중요한 가이드라인.
-> Producer - Extends, Consumer - Super. 

와일드 카드에 언제 extends 를, 언제 super 를 써야 될지를 제시한다.


먼저 다시 WildCard 의 형태를 보자.

##### wildcard 의 형태

###### Unbounded 

모든 타입 허용. 즉 타입에 대한 구체적인 정보가 필요 없을때.


```java
List<?> list = new ArrayList<String>();
```

- 사용 의도

-> 메서드의 변수가 타입에 의존하지 않고 Object 로 써만 사용될때.


###### Upper Bounded

```java
public void pushAll(Iterable<? extends E> src) {
    for (E e : src)
        push(e);
}
```

E 나 그 하위 타입 허용

###### Lower Bounded

```java
public void popAll(Collection<? super E> dst) {
    while (!isEmpty())
        dst.add(pop());
}
```

E 나 그 상위 타입 허용 (super class)

```java
List<? super Integer> list;
list = new ArrayList<Integer>(); // OK
list = new ArrayList<Number>();  // OK
list = new ArrayList<Object>();  // OK
```


#### 왜 \<? extends E> 타입에는 Put 할 수 없는가 ?

\<? extends E> -> E 의 서브클래스이긴 한데, 어떤 서브클래스인지 모름.

예를 들어 E 가 Number 면, 그 서브클래스들은 Integer, Double 등이 있을 것.
List\<? extends E> 타입인 변수 x 에 대해, 실제로는 Integer 타입으로 저장되어있는데 
Double을 넣어버리면 타입 integrity 가 깨져버림.

```java
List<? extends Number> numbers = new ArrayList<Integer>();
numbers.add(3.14); // 컴파일 에러! (Double을 넣을 수 없음)
```

즉 넣고자 하는 대상이 실제로 어떤 타입인지 알 수 없기때문에 값을 안전하게 넣을 수가 없음.

**단, null은 모든 참조 타입에 넣을 수 있으므로 예외적으로 허용됨**


그래서, numbers 라는 변수는 값을 주기만 하는 'Producer' 가 되는 것이다 (Producer - extends)



#### 왜 \<? super E> 타입로부터 get 할 수 없는가 ?

\<? super E> 라는 의미는, 어떤 타입이 그 자체거나 E 의 super 클래스 라는 의미.

즉, E 가 Integer 일 경우
List\<Integer>, List\<Numbers>, List\<Object> 모두 가능함.



그렇다면 List\<? super Integer> myList 에

값을 넣을 경우, \<? super Integer> 에 해당하는 타입들 즉
Integer, Number, Object 만 허용 하기 때문에
그 값들을 넣는 것은 상관이 없다.

```java
List<? super Integer> list = new ArrayList<Object>();
list.add(42);        // OK, Integer는 Integer의 하위 타입
list.add(new Integer(7)); // OK
list.add("hello");  // 컴파일 에러! String은 Integer의 하위 타입이 아님
list.add(3.14);      // 컴파일 에러! Double은 Integer의 하위 타입이 아님
```


myList 에 대해서 변수를 끄집어 올때,
이 변수가 실제로 Object 인지, Number인지, Integer 인지 알 수가 없음.

```java
List<? super Integer> list = new ArrayList<Number>();
list.add(42); // OK, Integer는 Number의 하위 타입
Object obj = list.get(0); // OK, Object로 받는 것은 안전
Integer i = list.get(0); // 컴파일 에러! 실제 타입이 Integer인지 확신할 수 없음
```

그래서 myList 는 항상 값을 얻기만 하므로 (Consume), 이 변수는 Consumer 가 됨 (Consumer - super)


**단, null은 모든 참조 타입에 넣을 수 있으므로 예외적으로 허용됨**


### @SafeVarargs Questions

[[251006#^211585]]

1. **경고의 본질**: `unchecked warning`이 발생하는 근본적인 이유는 무엇인가요? 왜 컴파일러는 varargs parameter array가 non-reifiable type일 때 경고를 내나요?
    
2. **타입 안전성의 조건**: 어떤 경우에 varargs 메서드가 실제로 타입 안전(type-safe)하다고 판단할 수 있을까요? Effective Java에서 제시하는 두 가지 조건은 무엇인가요?
    
3. **Heap Pollution**: "heap pollution"이란 정확히 무엇을 의미하나요? 어떤 상황에서 발생하며, 왜 위험한가요?
    
4. **책임의 전가**: `@SafeVarargs`를 붙인다는 것은 누가 누구에게 무엇을 약속(promise)하는 건가요? 그리고 그 약속이 지켜지지 않으면 어떤 일이 발생하나요?
    
5. **대안**: `@SafeVarargs` 대신 사용할 수 있는 더 안전한 방법은 없을까요? (힌트: Item 28의 조언)

6. **Type Erasure의 정의**: Java의 제네릭은 컴파일 타임에만 존재하고, 런타임에는 "소거(erasure)"됩니다. 이게 정확히 무슨 의미인가요?
    
7. **Reifiable vs Non-reifiable**:
    
    - Reifiable type과 Non-reifiable type의 차이는 무엇인가요?
        
    - 왜 배열은 reifiable하고, 제네릭 타입은 non-reifiable한가요?
        
8. **Varargs의 내부 구현**: `varargs` 파라미터는 내부적으로 어떻게 처리되나요? 
    
9. **런타임 타입 정보**: `List<String>`이 컴파일되면 런타임에는 어떤 타입 정보를 가지고 있나요? `List<Integer>`와 구분이 가능한가요?
    

**이제 @SafeVarargs로 연결:**

5. **경고가 발생하는 이유**: Type erasure 때문에 varargs와 제네릭을 함께 사용하면 왜 `unchecked warning`이 발생하나요?
    
6. **@SafeVarargs의 실제 역할**: 이 어노테이션은 컴파일러에게 무엇을 "약속"하는 건가요? 실제로 타입 안전성을 **보장**하나요, 아니면 단순히 경고를 **억제**하나요?




## I/O




## NIO




## 자바 8에서 추가된 것


