## Generic - Type Parameter vs WildCard, PECS, @SafeVarargs


### Type Parameter vs WildCard

#### **와일드카드 제약:**

- **인스턴스 생성 불가**: `new ArrayList<?>()` ❌
    
- **제너릭 메서드 호출 시 명시 불가**: `List<?> list = Lists.<?>factory()` ❌
    
- **슈퍼타입에 사용 불가**: `class AnyList extends ArrayList<?> {}` ❌

>In a class instance creation expression, if the type is a parameterized type, then none of the type parameters may be wildcards.

-> Parameterized type : 제너릭타입에 구체적인 타입인자(type argument) 를 제공한 타입.
-> List\<T>  -> Generic Type
-> List\<String> -> String 이란 Type argument 를 준 Parameterized Type.



```java
// 잘못된 코드 - 컴파일 에러
List<?> list = new ArrayList<?>();  // ❌ 불가능 -> 인스턴스 생성 불가
Map<String, ? extends Number> map = new HashMap<String, ? extends Number>();  // ❌ 불가능 -> 인스턴스 생성 불가

// 올바른 코드
List<?> list = new ArrayList<String>();  // ✅ 가능 (구체적 타입으로 생성)
List<?> list = new ArrayList<>();  // ✅ 가능 (타입 추론)
Map<String, ? extends Number> map = new HashMap<String, Integer>();  // ✅ 가능
```

```java
class Lists {  
    public static <T> List<T> factory() {  
        return new ArrayList<T>();  
    }  
}

List<?> list = Lists.<?>factory(); // ❌ 컴파일 에러

List<?> list = Lists.<Integer>factory(); // ✅ 가능


class AnyList extends ArrayList<?> { // ❌ 컴파일 에러
}

class AnotherList implements List<?> { // ❌ 컴파일 에러
}
```

#### 읽기/쓰기



```java
// 와일드카드 사용 예시
void processNumbers(List<? extends Number> numbers) {
    for (Number n : numbers) {
        System.out.println(n.doubleValue());
    }
    // numbers.add(1); // 컴파일 에러: 값을 넣을 수 없음
}


// 타입 파라미터 사용 예시
<T extends Number> void processNumbers2(List<T> numbers) {
    for (T n : numbers) {
        System.out.println(n.doubleValue());
        // T 타입의 메서드, 필드 사용 가능
    }
    numbers.add(numbers.get(0)); // T 타입이 명확하므로 값 추가 가능
}

```


- `? extends T`는 "T 또는 그 하위 타입"을 받아서 **읽기만** 할 때 사용.


- `E extends T`는 "T의 하위 타입 E"를 명확히 지정해서 **읽기/쓰기 모두** 할 때 사용.



#### SubTyping

타입 파라미터는 타입을 선언하고 여러 곳에서 재 사용할떄,
API 의 유연성을 높이고 서브타이핑을 허용할때 와일드 카드를 쓰는게 좋다고 한다.

서브타이핑이란 ?

>"Subtyping is a key feature of object-oriented languages such as Java. In Java, 
>one type is a subtype of another if they are related by an extends or implements clause."

```java
Integer is a subtype of Number
Double is a subtype of Number
ArrayList<E> is a subtype of List<E>
List<E> is a subtype of Collection<E>
```
즉 subtype 은 transitive 하다.


> "Sometimes we would like lists to behave more like arrays, in that we want to accept not only a list with elements of a given type, but also a list with elements of any subtype of a given type. For this purpose, we use wildcards."

어떤 리스트에 대해서 그 리스트에 정의된 타입 뿐만 아니라,  그 타입의 subtype 까지 해당 리스트에 포함시키고 싶을떄, 와일드 카드를 쓸 수 있음.

##### Covariant ?

> "In Java, array subtyping is covariant, meaning that type `S[]` is considered to be a subtype of `T[]` whenever `S` is a subtype of `T`."

타입 관계가 같은 방향으로 변한다. (공변성)
위 예시에서, S 가 T 의 서브 타입일 경우, S 의 배열은 T 의 배열의 서브타입이라고 간주함.


```java
Integer[] ints = new Integer[]{1, 2, 3};
Number[] nums = ints;  // OK! Integer[]는 Number[]의 서브타입
```

##### Invariant vs Covariant

> "In contrast, the subtyping relation for generics is invariant, meaning that type `List<S>` is not considered to be a subtype of `List<T>`, except in the trivial case where `S` and `T` are identical."

Invariant (불변성) 은 타입 관계가 유지되지 않음을 의미.

```java
List<Integer> ints = Arrays.asList(1, 2, 3);
List<Number> nums = ints;  // compile-time error
```

이때, 와일드 카드가 Covariant 를 재적용할 수 있다.

```java
List<Integer> ints = Arrays.asList(1, 2);
List<? extends Number> nums = ints;  // OK!
```

##### 보통 제너릭은 Invariant 하다. (Type parameter)

왜 그렇냐면, 당연히 안정성 떄문이다.

```java
List<Integer> ints = new ArrayList<Integer>();
ints.add( 1 );
ints.add( 2 );
List<Number> nums = ints;  // compile-time error
nums.add(3.14);
assert ints.toString().equals("[1, 2, 3.14]"); // uh oh!
```

만약 위 상황에서 Generic 이 covariant 하다면,
List\<Integer> 가 List\<Number> 로 취급될 수 있게 되고,
그러면 nums 에 3.14 즉 다른 타입이 추가될 수 있음 (Number 를 상속받는).

하지만 실제로 nums 는 List\>Integer> 이므로 타입 안전성이 깨져버린다.


##### Contravariance (반공변)

> "Wildcards also introduce contravariant subtyping for generics, in that type `List<S>` is considered to be a subtype of `List<? super T>` when `S` is a supertype of `T` (as opposed to a subtype)."

와일드 카드는 또는 Contravariance 라는 속성을 제너릭에 부여할 수 잇는데,
S 가 T 의 super class 일 경우, List\<S> 는 List\<? super T> 의 subtype 이 된다. (놀랍군!)

```java
List<Number> nums = new ArrayList<Number>();
List<? super Integer> sink = nums;  // OK!
sink.add(42);  // Integer를 쓸 수 있음
```


##### 배열 vs 제너릭

> Wildcards also introduce contravariant subtyping for generics, in that type List\<S> is considered to be a subtype 
> of List\<? super T> when S is a supertype of T (as opposed to a subtype). 
> 
> Arrays do not support contravariant subtyping. For instance, recall that the method count accepted a 
> parameter of type Collection\<? super Integer> and filled it with integers. 
> There is no equivalent way to do this with an array, 
> since Java does not permit you to write (? super Integer)\[].


-> 잘 이해가 안간다.

### PECS


-> WildCard 를 사용 할 떄 중요한 가이드라인.
-> Producer - Extends, Consumer - Super. 

와일드 카드에 언제 extends 를, 언제 super 를 써야 될지를 제시한다.


먼저 다시 WildCard 의 형태를 보자.

##### wildcard 의 형태

###### Unbounded 

모든 타입 허용. 즉 타입에 대한 구체적인 정보가 필요 없을때.


```java
List<?> list = new ArrayList<String>();
```

- 사용 의도

-> 메서드의 변수가 타입에 의존하지 않고 Object 로 써만 사용될때.


###### Upper Bounded

```java
public void pushAll(Iterable<? extends E> src) {
    for (E e : src)
        push(e);
}
```

E 나 그 하위 타입 허용

###### Lower Bounded

```java
public void popAll(Collection<? super E> dst) {
    while (!isEmpty())
        dst.add(pop());
}
```

E 나 그 상위 타입 허용 (super class)

```java
List<? super Integer> list;
list = new ArrayList<Integer>(); // OK
list = new ArrayList<Number>();  // OK
list = new ArrayList<Object>();  // OK
```


#### 왜 \<? extends E> 타입에는 Put 할 수 없는가 ?

\<? extends E> -> E 의 서브클래스이긴 한데, 어떤 서브클래스인지 모름.

예를 들어 E 가 Number 면, 그 서브클래스들은 Integer, Double 등이 있을 것.
List\<? extends E> 타입인 변수 x 에 대해, 실제로는 Integer 타입으로 저장되어있는데 
Double을 넣어버리면 타입 integrity 가 깨져버림.

```java
List<? extends Number> numbers = new ArrayList<Integer>();
numbers.add(3.14); // 컴파일 에러! (Double을 넣을 수 없음)
```

즉 넣고자 하는 대상이 실제로 어떤 타입인지 알 수 없기때문에 값을 안전하게 넣을 수가 없음.

**단, null은 모든 참조 타입에 넣을 수 있으므로 예외적으로 허용됨**


그래서, numbers 라는 변수는 값을 주기만 하는 'Producer' 가 되는 것이다 (Producer - extends)



#### 왜 \<? super E> 타입로부터 get 할 수 없는가 ?

\<? super E> 라는 의미는, 어떤 타입이 그 자체거나 E 의 super 클래스 라는 의미.

즉, E 가 Integer 일 경우
List\<Integer>, List\<Numbers>, List\<Object> 모두 가능함.



그렇다면 List\<? super Integer> myList 에

값을 넣을 경우, \<? super Integer> 에 해당하는 타입들 즉
Integer, Number, Object 만 허용 하기 때문에
그 값들을 넣는 것은 상관이 없다.

```java
List<? super Integer> list = new ArrayList<Object>();
list.add(42);        // OK, Integer는 Integer의 하위 타입
list.add(new Integer(7)); // OK
list.add("hello");  // 컴파일 에러! String은 Integer의 하위 타입이 아님
list.add(3.14);      // 컴파일 에러! Double은 Integer의 하위 타입이 아님
```


myList 에 대해서 변수를 끄집어 올때,
이 변수가 실제로 Object 인지, Number인지, Integer 인지 알 수가 없음.

```java
List<? super Integer> list = new ArrayList<Number>();
list.add(42); // OK, Integer는 Number의 하위 타입
Object obj = list.get(0); // OK, Object로 받는 것은 안전
Integer i = list.get(0); // 컴파일 에러! 실제 타입이 Integer인지 확신할 수 없음
```

그래서 myList 는 항상 값을 얻기만 하므로 (Consume), 이 변수는 Consumer 가 됨 (Consumer - super)


**단, null은 모든 참조 타입에 넣을 수 있으므로 예외적으로 허용됨**


### @SafeVarargs Questions

[[251006#^211585]]

1. **경고의 본질**: `unchecked warning`이 발생하는 근본적인 이유는 무엇인가요? 왜 컴파일러는 varargs parameter array가 non-reifiable type일 때 경고를 내나요?
    
2. **타입 안전성의 조건**: 어떤 경우에 varargs 메서드가 실제로 타입 안전(type-safe)하다고 판단할 수 있을까요? Effective Java에서 제시하는 두 가지 조건은 무엇인가요?
    
3. **Heap Pollution**: "heap pollution"이란 정확히 무엇을 의미하나요? 어떤 상황에서 발생하며, 왜 위험한가요?
    
4. **책임의 전가**: `@SafeVarargs`를 붙인다는 것은 누가 누구에게 무엇을 약속(promise)하는 건가요? 그리고 그 약속이 지켜지지 않으면 어떤 일이 발생하나요?
    
5. **대안**: `@SafeVarargs` 대신 사용할 수 있는 더 안전한 방법은 없을까요? (힌트: Item 28의 조언)

6. **Type Erasure의 정의**: Java의 제네릭은 컴파일 타임에만 존재하고, 런타임에는 "소거(erasure)"됩니다. 이게 정확히 무슨 의미인가요?
    
7. **Reifiable vs Non-reifiable**:
    
    - Reifiable type과 Non-reifiable type의 차이는 무엇인가요?
        
    - 왜 배열은 reifiable하고, 제네릭 타입은 non-reifiable한가요?
        
8. **Varargs의 내부 구현**: `varargs` 파라미터는 내부적으로 어떻게 처리되나요? 
    
9. **런타임 타입 정보**: `List<String>`이 컴파일되면 런타임에는 어떤 타입 정보를 가지고 있나요? `List<Integer>`와 구분이 가능한가요?
    

**이제 @SafeVarargs로 연결:**

10. **경고가 발생하는 이유**: Type erasure 때문에 varargs와 제네릭을 함께 사용하면 왜 `unchecked warning`이 발생하나요?
    
11. **@SafeVarargs의 실제 역할**: 이 어노테이션은 컴파일러에게 무엇을 "약속"하는 건가요? 실제로 타입 안전성을 **보장**하나요, 아니면 단순히 경고를 **억제**하나요?


#### Parameterized Type

(From JLS8)

> A parameterized type is a class or interface type of the form C<T1,...,Tn>, where C 
> is the name of a generic type and <T1,...,Tn> is a list of type arguments that denote 
> a particular parameterization of the generic type.

위 문장에서 C 는 Type Parameter 를 사용해서 정의한 클래스로 Generic Class 라 부른다.

Generic Type 은 Generic Class 를 이용해 Type parameter 또는 WildCard 를 이용해 선언한 타입이다.
Paramterized Type 은 Generic Type 에서 특정 클래스를 이용해 명시한 타입이다.

```java
// 예시 1: 타입 파라미터 T를 사용하는 제네릭 클래스
public class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}

// 예시 2: 두 개의 타입 파라미터를 사용하는 제네릭 클래스
public class Pair<T, U> {
    private final T first;
    private final U second;
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
    public T getFirst() { return first; }
    public U getSecond() { return second; }
}

// 예시 3: 타입 파라미터 E를 사용하는 제네릭 인터페이스
public interface Stack<E> {
    boolean empty();
    void push(E elt);
    E pop();
}
```

```java
// 예시 1: List<E> 타입 선언. List<E> 가 'Generic Type' 이다.
List<E> list;

// 예시 2: Map<K, V> 타입 선언
Map<K, V> map;

// 예시 3: Box<T> 타입 선언
Box<T> box;
```

```java
// 예시 1: List<String> 타입 변수 선언. List<String> 은 'Parameterized Type' 이다.
List<String> names = new ArrayList<String>();

// 예시 2: Map<Integer, String> 타입 변수 선언
Map<Integer, String> idToName = new HashMap<Integer, String>();

// 예시 3: Box<Double> 타입 변수 선언
Box<Double> doubleBox = new Box<Double>();
```

Type Parameter 는 Generic method, class, variable 을 선언할때 쓰이는 문자이고, (e.g T, E, J, V)
Type Argument 는 Generic Type Variable 이 인스턴스화 될때 쓰이는, 실제로 존재하는 타입을 말한다.

```java
// 제네릭 클래스 정의 (type parameter 사용)
class Box<T> { ... }

// 제네릭 타입 사용 (type argument 명시)
Box<String> stringBox = new Box<String>(); // 여기서 String이 type argument
Box<Integer> intBox = new Box<Integer>();  // 여기서 Integer가 type argument
```


> In the Java programming language, every variable and every expression has a type that can be determined at compile time. 
> The type may be a primitive type or a reference type. Reference types include class types and interface types. Reference 
> types are introduced by type declarations, which include class declarations (§8.1) 
> and interface declarations (§9.1). We often use the term type to refer to either a class or an interface.


여기서 마지막 출에 '우리는 종종 타입 이라는 용어를 클래스나 인터페이스를 가리키는데 사용한다' 라고 하는데,
이는 곧 타입 != 클래스를 의미한다. 
바로 위에도 보면 Generic Type 과 Generic Class 가 다르다.

Parameterized Type 과 Generic Type 이 헷갈릴 수 있는데,
Generic Type 은 선언부에서만 쓰인다.

Parameterized Type 은 Generic Type 에 wildcard, 또는 class name (type argument) 이 쓰인 것을 말한다.
```java
List<String> list1;              // parameterized type (type argument: String)
List<? extends Number> list2;    // parameterized type (type argument: ? extends Number)
List<?> list3;                   // parameterized type (type argument: ?)
```

Generic Type 은 wildcard 나 specific type 이 사용되지 않는다. 오직 Type parameter 만 쓰인다.

```java
// 1. 타입 파라미터 E를 사용하는 List 인터페이스
public interface List<E> {
    void add(E element);
    E get(int index);
}

// 2. 타입 파라미터 T를 사용하는 Box 클래스
public class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}

// 3. 두 개의 타입 파라미터를 사용하는 Pair 클래스
public class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    public K getKey() { return key; }
    public V getValue() { return value; }
}
```


Type Variable 은 또 Type parameter 와 다르다.

Type parameter는 선언이고, Type variable은 그 선언에 의해 생성된 변수.

- **Type parameter**: `<T>`에서 T를 **선언하는 행위** 자체
    
- **Type variable**: 선언된 후 body에서 **실제로 사용되는 T**


```java
class Box<T> {           // ← 여기서 T가 type parameter
    private T value;     // ← 여기서 T가 type variable
    
    public Box(T value) {     // ← 여기서 T가 type variable
        this.value = value;
    }
    
    public T getValue() {     // ← 여기서 T가 type variable
        return value;
    }
    
    public void setValue(T value) {  // ← 여기서 T가 type variable
        this.value = value;
    }
}
```

```java
public static <T> List<T> toList(T... arr) {  // T가 type parameter
    List<T> list = new ArrayList<T>();      // T는 type variable
    for (T elt : arr) {                      // T는 type variable
        list.add(elt);
    }
    return list;                              // List<T>에서 T는 type variable (Type Parameter T 의 사용이므로)
}
```

왜 그럼 Type variable 에 대한 설명을 하냐면...

#### Type Erasure 

(from JLS8)
> Type erasure is a mapping from types (possibly including parameterized types and type variables) 
> to types (that are never parameterized types or type variables). We write |T| for the erasure of type T. 
> The erasure mapping is defined as follows:
> 
> • The erasure of a parameterized type (§4.5) G<T1,...,Tn> is |G|.
> • The erasure of a nested type T.C is |T|.C.
> • The erasure of an array type T\[] is |T|\[].
> • The erasure of a type variable (§4.4) is the erasure of its leftmost bound.
> • The erasure of every other type is the type itself.


아래는 어떠한 대상이 Type Erasured 된 것을 표기하는 방법.

Type Erasure 는 parameterized 된 type 이나 type variable 등의 type 으로부터, 
parameterized type 이거나 type variable 가 아닌 type 으로의 mapping 이다 (ㅋㅋ).
(즉 Type Erasure 의 결과물은 parameterized type 이나 type variable 이 절대 아님.)

내가 해석해놓고도 어이가 없네.


> (that are never parameterized types or type variables).
> -> 여기서 nor 랑 상관없나보다. parameterized types 또는 type variables 가 절대 아닌. 이 된다.


```java
// 입력 → 출력 (erasure 결과)
List<String> → List              // raw type (O)
T extends Number → Number         // concrete class (O)
Map<K,V> → Map                   // raw type (O)

// 절대 나올 수 없는 출력
→ List<Integer>                  // parameterized type (X)
→ T                              // type variable (X)
```

그럼 Type Erasure 되면 어떤 결과물이 남는가?
그럴려면 Java 의 Type 이 뭐가 있는지를 알아야 한다.
[[251009#^1810fd]]




일단 쉽게 표현하자면

Type Erasure는 제네릭 타입의 타입 파라미터 정보를 컴파일 시점에 제거하여, 
런타임에는 원시 타입(raw type)만 남도록 하는 Java의 제네릭 구현 방식.

#### Reifiable Types

런타임에 그 타입을 알 수 있는 타입.



## BNF - Backus-Naur Form

참고로, JLS8 에서 자꾸

```java
PrimitiveType:
{Annotation} NumericType
{Annotation} boolean
```
이렇게 나오는건
BNF - Backus-Naur Form, 즉 문법 표기법이다. (배커스 나우르)
위 문법은 이런 의미다.

**`{Annotation}`**: **0개 이상의 Annotation**이 올 수 있다는 뜻.

```java
// 0개의 Annotation
int x;

// 1개의 Annotation
@NonNull int x;

// 2개의 Annotation
@NonNull @NotEmpty int x;

// 3개 이상도 가능
@A @B @C int x;
```

ㅋㅋ.

`[x]` (대괄호): 0개 또는 1개


`(one of)`: 다음 중 하나


Reference Type 의 문법 정의를 또 보면

```java
ReferenceType:
    ClassOrInterfaceType
    TypeVariable
    ArrayType

ClassOrInterfaceType:
    ClassType
    InterfaceType

ClassType:
    {Annotation} Identifier [TypeArguments]
    ClassOrInterfaceType . {Annotation} Identifier [TypeArguments]

InterfaceType:
    ClassType

TypeVariable:
    {Annotation} Identifier

ArrayType:
    PrimitiveType Dims
    ClassOrInterfaceType Dims
    TypeVariable Dims

Dims:
    {Annotation} [ ] {{Annotation} [ ]}

```

이렇게 되어 있는데, 이를 하나하나 보면

```java
ReferenceType:
    ClassOrInterfaceType
    TypeVariable
    ArrayType
```

Reference Type는 3가지 중 하나:

- ClassOrInterfaceType (클래스나 인터페이스 타입)
- TypeVariable (타입 변수, 예: T, E)
- ArrayType (배열 타입)


```java
ClassOrInterfaceType:
    ClassType
    InterfaceType
```

ClassOrInterfaceType는 2가지 중 하나:

- ClassType
- InterfaceType

```java
ClassType:
    {Annotation} Identifier [TypeArguments]
    ClassOrInterfaceType . {Annotation} Identifier [TypeArguments]
```

ClassType는 2가지 형태:

- 0개 이상의 Annotation + Identifier + 0개 또는 1개의 TypeArguments
- ClassOrInterfaceType + . + 0개 이상의 Annotation + Identifier + 0개 또는 1개의 TypeArguments
( . 이 그냥 글자다.)

예시) 
```java
String                          // {Annotation} Identifier
List<String>                    // {Annotation} Identifier [TypeArguments]
@NonNull String                 // {Annotation} Identifier
Outer.Inner                     // ClassOrInterfaceType . Identifier
Outer.@NonNull Inner<T>         // ClassOrInterfaceType . {Annotation} Identifier [TypeArguments]
```



```java
InterfaceType:
    ClassType
```

InterfaceType는 ClassType과 동일한 문법을 따른다. (문법상 구분은 없고, 의미상으로만 interface)

```java
TypeVariable:
    {Annotation} Identifier
```

TypeVariable는:
 - 0개 이상의 Annotation + Identifier

예시)
```java
T                               // Identifier
@NonNull T                      // {Annotation} Identifier
```

```java
ArrayType:
    PrimitiveType Dims
    ClassOrInterfaceType Dims
    TypeVariable Dims
```

ArrayType는 3가지 형태:

- PrimitiveType + Dims (예: int\[])
- ClassOrInterfaceType + Dims (예: String\[])
- TypeVariable + Dims (예: T\[])


```java
Dims:
    {Annotation} [ ] {{Annotation} [ ]}
```

Dims는:
- 0개 이상의 Annotation + \[] + 0개 이상의 ({Annotation} + \[])

즉, 1개 이상의 대괄호 쌍을 의미하며, 각 대괄호 앞에 annotation이 올 수 있다..

예시)
```java
int[]                           // Dims (1차원)
int[][]                         // Dims (2차원)
int @NonNull []                 // Annotation이 있는 1차원
int [] @NonNull []              // 2차원, 두 번째 차원에 annotation
```


## I/O




## NIO




## 자바 8에서 추가된 것


