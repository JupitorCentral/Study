
## Annotation

Java 언어에서 지원하는 2가지 특수 목적의 참조 타입 (참조 - 객체를 가리키는) 중 하나 (다른 하나는 Enum)

도구나 프레임워크에 의해 특별한 처리가 필요한 메소드에 대해서 명명규칙에 특수한 접두사를 받는게
일종의 관습이었음 (test_someMethod 등등)

Annotation 은 이러한 명명패턴의 단점을 해결하고 대체함.

### 주요 기능

기존의 명명패턴과의 차이.

어노테이션은 사용된 대상의 코드에 영향을 미치진 않는다.
하지만 특정 도구가 해당 요서에 특별한 처리를 할 수 있게 해줌.

명명 패턴은 오타가 발생하면 컴파일 시점에 감지되지 않고
묵시적인 실패를 유발하지만 (그러니까 내 생각에는, 실제로 해당 명명패턴을 읽지 못하고 도구나 프레임워크가 
원하는대로 동작하지 않는 것을 의미하는듯.)

애너테이션을 잘못 사용하면 컴파일 에러가 발생.




런타임에 리플렉션 API를 사용해, 특정 애너테이션이 붙은 메서드/클래스를 찾고, 그 정보를 활용할 수 있다.

```java
for (Method m : clazz.getDeclaredMethods()) {
    if (m.isAnnotationPresent(Test.class)) {
        // 테스트 메서드 실행
        m.invoke(null);
    }
}
```

### 어노테이션 타입의 종류 및 선언


- 마커 에너테이션 
파라미터를 가지지 않고, 단순히 주석이 달린 요소를 표시만 함. (@Test 등)


- Annotation with Parameter
어노테이션은 파라미터를 가질 수 있음.

> Class Literal -> 클래스 자체에 대한 참조. (String.class)
> Reflection 에서 클래스를 동적으로 다룰때, 제너릭에서 타입토큰을 넘길때, 프레임워크에서 타입정보가 필요할때


- [ ] admittedly ➕ 2025-10-04 #EnglishWord 
      솔직히 말하자면, 인정하건대, 사실



### Meta-Annotations

에너테이션 선언시 에너테이션 그 자체에 붙이는 에너테이션. 에너테이션을 '설정'함.
메타 애너테이션은 애너테이션의 "동작 방식"을 설정함.

대표적으로 `@Retention`, `@Target` 이 있다.

- @Retention(RetentionPolicy.RUNTIME)

이 에너테이션이 런타임까지 유지가 되어 리플렉션으로 접근하게 만듦.

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnno {
    String value();
}

public class Example {
    @MyAnno("hello")
    public void test() {}
}


import java.lang.reflect.*;

public class Main {
    public static void main(String[] args) throws Exception {
        Method m = Example.class.getMethod("test");
        if (m.isAnnotationPresent(MyAnno.class)) {서
            MyAnno anno = m.getAnnotation(MyAnno.class);
            System.out.println(anno.value()); // "hello" 출력
        }
    }
}
```

만약 Retension Annotation 이 없다면, 컴파일 후 class 파일에 존재하지 않거나
JVM 이 로드할때 버려짐.

- @Target(ElementType.METHOD)
해당 어노테이션이 어떤 요소 (클래스, 메서드 등) 에 쓰일 수 있는지 제한함


@Documented: Javadoc에 포함할지 여부를 지정

@Inherited: 클래스에 붙은 애너테이션이 하위 클래스에도 자동으로 적용될지 지정

@Repeatable: 같은 애너테이션을 여러 번 붙일 수 있게 함







## Thread  vs Process - 어제에 이어서


### Questions 

프로세스도 컴퓨터의 자원을 다른 프로세스와 공유하지 않나? 아닌가? 어쨌든 메모리를 공유하지 않으니 동시성문제가 쓰레드에 비해서 덜한가 ?

#### 프로세스가 '자원을 공유한다' 는 무슨 의미인가 ?

2 개 이상의 독립적인 실행 단위 (프로세스 또는 스레드) 가 동일한 리소스 (메모리, 파일, 하드웨어) 에 접근하거나, 
읽기/쓰기를 할 수 있다는 의미.


#### 프로세스는 기본적으로 다른 프로세스와 메모리를 공유하지 않고, OS 차원에서 다른 메모리에 접근하는 것을 차단한다. 그 이유는 ?

하나의 프로세스가 다른 프로세스의 동작에 간섭하는 것을 방지하기 때문이다.
메모리 침범을 막으므로써 필요한 데이터가 지워진다거나, 잘못된 실행코드가 덮어진다거나 하는 사고를 막을 수 있다.
즉 한 프로세스의 악의적 행동이나 오류가 다른 프로세스에게 영향을 주지 않는다.

따라서 기본적으로 프로세스는 메모리를 공유하지 않는다.

#### 자원의 공유는 기본동작이 아니라 '명시적' 이다

필요할때만 '명시적' 으로 요구하여 자원의 낭비를 막는다.


#### 프로세스 간 자원 공유의 범위는 어디까지일까?

기본적으로 프로세스는 독립적인 메모리 공간 (코드, 데이터, 스택, 힙 등) 을 공유하지 않는다.

##### 프로세스간 공유 가능한 자원

1. Shared Memory
운영체제가 별도로 할당한 메모리 영역.
특정 프로세스의 메모리 영역이 아니라 운영체제가 특정 메모리 영역에 생성한 독립적인 영역임.
이를 프로세스가 자신의 주소공간에 '매핑' 하여 사용한다.

> 자신의 주소 공간에 '맵핑' 한다 ?

	-> 각 프로세스는 자신의 가상의 주소 공간에 공유메모리 영역을 연결함.
	-> 이렇게 되면 각 프로세스는 자신의 메모리 공간 안에서 포인터를 통해 해당 공유 메모리 영역을 접근이 가능해짐.


2. 파일 및 I/O 자원
두 프로세스가 같은 파일을 읽거나 쓸 수 있음.
네트워크 소켓이나 파이프를 통해 데이터를 주고받을 수 있음.

3. IPC (Inter Process Communication) 자원
운영체제가 제공하는 IPC 메커니즘 (메시지 큐 파이프, 세마포어 등) 을 통해 데이터를 주고받거나 동기화할 수 있음

-> 이때 파이프가 2번에도 있고 3번에도 있는 경우는 2가지 특징을 모두 갖기 때문이다.

4. 메모리 맵 파일 (Memory - mapped file)
여러 프로세스가 같은 파일을 메모리에 매핑하면, 해당 파일의 내용을 메모리처럼 공유 가능.


-> 일단 Shared Memory 와 Memory Mapped File 는 다르다. 
원래 방향과 너무 틀어지므로 여기까지.



일단 프로세스는 다른 프로세스와 자원을 기본적으로 공유하지 않는다.































