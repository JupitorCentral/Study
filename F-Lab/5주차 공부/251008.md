
## Generic

[[250913#^45e137]]


### Questions


#### 왜 Java에 Generic이 추가되었는가?

Generic 이 도입되기 전 Java 1.4 에서는 컬렉션이 모두 Object 타입 으로 저장.
```java
// Generic 이전 (Java 1.4)
List list = new ArrayList();
list.add("Hello");
list.add(new Integer(42));
String s = (String) list.get(1); // 런타임에 ClassCastException 발생!
```

Generic 도입 후

```java
// Generic 사용 (Java 5+)
List<String> list = new ArrayList<String>();
list.add("Hello");
list.add(new Integer(42)); // 컴파일 에러! 타입 불일치
String s = list.get(0); // 형변환 불필요
```

따라서,

1. 컴파일 타입 오류 체크

2. 형변환 제거
(위 코드 참조)

3. 코드 재사용성 확보

generic 이 없었다면

```java
// Generic 없이 - 타입마다 클래스를 따로 만들어야 함
public class IntegerPair {
    private Integer first;
    private Integer second;
    // ...
}

public class StringPair {
    private String first;
    private String second;
    // ...
}

public class EmployeePair {
    private Employee first;
    private Employee second;
    // ...
}
```

Generic 덕분에

```java
// Generic 사용 - 하나의 클래스로 모든 타입 지원
public class Pair<T> {
    private T first;
    private T second;
    
    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }
    
    public T getFirst() { return first; }
    public T getSecond() { return second; }
}
```


### Generic Type Parameter(예: \<T>,\<E>)는 정확히 무엇을 의미하는가?

\<T> , \<E> 등은 타입 parameter를 의미함.
제너릭 클래스, 인터페이스, 메서드, 생성자등의 타입 파라미터 선언을 통해 도입됨.

#### 제너릭 클래스

하나 이상의 타입변수를 가지 클래스.

```java
public class Pair<T> {
    private T first;
    private T second;
    
    public Pair() { 
        first = null; 
        second = null; 
    }
    
    public Pair(T first, T second) { 
        this.first = first; 
        this.second = second;
    }
    
    public T getFirst() { return first; }
    public T getSecond() { return second; }
    
    public void setFirst(T newValue) { first = newValue; }
    public void setSecond(T newValue) { second = newValue; }
}
```


나의 답변 :
> "\<T>, \<E>는 제너릭 타입으로 이 선언된 제너릭 타입을 파라미터의 타입으로 선언함으로써 어떤 타입도 파라미터로 쓸 수 있게 해주고, 
> 메서드 내부에도 그 타입으로 무언가 할 수 있게 해줌."

-> 정확한 개념과 범위 (scope) 에 대한 설명 부족.


Type Paramter \<T>, \<E> 는
#### PlaceHolder 역할

타입 파라미터는 실제 타입을 대신하는 placeHolder 이며, 클래스나 메서드가 인스턴스화 할때
구체적인 타입으로 치환됨.
즉 실제 타입이 아니라 나중에 구체적인 타입으로 대체될 자리.

##### 인스턴스화란 ?

**인스턴스화**는 제너릭 타입의 타입 매개변수에 구체적인 타입(actual type parameter)을 대입하는 과정을 의미.

```java
// 제너릭 클래스 정의
public class Pair<T> {
    private T first;
    private T second;
    // ...
}

// 인스턴스화 - String 타입으로 치환
Pair<String> pair = new Pair<String>("one", "two");
```

#### Scope 에 관해

타입 파라미터는 선언된 범위

##### 클래스, 인터페이스의 경우

해당 클래스, 인터페이스의 전체 선언부, 본문 (body)

```java
public class Box<T> {
    private T value; // T 사용 가능
    public void set(T value) { this.value = value; } // T 사용 가능
    public T get() { return value; } // T 사용 가능
}
// Box<T>의 T는 Box 내부에서만 사용 가능

```

static instance variable 에는 사용 불가능

```java
class Cell<T> {
    private static T value; // 컴파일 에러!
}
```


##### 메서드의 경우

해당 메서드 선언부와 본문 (body)

```java
public static <T> List<T> toList(T[] arr) {
    List<T> list = new ArrayList<>(); // T 사용 가능
    for (T elt : arr) { list.add(elt); }
    return list;
}
// <T>는 toList 메서드 내부에서만 사용 가능

```

근데 static method 에는 사용 불가능하다.

```java
class Box<T> {
    private T value;
    public static void print(T val) { // 컴파일 에러!
        System.out.println(val);
    }
}
```




##### 중첩 클래스의 경우

1. 비 중첩 클래스
외부 클래스의 타입 파라미터가 내부 클래스에서도 **그대로 사용** 가능

```java
public class LinkedCollection<E> extends AbstractCollection<E> {
    private class Node {
        private E element;
        private Node next = null;
        private Node(E elt) { element = elt; }
    }
    private Node first = new Node(null);
    private Node last = first;
    private int size = 0;
    // ... 기타 메서드
}
```


2. static 중첩 클래스

사용 불가능.

```java
public class LinkedCollection<E> extends AbstractCollection<E> {
    private static class Node<T> {
        private T element;
        private Node<T> next = null;
        private Node(T elt) { element = elt; }
    }
    private Node<E> first = new Node<E>(null);
    private Node<E> last = first;
    private int size = 0;
    // ... 기타 메서드
}
```



#### Bounds of Type Parameter

타입 파라미터가 어떤 것을 implements 하거나, 또 어떤 것의 부모 클래스임으로 국한 시키는 방법.

##### bounded above, extends

`? extends T`는 T 또는 T의 하위 타입을 나타냄

```java
public class Stack<E> {
    public void pushAll(Iterable<? extends E> src) {
        for (E e : src)
            push(e);
    }
    ...
}

```

? extends E 는 E 를 상속받는 클래스.

만약 E 에 Number 를 지정하면, Iterable의 ? 에는 Number 를 상속받는 클래스가 사용될 수 있음.
만약 ? 가 Integer 이면, Integer 는 넘버를 상속받으므로 사용 가능.
즉 Iterable\<Integer> 가 src 의 타입이 되는 것.


##### multiple bound

```java
public static <S extends Readable & Closeable, T extends Appendable & Closeable>  
void copy(S src, T trg, int size) throws IOException {  
    try {  
        CharBuffer buf = CharBuffer.allocate(size);  
        int i = src.read(buf);  
        while (i >= 0) {  
            buf.flip(); // prepare buffer for writing  
            trg.append(buf);  
            buf.clear(); // prepare buffer for reading  
            i = src.read(buf);  
        }  
    } finally {  
        src.close();  
        trg.close();  
    }  
}
```

타입 파라미터는 여러개의 bound above 를 가질 수 있음.

super 는 불가능.
```java
<T super Number & Serializable>     // 컴파일 에러
```


##### bounded below, super

일반적인 Type Parameter 는 사용 불가능.
와일드 카드 - ? 만 사용 가능

```java
<T super Number> // 컴파일 에러
<? super Number> // 사용 가능
```

와일드 카드는 extends, super 모두 사용 가능.


#### WildCard 란 ?

제너릭 타입의 유연성을 제공하기 위해 사용되는 특수한 기법이다...?

타입 파라미터는 아니다.

##### Type parameter vs Type argument

타입 파라미터 : `<T>` 처럼 클래스, 인터페이스 등에서 선언부에 사용되는 식별자. 인스턴스화 될떄 구체적인 타입으로 대체됨.

타입 인자 : 제네릭 타입을 사용할때 실제로 전달되는 타입. `List<String>` 에서 `String` 이 타입 인자.
		`List<?>` 에서 `?` 도 타입 인자.

##### wildcard 의 형태

###### Unbounded 

모든 타입 허용. 즉 타입에 대한 구체적인 정보가 필요 없을때.


```java
List<?> list = new ArrayList<String>();
```

- 사용 의도

-> 메서드의 변수가 타입에 의존하지 않고 Object 로 써만 사용될때.


###### Upper Bounded

```java
public void pushAll(Iterable<? extends E> src) {
    for (E e : src)
        push(e);
}
```

E 나 그 하위 타입 허용

###### Lower Bounded

```java
public void popAll(Collection<? super E> dst) {
    while (!isEmpty())
        dst.add(pop());
}
```

E 나 그 상위 타입 허용 (super class)

##### PECS

-> WildCard 를 사용 할 떄 중요한 가이드라인.
-> Producer - Extends, Consumer - Super. 




##### WildCard Constraints

- **인스턴스 생성 불가**: `new ArrayList<?>()` ❌
    
- **제너릭 메서드 호출 시 명시 불가**: `List<?> list = Lists.<?>factory()` ❌
    
- **슈퍼타입에 사용 불가**: `class AnyList extends ArrayList<?> {}` ❌



### TypeParamter 쓰면 되지 왜 WildCard 를 쓰는가 ?

```java
public static void printCollection(Collection<?> c) {
    for (Object o : c) {
        System.out.println(o);
    }
}
```

이 코드를 잘 보면

```java
public static <T> void printCollection(Collection<T> c) {
    for (Object o : c) {
        System.out.println(o);
    }
}
```

이 표현으로 대체해도 아무 문제가 없다. 도대체 이럴때 왜 와일드 카드를 쓰는지??

-> printCollection 에서 타입을 명시해봤자, 해당 타입의 메서드를 사용하지 않는다.
-> 즉 T 가 불필요하다.


#### 그럼 와일드 카드를 쓰는 이유?

##### API 의 의도

-> 와일드 카드를 쓰면, 해당 메소드는 타입파라미터에 의존하지 않음을 의미.

-> 만약 타입파라미터를 쓰면, 해당 메소드가 마치 타입에 의존하는 것처럼 보일 수 있음.

##### 타입 추론 필요 없음

###### 타입 추론 (Type Inference) ?

코드에서 명시적으로 지정하지 않아도, 코드의 맥락 (context) 를 보고 타입을 추측하는 과정을 의미.

만약 타입추론이 불가능한 상황이면, 컴파일러가 에러를 낸다.

```java
public static void printCollection(Collection<?> c) {
    for (Object o : c) {
        System.out.println(o);
    }
}
```

만약 위에서 타입 파라미터를 쓴다면, 컴파일러가 호출시점에 타입을 추론해야 한다.
-> 성능 이슈.

그리고 와일드카드를 씀으로써 해당 메서드가 파라미터의 타입과는 상관없이 없음을 의미하는 것은
그냥 아무 타입이든 해당 메서드의 파라미터로 쓸 수 있다는 것을 의미한다.
만약 그게 아니라면 파라미터마다 오버라이딩 해야할 것.

즉 성능 + 편의.

##### 불필요한 타입 파라미터 남용 방지

Type Parameter 는 실제로 그 타입을 해당 body 에서 사용할때만 사용하는 것이 좋다.