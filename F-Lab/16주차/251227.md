## 왜 Atomicity 를 달성하는게 어려운가

### 참조해야 할 부분 


Chapter 17 Transactions
	17.1 Transaction Concept
	17.2 A Simple Transaction Model
	17.4 Transaction Atomicity and Durability
	17.7 Transaction Isolation and Atomicity

Chapter 19 Recovery System
	19.3 Recovery and Atomicity
	19.4 Recovery Algorithm

이 중에서 “왜 어려운지”에 대한 직접적인 근거 문장은 보통 다음 두 군데에 있습니다.

17.4 “Transaction Atomicity and Durability” 서두
19.3 “Recovery and Atomicity” 서두

내용 요지 (어떤 식으로 설명되는지)
각 섹션에서 공통적으로 말하는 어려운 이유는 대략 이런 식입니다.

트랜잭션 수행 중에
디스크/버퍼에 일부만 반영되었을 수 있고
DBMS, OS, 하드웨어, 디스크 등 어느 계층에서든 장애가 날 수 있어서
단순히 “롤백하겠다”고 선언하는 것만으로는 안 되고,

로그 기록(write-ahead logging)
체크포인트, undo/redo 알고리즘
크래시 이후 재시작 시의 복구 절차
같은 메커니즘이 필요하다는 점을 강조하면서

이런 복구 메커니즘을 설계·구현해야만 원자성을 “논리적으로” 보장할 수 있고,
이게 DBMS를 어렵게 만드는 핵심 요인 중 하나라고 설명합니다.

특히 17.4와 19.3 첫 두세 문단을 읽으면,
“트랜잭션 도중 시스템 장애가 발생했을 때 왜 단순하지 않은지”
“그래서 로그 기반 회복이 왜 필요한지”
를 직접적으로 서술하고 있어서, ‘DBMS가 왜 atomicity 달성이 어려운지’에 대한 근거 문장으로 그대로 인용하기 좋습니다.


---

일단 Atomicty 를 보장한다는 것은 Transaction 에서 all or nothing 을 달성한다는 얘기.

### 트랜잭션의 상태

- Active
-> 트랜잭션의 초기 상태
트랜잭션이 실행되는 동안 이 상태에 머물러있음

- Partially committed
-> 트랜잭션의 마지막 statement 가 실행되고 난 다음

- Failed
-> 정상적인 실행이 더 이상 불가능하다는 것을 알아차렸을때의 시점

- Aborted 
-> 트랜잭션에 의해 변경된 사항들이 rollback 되고 db 의 상태가
트랜잭션이 실행되기 전으로 복구된 상태

- Commited
-> 모든 동작이 성공적으로 마무리된 상태

![[Screenshot 2025-12-27 at 7.58.14 PM.png|500]]


하드웨어 문제나 로지컬한 이슈때문에 트랜잭션 내의 스테이트먼트를 실행하기 어려운 경우
failed 상태로 트랜잭션이 진입한다.
롤백을 하는데에 있어 시스템에는 2가지 옵션이 존재함.

1. restart the transaction
근데 하드웨어나 소프트웨어 오류로 인한 에러만 가능
statement 자체의 로지컬한 문제때문이면 재시작 불가능

2. kill the transaction
트랜잭션 내부의 논리 오류
잘못된 입력 데이터
트랜잭션에서 필요한 데이터를 DB 에서 못찾은 경우


### 데이터 접근 구조

(19.2.2 Data Access)
데이터는 block 이라는 fixed 사이즈의 유닛으로 나뉜다.

- physical block 
디스크에 있는 블록

- buffer block
메모리에 올라온 블록

#### 블록에 있는 데이터가 메모리와 디스크 사이 움직이는 동작

- _input_ (B)
physical block B 를 메인 메모리에 옮긴다

- _output_ (B)
buffer block B 를 디스크에 옮기고 적절한 위치의 physical block 을 대체한다.


#### 데이터를 옮길때 동작

여기서 지역변수 $x_i$ 는 트랜잭션의 지역변수이다.

##### read (x)
X 라는 아이템의 값을 지역변수 $x_i$ 에 저장할때

1. 만약 X 라는 데이터가 존재하는 Block $B_x$ 가 메인메모리에 존재하지 않을때, _input($B_x$)_ 를 호출한다.
2. 그리고 메인메모리에 올라온 _$B_x$_ 를 지역변수 x 에 할당한다

##### write(x)

지역 변수 $x_i$ 의 값을 X 라는 데이터 아이템에 저장하는 경우

1. 만약 X 라는 데이터가 존재하는 Block $B_x$ 가 메인메모리에 존재하지 않을때, _input($B_x$)_ 를 호출한다.
2. 그리고 메인메모리에 올라온 _$B_x$_ 에 지역변수 x 의 값을 설정한다

만약 트랜잭션이 맨처음에 data item X 에 처음으로 접근해야 한다면
트랜잭션은 무조건 _read(x)_ 를 호출해야 한다.

그 다음부터는 트랜잭션이 X에 대한 모든 변경을 메모리 안의 변수 $x_i$에 대해 수행한다.
(즉, DB 페이지가 아니라, 트랜잭션의 로컬 변수에다 계속 업데이트하는 것.)

트랜잭션 수행 도중 **원하는 시점에** `write(X)`를 실행할 수 있는데, 이 연산은 지금까지 $x_i$
에 해 온 변경 사항을 **데이터베이스의 X에 반영**하는 역할을 한다.

여기서 중요한 점은, 만약 시스템이 `write(X)`는 이미 실행된 뒤인데, 아직 `output(BX)`가 실행되기 **전에 크래시가 나버리면**,
- X의 새 값은 **디스크에 한 번도 쓰이지 못하고**,
- 결국 그 값은 **유실된다는 것**이다

##### 요약

read(X) 하면 디스크/버퍼에서 X를 읽어와서 로컬 변수 xi에 담고,
이후 계산은 계속 xi 위에서만 하고,
“이제 DB에 반영할래” 하는 시점에 write(X)로 버퍼 블록의 X를 갱신한다.
하지만 그게 곧바로 디스크에 쓰이는 건 아니고, output(BX)가 언제 호출되느냐에 따라 디스크 반영 시점이 밀릴 수 있다.
그래서 write(X)까지 했는데 크래시가 나면, 디스크에는 여전히 옛날 값이라서 새 값이 날아갈 수 있고, 
이런 상황에서도 커밋된 변경이 안 날아가게 하려고 로그/복구 메커니즘을 붙인다.

커밋된게 곧바로 디스크에 반영이 안되는게 문제. 
커밋된 데이터의 블록은 메모리에 남고, 이 사이에 크래쉬가 나버리면 메모리에 있던 커밋되어 변경된 데이터가 날아가 버린다.


##### 예시 상황

계좌 A 에는 1000, 계좌 B 에는 2000 이 있다고 하자
Transaction x 는 계좌 A 에서 B 로 50 을 보내는 동작이다.

여기서 x 의 동작중에 트랜잭션으로인한 동작 수행후 output (A), output(b) 가 일어나야 각각 디스크에 950, 2050 이 적용된다.
근데 ouput(A) 가 일어나고 나서 output(B) 가 이루어지기 전 시점에 크래쉬가 나버리면
디스크에 각각 950, 2000 이 저장된다.

DBMS 의 트랜잭션 실패시 선택지 2가지 중에 , 시스템 크래쉬가 발생할경우
트랜잭션을 재시작하는데

이 트랜잭션을 재시작 하는데에 있어서 초기상태가 이전 상태와 달라져버린다.
이는 원자성이 깨져버리는 상황이 된 것이다.

##### stable storage

이러한 문제를 해결하기 위해 실제 db 를 변경하기 전에
어떤 변경이 일어나는지를 설명하는 정보를 안전 저장장치 (stable storage)에 저장해두어야 한다.

그리고 어떤 트랜잭션이 값을 수정할때 이전상태의 값도 보존할 필요가 있음.
이렇게 저장한 정보는 rollback 때 쓰인다.

이런 복구를 위한 일반적인 기법으로는 로그가 있다.


##### 다른 이유 - 성능을 위한 steal + no-force 정책

######  force / non-force

commit 하여 트랜잭션이 끝나고 난 변경사항이 메모리에 남아있는걸
disk 에 바로 적용하는 정책을 force 라 하고

no-force 는 disk 에 아직 커밋되지 않는 데이터들을
트랜잭션 실행중에 조작및 업데이트할 수 있게 허용하는 정책이다.

no-force policy 는 트랜잭션의 커밋 속도가 빠르다.

그러나 no-force policy 는 디스크와 메모리간 데이터 간극을 높이기때문에
atomicity 를 달성하는데 힘들게 하는 원인이 된다

###### steal / no-steal

no-steal 은 active 한 상태의 트랜잭션이 수정하고 있는 데이터 블록이
디스크에 쓰이지 말아야 하는 정책이다. 그러니까 아직 끊나지 않은 트랜잭션이 수정한 데이터가 디스크에 쓰이지 못하게 막는 것.

반대로 steam 은 transaction 이 완전히 커밋되지 않아도 변경된 데이터가 디스크에 쓰여지게 하는 policy 이다.

이러면 또 어떤 데이터는 메모리에서 디스크에 쓰여지고 어떤 데이터는 


