# DBMS 에서 왜 Atomicity 를 달성하기 어려운가

## Query 가 DBMS 에 들어오면 어떤 흐름으로 처리되는가

- 전체 엔진 구조(아주 거친 1장 레벨)
1.6 Database Engine: 사용자가 쿼리를 던졌을 때, DB 엔진이 하는 일(저장, 처리, 관리)을 블록 다이어그램 수준에서 설명한다.

1.7 Database and Application Architecture: 클라이언트–서버 / 3-tier 구조 속에서 DBMS가 어디에 위치해 있고, 애플리케이션에서 어떻게 쿼리가 넘어오는지 볼 수 있다.

- 저장·버퍼 쪽 경로 (디스크 I/O 관점)
13.1 Database Storage Architecture: 데이터/인덱스 파일, 시스템 카탈로그, 로그 등이 디스크에 어떻게 배치되는지, DBMS 내부 저장 구조의 큰 틀이 나온다.

13.5 Database Buffer: 쿼리 실행 중 페이지가 메모리로 올라오고 내려가는 흐름(버퍼 매니저 역할)을 설명해서, “실행 엔진 ↔ 버퍼 ↔ 디스크” 경로를 이해하는 데 핵심이다.

- 쿼리 처리 파이프라인 (실행 계획 관점)
15.1 Overview: SQL 쿼리가 들어왔을 때 어떤 연산들(선택, 조인, 정렬 등)로 분해되어 실행되는지, 전체 query processing 파이프라인의 개요가 나온다.

15.7 Evaluation of Expressions: 연산자 트리(실행 계획)를 실제로 어떻게 평가할지, 연산자 간 파이프라이닝 등 실행 흐름을 그림과 함께 보여준다.

- 쿼리 최적화 (파서 뒤–실행 전 단계)
16.1 Overview: 사용자가 쓴 SQL이 논리적 연산자로 변환되고, 그게 다시 여러 물리적 계획 후보로 바뀐 뒤 하나를 선택하는 전체 최적화 플로우를 요약한다.

16.4 Choice of Evaluation Plans: 비용 추정과 함께 어떤 계획을 고르는지, 즉 “파서/논리 계획 → 물리 계획 → 실행 엔진으로 넘기는” 부분의 핵심이다.

- 트랜잭션·원자성 관점의 흐름
17.2 A Simple Transaction Model: 하나의 트랜잭션이 어떤 상태들을 거치며 실행/커밋/어보트 되는지, 개념적인 실행 흐름을 다룬다.

17.4 Transaction Atomicity and Durability: 실행 도중/커밋 시점에 로그/디스크 반영이 어떻게 엮이는지, 원자성을 어디서 보장하려 하는지의 “흐름 요약”이 있다.


### 전체 엔진 구조

엔진은 크게 Store manager, Query Processor, transaction manager (recovery manager) 로 구분됨

Store manager 는 파일/페이지/레코즈 조직, 인덱스, 버퍼 관리등을 맡고
Query Processor 는 SQL parsing, 실행 계획 생성, 연산자 실행 (select, join, sort) 등을 담당함.

- 실행 흐름
-> 사용자가 SQL 을 보낸다 -> 파서가 이를 내부 표현(논리 계획)으로 바꾼다 -> 여러 논리계획중 가장 최적화가 잘된 후보를 하나 골라 물리 실행 계획을 만든다
-> 실행 엔진은 이 계획에 따라 연산을 수행하면서 필요할때마다 Store Manager 에게 페이지를 요청하고,
이 과정에서 Transaction  management, Concurrency control / log, recovery module 등이
atomicity, isolation, durability 를 지키기 위해 개입함.

Store Manager components 에 
Transaction manager, Authorization and integrity manager, File manager, Bugger Manager 등이 포함됨

Query Processor 에는
DDL interpreter, 
DML compiler, 
Query evaluation Engine 등이 포함됨


### 실행 흐름 with corresponding components role

1. 어플리케이션이 DBMS 에 실행할 쿼리를 전송
먼저 app 이 TLS 를 통해 DBMS 를 연결, 실행할 SQL (DML, Data manipulation language, select / update /delete) 을 전송

이 SQL이 DBMS의 Query Processor로 전달. 
이때 각 요청은 항상 어떤 트랜잭션 컨텍스트 안에서 실행되며, 
사용자가 명시적으로 BEGIN을 하지 않은 경우에도 DBMS는 자동 커밋 모드에서 쿼리마다 내부적으로 트랜잭션을 생성한다.​

2. Authorization / Integrity 검사
Authorization and integrity manager 가 사용자가 쿼리에 다른 테이블, 컬럼에 접근 권한이 있는지 , 어떤 연산이 허용되는지 확인 (Authorization)
그리고 제약 조건 (기본키, 외래키 등) 을 만족하는 쿼리인지도 확인, 이 동작은 실행 후에도 이루어진다

통과하지 못하면 실행 종료

3. 파싱 + 컴파일(DML compiler)
Query Processor 에 포함되는 DML compiler 가 
SQL 문자열을 파싱하여 구문 의미 분성을 하고, 내부 표현 (논리적 연산자 트리) 를 만든다.
이 논리계획을 바탕으로 어떤 인덱스를 쓸지 어떤 조인 순서/알고리즘을 쓸지 여러 후보를 생성하고
비용을 평가해 그 중 하나의 가장 비용이 적은 실행계획을 선택

이때 만들어진 실행계획은 캐시에 넣어두어 이후 유사 쿼리 요청시 재사용.

4. 실행 계획 수행 (Query Evaluation Engine)
Query Processor 에 포함된 Query Evaluation Engine 이 선택된 실행 계획 (연산자 트리) 에 따라
실제로 연산을 실행한다.

실행 중에 각 연산자에 따라 필요한 것들 - page, records, index 등을 Storage manager 에 요청한다 

이 부분부터 논리적 부분에서 실제 데이터 접근 부분으러 넘어가기때문에 Storage manager 쪽 컴포넌트들이 본격적으로 개입

5. Storage Manager 진입 – File / Buffer Manager
File Manager 가 테이블/인덱스가 어떤 파일/페이지 구조로 디스크에 저장되어있는지 알고 있음.
그래서 File manager 가 file X 의 페이지 N 과 같은 - X 라는 파일에 N 이라는 페이지를 읽거나 쓰는 저수준의 동작을 실행함.

Buffer Manager 가 필요한 페이지가 메모리에 있는지 확인하고, 없으면 디스크에서 읽어 버퍼 풀에 적재한다.
페이지 교체 정책을 적용해서 어떤 페이지를 메모리에 적재할지 판단한다.

즉 File / Buffer Manager 가 실제로 데이터를 물리적으로 읽어들이는 역할을 함

이 둘은 같이 움직인다.

> Query processor → Storage manager → Buffer manager → (없으면) File manager → 디스크 → Buffer manager → Query processor (쿼리 실행 연산자가 Buffer Manager API 를 호출해 페이지를 받아 쓰는 형태)


6. Transaction manager의 개입 (동시성/록)
현재 Transaction 의 읽기/쓰기 요청에 따라 필요한 락을 획득하거나 검사한다.

다른 트랜잭션과 충돌 (lock competition, dead lock) 등이 나지 않도록 스케쥴링하고, 격리 수준에 따라 어떤 읽기/쓰기 패턴을 허용할지 결정한다.

쿼리 실행 엔진이 "이 레코들을 읽을/쓸 거다" 라고 할려고 할때 실제 I/O 전에 transactino manager 가
락 체크를 선행한다.

-> Query evaulation Engine 이 논리적 연산을 맡고 Transaction Manager 가 Acid 를 유지하는 구조


7. 로그 기록 + 디스크 반영 (원자성/지속성)
쓰기 연산 (Insert, update, delete) 이 일어나면 
로그 관리자 (보통 transaction / recovery manager 의 일부) 가 변경내용을 로그에 기록함

Buffer Manager 는 로그 순서를 지키도록 transaction/recovery manager 와 협력하여 데이터를 메모리에 적재하거나 쓴다 (File manager 를 통해)

이러한 단계를 통해 systme 에서 crash 가 나더라도 로그를 보고 undo/redo 를 수행해 원자성/지속성을 유지할 수 있음

8. 결과 반환 + 커밋/롤백

Select 라면 Query Evaluation engine 이 결과 tuple 들을 만들어 클라이언트에게 스트림으로 보내고,
사용하고 나서 필요없어진 페이지/락을 해제한다 

변경을 수행하는 트랜잭션이면 
어플리케이션이 commit 을 호출하면 transaction manager 가 필요한 모든 로그기록이 저장되었는지 확인
락을 해제하고 트랜잭션 상태를 commited 로 업데이트

rollback 이면 현재 트랜잭션에서 한 변경을 undo 하고 로그와 메모리상태를 되돌린다.










