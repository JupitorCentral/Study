

# 토비의 스프링 7장

## SQL 과 DAO 의 분리

### SQL 제공 서비스

SQL 과 DI 설정정보가 섞여있으면 보기에도 지저분하고 관리하기에도 좋지 않다.

SQL 을 꼭 xml 에 담아둘 필요는 없다.
sql 정보 파일 포맷이 있더라면.
아니면 sql 를 db 에 저장한다면.
웹서비스나 리모팅을 이용해 최신 SQL 정보를 가져온다면.

스프링의 설정파일로 생성된 오브젝트와 정보는 
어플리케이션을 다시 시작하기 전에는 변경이 매우 어려운 것도 문제.

-> DAO 가 사용할 SQL 을 제공해주는 기능을 독립시킬 필요가 있다.

#### SQL 서비스 인터페이스

SQL 서비스 인터페이스를 설계를 하자.
기능 -> SQL 에 대한 키를 던저주면 그에 해당하는 쿼리를 리턴하는 것.

주어진 키를 이용해 어디서 쿼리를 가져오는지, 어디에 저장되어있었는지, 어떻게 찾아오는지는
DAO 의 관심사항이 아님.

```java
public class UserDaoJdbc implements UserDao {
	...
	private Sqlervice sqlService;
	
	public void setSqlService (SqlService sqlService) {
		this. sqlService = sqlService
	}

}


public class UserDao {
	public void add (User user) {
		this.jdbcTemplate.update(this.sqlService.getSql("userAdd"),
			user.getId(), user.getName(), user.getPassword() ...
		)
	}
}
```

#### 스프링 설정을 사용하는 단순 SQL 서비스

늘 하던 것처럼 SqlService 구현체를 생성하고 
xml 을 통해 sqlService 를 UserDaoJdbc 에 주입해준다.
이 sqlService 구현체 SimpleSqlService 의 map property 를 또 Spring 의 xml 설정을 통해 map property 를 설정해서 sql 문읠 정의

```java

public class SimpleSqlService implements SqlService {
	private Map<String, String> sqlMap;
	
	public void setSqlMap(Map<String, String> sqlMap) {
		this.sqlMap = sqlMap;
	}
	
	public String getSql (String key) throws SqlRetrieval ... Exception {
		String sql = sqlMap.get(key)
		if (sql == nul)
			throw new SqlRetrieval ... Exception(key + "에 대한 sql 을 ...")
		else 
			return sql;
	}
}
```


```xml
<bean id="userDao" class="springbook.dao.UserDaoJdbc">
	<property name="dataSource" ref="dataSource" / >
	<property name="sqlService" ref="sqlService" / >
< /bean>

<!-- 바로 위에 선언해두었던  sqlService 필드에 대한 구현체 설정 -->>

<bean id="sqlService" class="springbook.user.sqlervice.SimpleSqlService">
	<property name="sqlMap"/ >
		<map>
			<entry key="userAdd" value = "insert user(id, name, password, email) values(?, ?, ?)" / >
			...
		< /map>
	< /property>
< /bean>
```



## 인터페이스 분리와 자기참조 빈

### XML 파일 매핑

`<bean>` 태그 안에 sql 정보를 넣어두고 활용하는건 그리 좋은 방법은 아님.
sql 전용 포맷을 가진 독립적 파일로 구분하자.

XML 에 담긴 정보를 파일에서 읽어오는 방법은 다양한데, 그 중 하나는 JAXB
(Java Architecture for XML Binding)

xml 파일을 만들고 xjc 명령어를 통해 특정 파일에 해당 xml 파일정보를 바인딩해줌
그럼 컴파일러가 바인딩 된 클래스를 알아서 코드로 생성해줌.

그러니까 sql 전용 xml 파일을 설정하고
그걸 JAXB 를 통해서 클래스 파일과 자동으로 매핑 -> 타입에 맞는 클래스를 자동으로 생성해주고,
xml 에 설정한 프로퍼티 마다 매핑된 클래스의 인스턴스가 생성됨.
java code 에서는 그 생성된 인스턴스를 쓰면 됨.


XML 문서를 잃어서 자바의 오브젝트로 변환하는 것을 JAXB 에서는 언마샬링이라고 함.
반대로 바인딩 오브젝트를 xml 문서로 변환하는건 마샬링이라고 함.

먼저 xml 문서의 구조를 정의하는 스키마를 만들어야 함.

(sqlmap.xsd)
```xml
<?xml version="1.0" encoding="UTF-8">
<schema xmlns="http://www.w3.org/2001/XMLSchema" 
	targetNamespace="http://www.epril.com/sqlMap" .... >
	
	<element name="sqlmap">
		<complexType>
			<sequence>
				<element name="sql" maxOccurs="unbounded" type="tns:sqlType" / >
			< /sequence>
		< /complexType>
	< /element>
	
	<complexType name="sqlType">
		<simpleContent>
			<extension base="string">
				<attribute name="ley" use="required" type="String" / >
			< /extension>
		< /simpleContent>
	< /complexType>
< /schema>
```

이 상황에서 
```bash
xjc -p springbook.user.sqlservice.jaxb.sqlmap.xsd -d src
```
명령어를 치면

springbook\user\sqlservice\jaxb\SqlType.java
springbook\user\sqlservice\jaxb\Sqlmap.java

파일이 생성됨. (위 xml 에 정의된 타입의 바인딩 클래스)


sqlmap.xml 을 UserDao 와 같은 패키지에 저장
```xml
<?xml version="1.0" encoding="UTF-8">
<sqlmap xmlns="http://www.epri.com/sqlmap" 
		xmlns:xsi="http: ....">
		<sql key="userAdd"> insert into users (id, name, password ... ) values (?, ?, ?, ...) < /sql>
< /sqlmap>
```

```java
public class XmlSqlService implements SqlService {
	private Map<String, String> sqlMap = new HashMap<String, String> ();
	
	public  XmlSqlService() {
		String contextPath = Sqlmapclass.getPackage().getName();
		try {
			JAXBContext context  = JAXBContext.newInstance(contextPath);
			Unmarhaller unmarchaller = context.createUnmarhcaller();
			InputStream is = UserDao.class.getResourceAsStream("sqlmap.xml");
			Sqlmap sqlmap = (Sqlmap)unmarchaller.unmarchal(is);
			
			for (SqlType sql : sqlmap.getSql()) {
				sqlMap.put(sql.getKey(), sql.getValue());
			}
		}
	}

	public void String getSql(String key) throws ... {
		String sql = sqlMap.get(key);
		if (sql == null) throw new ...
		else 		return sql;
	}
}
```


### 빈 초기화 작업 개선

생성자에서 예외가 발생할 수도 잇는 복잡한 초기화 작업을 다루는건 좋지 않음

읽어들일 파일의 위치와 이름이 코드에 고정되어있는 것도 좋지 않음 (하드코딩)
-> 외부에서 DI 로 설정할 수 있게 만들어야 함

XmlSqlService 클래스에 sqlmapFile 을 인젝션하면 된다. 
```java
private String sqlmapFile;

public void setSqlmapFile(String sqlmapFile) {
	this.sqlmapFile = sqlmapFile;
}
```

그리고 생성자에서 에러가 발생할만한 부분을 빼서 메소드로 생성

```java
public void loadSql() {
	String contextPath = Sqlmapclass.getPackage().getName();
		try {
			...
			InputStream is = UserDao.class.getResourceAsStream(sqlmapFile);
			...
		} ...
}
```

그럼 loadSql 은 언제 실행되어야 하며, 어떻게 실행시킬 수 있을까 ?

우리한테 XmlSqlService 의 제어권이 있다면 우리가 메소드를 호출해주면 된다.
그런데 Spring 에서 Bean 의 제어권은 Spring 에게 있으므로 Spring에게 맡길 수 밖에 없으며,
스프링은 빈 오브젝트를 생성하고 Di 작업을 수행해서 프로퍼티를 모두 주입해준 뒤에 미리 지정한 초기화 메소드를 
호출해주는 기능을 가지고 있다.
-> 빈 후처리기.

어노테이션을 이용한 빈 설정을 지원해주는 몇 가지 Bean 후처리기가 있음.

스프링 설정 파일 - applicationContext.xml 등에서
context schema 에 정의한 태그를
context namespace 를 통해 사용하도록 정의할 수 있음

```java
<beans xmlns="http://www.springframework.org/schema/beans"
	...
	xmlns:context="http://www.springframework.org/schema/context"
	...
	>
	
	<tx:annotation-driven / > // @Transactional 이 붙은 타입과 메소드에 트랜잭션 부가기능을 담은
							// 프록시를 추가하도록 만들어주는 후처리기 등록
	
	<context:annotation-config / >  // 코드의 어노테이션을 이용해서 부가적인 빈설정 또는 초기화 작업을 해주는 후처리기 등록
...
```

그래서 loadSql 에 @PostConstruct 를 붙여 빈의 초기화 메소드로 지정할 수 있음


### 변화를 위한 준비 : 인터페이스 분리

XML 대신 다른 포맷의 파일에서 SQl 을 읽어오게 하려면 ?
또,  읽어들여온 SQL 정보를 HashMap 이 아닌 다른 방식으로 저장해서 가져오려면?

지금 구조에서는 XmlSqlService 의 코드를 직접 뜯어 고쳐야 한다.

XmlSqlService 에서 책임을 분리해야 한다.

#### 책임에 따른 인터페이스 정의

XmlSqlService 구현에서 독립적으로 변경 가능한 책임은 ? 2가지가 있을 수가 있다.

1. SQL 정보를 외부의 리소스로부터 읽어오는 것

2. 읽어온 SQL 을 보관해두고 있다가 필요할때 제공하는 것

부가적인 책임 -> 서비스를 위해서 한번 가져온 SQL 을 필요에 따라 수정할 수 있게 해주는 것.

DAO -> SqlService -> SqlReader  - - - - - -> Sql Resource
				-> SqlRegistry          <- SqlUpdater

SqlService : Dao 가 Sql 을 요구하면 리턴해주는 역할
Sql 리턴해주기 위해 초기에 특정 문서에서 Sql 정보를 불어들이고 그걸 특정 데이터 구조에 저장함.

이후

SqlReader 라는 빈이 있어 SqlService 라는 빈에서 
어떤 파일에서 Sql 정보를 읽어들일지에 대한 관심사를 분리

SqlRegistry 라는 빈을 만들어 SqlService 라는 빈에서
어떤 데이터구조로 값을 저장할지에 대한 관심사를 분리

기능을 추가 : SqlUpdater 라는 빈을 생성하여
동적으로 Sql 을 수정

SqlReader는 SqlRegistry 의 구현체에 값을 저장함.

### 자기 참조 빈으로 시작하기 (?)

#### 다중 인터페이스 구현과 간접 참조

XmlSqlService 는 SqlService, SqlReader, SqlRegistry 에 의존
JaxbSqlReader 는 SqlReader 와 SqlRegistry 에 의존
hashMapSqlRegistry 는 SqlRegistry 에 의존

이 세 개의 인터페이스를 하나의 클래스가 모두 구현한다면 ?

인터페이스는 다중 상속이 가능하므로 XmlSqlService 가 SqlService, SqlReader, SqlRegistry 을 모두 구현

이렇게 함으로써 성격이 다른 코드를 다른 인터페이스에 정의하게 하여
관심사의 분리를 이루어냄 
-> 근데 솔직히 이 것의 이점을 모르겠음.
이것의 시작은 XmlSqlService 에서 sql 을 읽을 파일을 유동적으로 바꾸기 위함인데
왜 한 곳에서 구현을 다시 해버리는지.

어쨌든 이렇게 하면 코드가 신기해지는데,
자기 자신이 interface 의 구현을 하기때문에 그냥 자기자신.method 실행하면 되는데
이렇게 하면 안되고 또 itnerface.method 로 불러와야 한다고 한다.

그런데 이렇게 분리하는 것에 대한 장점은
나중에 해당 인터페이스에 대한 구현이 바뀔때 XmlSqlService 에서 분리하고 그 구현체를 Bean으로 주입하면 그만이기 때문이다.
이러면 XmlSqlService 에서 파일 설정이 바뀌거나 sql 저장 데이터 구조가 변경되면 분리하면 그만이다.

일단 현재는 XmlSqlService 에서는 모든 인터페이스를 구현하므로
어떤 파일에서 값을 불러들이는지, 어떤 데이터구조로 저장하는지도 다 구현되지만
나중에 이 부분만 변경되면

다른 코드들은 영향을 받지 않는다. 왜냐하면 interface 의 메서드를 사용하기 때문.
그러니까 변경되는 코드 부분을 최소화했다고 볼 수 있다.

#### 자기 참조 빈 설정

이떄 주입을 어떻게 해주냐면 자기 자신이 빈을 구현하므로
의존성 주입시 자기 자신을 참조하게끔 해야 한다.

```xml
<Bean id="sqlService" class="springbook.user.sqlService.XmlSqlService">
	<property name="sqlReader" ref="sqlService" / >
< /Bean>
```


이런 방식은 흔히 쓰이는 방법은 아니다.
다만 자기 참조 빈을 만들어보는것은 책임과 관심사가 복잡하게 얽혀있어
확장이 힘들고 변경에 취약한 구조의 클래스를 유연한 구조로 만들려고 할때 처음 시도해볼 수 잇는 방법.


### 디폴트 의존 관계


#### 확장 가능한 기반 클래스

이게 자기참조에서 의존성들을 DI 를 통해 완전히 분리해보자.

```java
public class BaseSqlService implements SqlService {
	protected SqlReader sqlReader;
	protected SqlRegistry sqlRegistry;
	
	public void setSqlReader(Sql Reader sqlReader) { this.sqlReader = sqlReader }
	public void setSqlRegistry ( ... ) ...

	@PostConstruct
	public void loadSql() {
		this.sqlReader.read(this.sqlRegistry)
	}
	
	public String getSql(String key) throws SqlRetrievalFailureException {
		try {
			return this.sqlRegistry.findSql(key);
		}
			catch ...
	}
}
```

이제 BaseSqlService 을 sqlService 빈으로 등록하고
SqlReader 와 SqlRegistry 를 구현한 클래스 역시 Bean 으로 등록해서 DI 해주면 됨.


근데 유연성은 있는데 적어도 3개의 빈을 등록해주어야 한다는 점이 귀찮을 수 있다
#### 디폴트 의존관계를 갖는 빈 만들기

디폴트 의존관계란 외부에서 DI 를 받지 않는 경우 기본적으로 자동 적용되는 의존관계를 말한다.


```java
public class DefaultSqlService implements SqlService {

	public DefaultSqlService () {
		setSqlReadser(new JaxbXmlSqlReader());
		setSqlRegistry(new HashMapSqlRegistry());
	}
}
```

그런게 이렇게 하면 JaxbXmlSqlReader 의 sqlmapFile property 가 주입되지 않았기때문에 에러가 발생한다.

방법으로는 sqlmapFile 을 DefailtSqlService 의 프로퍼티로 주입하는 방법이 있다.
그런데 그렇다는건 설정을 한다는 것이고, 우리는 디폴트로써 어떤 기능을 사용하려고 하는것이다.
이 빈이 바뀌면 디폴트가 덮어 씌워지게 된다는 것이다.

그런데 JaxbXmlSqlReader 를 반드시 사용하리라는 보장이 없다. 단지 디폴트 의존성이기 때문에.

JaxbXmlSqlreader 는 DefaultSqlService 의 sqlReader로써 그대로 사용해도 좋을 구현이므로 디폴트 의존 오브젝트로 만든것이다.
그렇다면 마찬가지로 sqlmapFile 의 경우도 JaxbXmlSqlReader 에 의해 기본적으로 사용될만한 디폴트 값을 가질 수 있을 것이다.


```java
public class JaxbXmlSqlReader implements SqlReader {
	private static final String DEFAULT_SQLMAP_FILE = "sqlmap.xml"
	
	private String sqlmapFile = DEFAULT_SQLMAP_FILE;
	
	public void setSqlmapFile(String sqlmapFile) { this.sqlmapFile = sqlmapFile}
}
```

DI 를 사용한다고 해서 항상 모든 프로퍼티 값을 설정에 넣고, 모든 의존성을 빈으로 일일히 지정할 필요는 없다.

근데 디폴트 의존 오브젝트를 사용하는 단점에는
일단 다른 것을 쓸려고 설정하기 전에 이미 디폴트 의존 오브젝트가 생성된다는 점이다. 이럼 낭비다.
만약 디폴트 오브젝트가 생성되는 비용이 너무 많다면 @PostConstruct 등의 초기화 메소드를 이용해
프로퍼티가 설정됬는지 확인하고 없는 경우에만 디폴트 오브젝트를 만드는 방법을 사용할 수 있다.

## 서비스 추상화 적용

JaxbXmlSqlReader 는 좀 더 개선하고 발전시킬 부분이 있다.

-> 자바에는 JAXB 외에도 다양한 매핑 기술이 있다. 필요에 따라 원하는 기술을 사용할 수 있게 해야 한다.
-> 현재는 UserDao 클래스와 같은 클래스패스 안에서만 XML 을 읽어올 수 있는데, 임의의 클래스 패스나 임의의 위치,
또는 HTTP Protocol 등을 통해 원격으로 가져올 수도 있게 할 수 있다.

### OXM 서비스 추상화 (Object XML Mapping)

SqlReader 에서 Unmarchaller 인터페이스를 이용한다.


### 리소스 추상화

