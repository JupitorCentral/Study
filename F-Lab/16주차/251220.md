# 토비의 스프링

- 스프링에서는 빈 주입이 xml 설정을 통해 가능하다.
- UserDao 의 시작 : 사용자 정보를 DB 에 넣고 관리할 수 있는 클래스.

- 메소드를 통한 중복의 제거
-> Connection 을 생성하는 부분이 중복되어, db 의 커넥션을 얻고 반환하는 메소드를 작성.

UserDao 가 서로 다른 DB 를 사용해야 한다면 ?

## 상속을 통한 확장

UserDao 클래스 자체와 UserDao 의 getConnecton 을 Abstract 로 선언,
이를 상속받아 DB 별로 클래스를 생성, getConnection 을 구현.

- 템플릿 메소드 패턴
슈퍼클래스에 기본적인 로직의 흐름을 만들고,
그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법

- 팩토리 메서드 패턴
서브 클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴
-> getConnection 에서 Connection 이라는 객체를 메소드에서 생성하여 리턴하기 떄문에 이것도 팩토리 메서드패턴이라 할 수 있다

UserDao 의 관심사항 -> 어떤 기능을 사용한다는 데에만 관심이 있음
NUserDao 와 DUserDao 의 관심사항 -> 어떤식으로 Connection 을 제공하는지, 어떻게 Connection 을 생성하는지에 관심

## 상속의 단점

만약 UserDao 가 다른 목적을 위해 상속을 사용하고 있다면 ?
-> 단지 커넥션을 위해서 상속을 쓴다면 java 는 다중상속을 지원하고 있지 않기때문에 다른 클래스를 상속받을 수 없다

또, 상속을 통한 상하위 클래스의 관게는 생각보다 밀접하다.
-> 슈퍼 클래스 내부에 변경이 있으면 서브 클래스도 그에 맞춰서 다 변경해야 함

## 클래스의 분리

처음에는 독립된 메소드
-> 상속
-> 상속도 아닌 완전한 독립클래스


```java
public class UserDao {
	private SimpleConnectionmaker maker;
	
	public UserDao() {
		maker = new SimpleConnectionMaker()
	}
}
```

```java
public class SimpleConnectionMaker {
	public Connection makeNewConnection throws ... {
		Class.forName(...)
		Connection c = DriverManager ... 
		...
		return c
	}
}
```

> 수정은 했지만 기능에 변화는 없다. 내부 설계를 변경해서 좀 더 나은 코드로 개선했을 뿐
> 기능에 변화가 없다는 것은 리팩토링 작업의 전제이지만 검증 내용이기도 하다.
> 정말 기능의 변화가 없는지 일일히 확인하여야 한다. -> 테스트 코드의 중요성


이렇게 수정하면 N 사와 D 사가 UserDao 를 상속받아서 사용하는게 불가능해짐.

그리고 UserDao 코드의 수정 없이 DB 커넥션의 생성 기능을 변경할 방법이 없음.
즉 UserDao 의 소스코드를 함께 제공하지 않고서는 DB 연결방법을 바꿀 수 없다는 문제로 되돌아옴.

클래스를 분리한 경우에도 상속을 썼을때처럼 자유로운 확장이 가능해지려면 다음의 문제를 해결해야 함
1. SimpleConenctionMaker 의 메소드가 문제
우리의 SimpleConnectionMaker는 getConnection 이란 메소드를 쓰는데,
다른 회사의 DB 커넥션 제공 클래스가 openConnection 이라는 이름을 쓴다면
UserDao 의 코드를 일일이 변경해주어야 한다.

2. DBConnection 을 제공하는 클래스가 어떤 것인지 UserDao 가 구체적으로 알고 있어야 함
N 사에서 다른 클래스를 구현해버리면 또 UserDao 를 자체 수정해야 함

## 인터페이스의 도입

이러한 문제를 해결하기 위해 UserDao 와 DbConnection 사이에 
느슨한 추상적인 연결고리를 도입할 수 있다.

추상화 : 공통적인 속성을 추출하는 것
-> 인터페이스

인터페이스는 클래스의 구체적인 정보는 모두 감춤.
결국 오브젝트를 만들려면 구체적인 클래스 하나 (구현체) 를 선택해야 겠지만

인터페이스를 사용하면 사용하는 입장(클라이언트) 에서는 구현을 어떻게 했는지 몰라도 됨
단지 어떤 기능이 있는지 알기만 하면 되고 그 기능을 쓰기만 하면 됨

```java
public interface ConnectionMaker {
	makeConnection()
}
```

UserDao 에서는 ConnectionMaker 를 상속받아 구현하는 어떤 구현체를 사용하면
그 구현체가 어떤 것이든 간에 makeConnection 을 호출하면
커넥션을 받을 수 있음.

-> 메소드 시그네쳐 자체를 interface 에서 정의해버리기 때문에
이를 상속받아 구현하는 Db maker 들은 시그네쳐가 같을 수 밖에 없다.


```java
public class UserDao {
	private ConnectionMaker connectionMaker;   // ConnectionMaker 는 interface 이다.

	public UserDao() {
		connectionMaker = new DConnectionMaker();          // 그러나 여전히 UserDao 가 어떤 회사의 커넥션 메이커를 쓰는지 알아야 한다.
	}
}
```

즉 UserDao 의 관심사항이 분리되지 않았다
-> 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 부분.

클라이언트 <--> 서비스
사용하는 오브젝트 <--> 사용되는 오브젝

지금 위에 상황은 결국 UserDao 가
DConnectionMaker 클래스에 의존관계를 맺고있는거나 마찬가지

물론 클래스간의 의존관계가 아니라, 오브젝트 사이에 다이내믹한 관계가 맺어지는것.
클래스 간의 의존관계는 코드상에 다른 클래스이름이 명시된다.

오브젝트 사이의 관계는 그렇지 않다.
코드에서 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면,
그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다.

어쨌든 생성자에서조차 어떤 구현체를 쓸 것인지 UserDao 코드에서 빼버릴 수가 있는데
Spring 에서는 xml 을 통한 Bean 설정도 가능하고,
 여러가지 어노테이션으로 DI 가 가능하다.

하여간 관심사 분리가 중요하다.

## Exception Handling 이 포함된 Jdbc 코드

UserDao 의 메서드 중 deleteAll 에 대해서

```java
public void deleteAll () throws SQLException {
	Connection c = null;
	PreparedStatement ps = null;

	try {
		c = dataSource.getConnection();
		ps = c.preparedStatement("delete * from users");
		ps.executeUpdate();                             // 예외가 발생할만한 코드를 다 try 로 묶음
	} catch (SQLException e) {
		throw e;
	} finally {
		if (ps != null) {
			try {
				ps.close();
			} catch (SQLException e) {
			}
		}
		if (c != null) {
			...
		}	
	}
}
```

## try/catch/finallly 가 추가된 jdbc 코드의 문제점

deleteAll 뿐만 아니라 다른 메서드 - getCount 등에도 
```java
catch (SQLException e) {
		throw e;
	} finally {
		if (ps != null) {
			try {
				ps.close();
			} catch (SQLException e) {
			}
		}
		if (c != null) {
			...
		}	
	}
```

이런 코드들이 중복이 된다.

이런 문제를 효과적으로 다루는 방법 
-> 늘 그렇듯 중복되는 코드,
그리고 로직에 따라 확장되고 자주 변하는 코드를 잘 분리하기.



## JdbcContext 의 분리



```java
public class JdbcContext {
	private DataSource
	
	public void setDataSource(DataSource dataSource) { // -> 이렇게 선언해야 Spring 에서 Bean 을 DI 해준다.
		this.dataSource = dataSource;
	}

	public void workWithStatementStrategy (StatementStrategy stmt) throws SQLException {
		Connection c = null;
		PreparedStatement ps = null;
		
		try {
			c = this.dataSource.getConnection();
			ps = stmt.makePreparedStatement(c);
			ps.executeUpdate();
		} catch (SQLException e) {
			throw e;
		} finally {
			...
		}
	}
}

public class UserDao {
	...
	private JdbcContext jdbcContext;
	
	public void setJdbcContext(JdbcContext jdbcContext) {
		this.jdbcContext = jdbcContext;
	}

	public void add(final User user) throws SQLException {
		this.jdbcContext.workWithStatementStrategy {
			new StatementStrategy() { ... }
		}
	}
}
```


UserDao  --> JdbcContext ---> DataSource
							^
							|
							|
						SimpleDriverDS
						\[ getConnection() ]
						
스프링의 빈 설정은 클래스 레벨이 아니라 런타임 시 만들어지는 오브젝트 레벨의
의존관계에 따라 정의된다.


	



# 토비의 스프링 7장


## SQL 과 DAO 의 분리

-> DB 테이블과 필드정보를 고스란히 담고있는 SQL 문장을 분리하고 싶다.

데이터를 가져오고 조작하는 작업의 인터페이스 역할을 하는 것이 DAO 다.

데이터 액세스 로직은 바뀌지 않더라도 DB 의 테이블, 필드 이름과 SQL 문장은 바뀔 수 있다.

SQL 변경 작업은 빈번하게 일어난다.

### XML 설정을 이용한 분리

sql 을 스프링의 xml 설정파일로 빼내는 것. 

#### 개별 SQL 프로퍼티 방식

sqlAdd 에 프로퍼티를 주입한다.

```java
public class UserDaoJdbc implements UserDao {  
    private String sqlAdd;  
  
    public void setSqlAdd(String sqlAdd) {  
       this.sqlAdd = sqlAdd;  
    }  
      
    public void add(User user) throws ClassNotFoundException, SQLException {  
       this.jdbcTemplate.update (  
          this.sqlAdd,  
          user.getId(), user.getName(), user.getPassword(),  
          user.getEmail(), user.getLevel().intValue()   
       )  
    }
```

```xml
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
	<property name="sqlAdd" value="insert into users (id, name, password) values (?, ?, ?)" / >
```


#### SQL 맵 프로퍼티 방식

```java
public class UserDaoJdbc implements UserDao {  
    private Map<String, String> sqlAdd;  
  
    public void setSqlMap(Map<String, String> sqlAdd) {  
       this.sqlAdd = sqlAdd;  
    }  
    
    public void add(User user) throws ClassNotFoundException, SQLException {  
       this.jdbcTemplate.update (  
          this.sqlMap.get("Add")  
          user.getId(), user.getName(), user.getPassword(),  
          user.getEmail(), user.getLevel().intValue()   
       )  
    }
```

```xml
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
	<property name="dataSource" ref="dataSource" / >
	<property name="sqlMap">
		<map>
			<entry key="add" value="insert into users(id, name, password)" / >
		< /map>
	< /property>
< /bean>
```





# Github Actions

프로젝트의 build, test, deployment 파이프라인을 자동화시킬 수 있는
CI (continuous integrity) / CD (continuous delivery) 플랫폼이다.

## Basic concepts

![[Screenshot 2025-12-20 at 6.27.48 PM.png|600]]
### Workflows 

한 개 이상의 _job_ 을 실행하는 수정가능한 자동화 프로세스
`github/workflows` 에 정의된다

### Events 

Workflows 를 발동시키는 행위 (activity)

PL을 생성하거나, issue 를 발생하거나 이런것들이 다 Event

### Jobs

같은 `runner` 에서 돌아가는 한 workflow 의 steps 의 집합. 
각각의 `step` 은 실행될 쉘 스크립트나, 실행될 `action` 을 의미함.


### Actions

`Action` 은 하나의 workflow 안에서 미리 정의된, 재사용 가능한 `job` 이나 code 를 의미함.
이걸로 workflow 설정 파일에서 코드의 중복을 줄일 수 있음.


### Runners

`workflow` 가 트리거될때 `workflow` 를 실행하는 서버를 말함.
각각의 `Runner` 는 하나의 `job` 만 실행할 수 있음.




### **주요 기능 3가지**

- **Services 컨테이너**: Postgres/Redis를 워크플로우에서 자동 실행 (docker-compose 대체)​
- **Secrets 관리**: Repository Settings > Secrets에서 TEST_POSTGRES_PASSWORD 등 추가​
- **CI 워크플로우**: .github/workflows/ci.yml에 빌드·테스트 스크립트 정의

## CI vs CD 차이

| 구분             | CI (Continuous Integration) | CD (Continuous Delivery/Deployment) |
| -------------- | --------------------------- | ----------------------------------- |
| 목적             | 코드 통합·빌드·테스트 자동화            | 배포 자동화 (서버 업로드)                     |
| 트리거            | PR/push 시                   | main 브랜치 머지 후                       |
| PulseTicket 적용 | `./gradlew test` 실행 ​       | Docker 이미지 빌드·배포 (미래)               |


## PR/Push 시 동작

PR 생성 또는 코드 푸시 → ci.yml 자동 실행 → 빌드 → Postgres/Redis 띄움 → 테스트 실행

```
- - name: Build and Test  
  run: ./gradlew build --info  
  env:  
    SPRING_PROFILES_ACTIVE: test
```

ci.yml 에 위에 처럼 설정해두어서 SpringBoot 의 테스트코드들을 실행하게 할 수 있다.



![[Screenshot 2025-12-20 at 7.14.52 PM.png|600]]
![[Screenshot 2025-12-20 at 7.15.09 PM.png|600]]

## 프로덕션 override 파일 처리 방법

#### 1. 현재 방식 유지 (추천)

(이미 `.gitignore`에 해당 파일이 포함된 상태를 유지하는 방식입니다.)

```
# .gitignore에 이미 있는 상태 유지
docker-compose.override.yml  # 로컬 개발용
```

프로덕션 서버에서의 설정 방식입니다.

```bash
# 서버에서 직접 생성
ssh user@prod-server

cat << EOF > docker-compose.override.yml
services:
  app:
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_PASSWORD=actual_prod_password
EOF

docker-compose up -d
```

---

#### 2. docker-compose.prod.yml 및 환경변수 분리

(민감 정보를 제외한 설정 파일은 Git에 관리하고, 실제 데이터는 서버 환경변수를 참조하게 합니다.)

```
.gitignore
├── docker-compose.override.yml  # 개발용
└── docker-compose.prod.yml      # 배포용 (git 커밋 OK)
```

**docker-compose.prod.yml (민감정보 제외)**

```
services:
  app:
    ports:
      - "80:8080"
    restart: always
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=${DB_HOST}
      - DB_PASSWORD=${DB_PASSWORD}  # 서버 환경변수 참조
```

**서버 배포 실행**

```bash
# 1. 환경변수 설정 (영구적)
echo "DB_PASSWORD=prod_secret" >> /etc/environment

# 2. 실행
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

---

#### 3. GitHub Actions 배포 자동화

(최종적으로 지향해야 할 자동화 단계입니다.)

```
# .github/workflows/deploy.yml
- name: Deploy to Production
  if: github.ref == 'refs/heads/main'
  run: |
    ssh user@prod-server << EOF
      docker-compose -f docker-compose.yml -f docker-compose.prod.yml pull
      docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
    EOF
  env:
    DB_PASSWORD: ${{ secrets.PROD_DB_PASSWORD }}
```

---

### 현재 CI 동작 확인법

1. PR 생성 (feature/abc 브랜치)
    
2. Actions 탭 → "CI" 워크플로우 실행 확인
    
3. `./gradlew build` 성공 → 멘토 리뷰 가능
    
