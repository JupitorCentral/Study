## 생성자가 하나일때 @Autowired 가 필요없다?


생성자가 여러개인 경우, 어떤 생성자를 의존성 주입용으로 사용할지를 알려주어야 한다.

만약

어떤 클래스의 의존성이 A,B,C 일때, 생성자가 B,C 에 대한 의존성을 설정한다고 해보자.

그럼 의존성 A 에 대해서 @Autowired 로 필드주입을 해주어야 하고

그렇게 안하면 의존성 주입 자체가 안된다.


## @RequiredArgument

lombok 에서 지원하는 어노테이션

클래스의 final 필드와 @NonNull 이 붙은 필드를 인자로 받는 생성자를 자동으로 만들어줌

즉, "객체를 만들 때 반드시 필요한(Required) Argument만을 받는 생성자"를 생성해서, 의존성 주입(Dependency Injection)에 매우 편리하게 사용할 수 있게 합니다.

```java
@RequiredArgsConstructor
@Service
public class MyService {
    private final DepA a;
    private final DepB b;
}

// 실제로는
public MyService(DepA a, DepB b) { ... }
```


## JPA - @PrePersist, and ETC

persist, update, delete 마다 다 Pre, Post 어노테이션이 있다.
Pre 는 실행 전, Post 는 실행 후.


메서드에 protected 를 쓰는게 중요한데
protected 를 쓰면 다른 패키지에서는 해당 메소드 호출이 불가능하기 때문이다
(보통 DTO, Service 는 다른 패키지에 있기 때문에)
(JPA 말고 서비스에서 실행해버리면 안되니까)





### Pre vs Post 차이

```
@PrePersist  ─→  DB INSERT  ─→  @PostPersist
    ↑                              ↑
  아직 DB에 없음               DB에 저장 완료! (ID도 생성됨)
  
@PreUpdate   ─→  DB UPDATE  ─→  @PostUpdate
    ↑                              ↑
  변경 전 검증                   변경 완료!
```

### 실제 사용 예시들

#### 1. **이벤트 발행 (가장 흔한 사용 사례)**

```java
@Entity
public class Reservation extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    private User user;
    
    @OneToOne
    private Seat seat;
    
    @Enumerated(EnumType.STRING)
    private ReservationStatus status;
    
    // DB 저장 후 이벤트 발행
    @PostPersist
    protected void onReservationCreated() {
        // 예약 생성 완료! 이메일 발송, 알림 전송 등
        ApplicationEventPublisher eventPublisher = 
            BeanUtil.getBean(ApplicationEventPublisher.class);
        
        eventPublisher.publishEvent(
            new ReservationCreatedEvent(this.id, this.user.getId(), this.seat.getId())
        );
        // → 다른 시스템에서 이메일 발송, SMS 발송, 로그 기록 등
    }
    
    // DB 업데이트 후 상태 변경 이벤트 발행
    @PostUpdate
    protected void onReservationUpdated() {
        if (this.status == ReservationStatus.CONFIRMED) {
            // 예약 확정 완료! 결제 시스템에 알림
            eventPublisher.publishEvent(
                new ReservationConfirmedEvent(this.id)
            );
        } else if (this.status == ReservationStatus.CANCELLED) {
            // 예약 취소 완료! 좌석 반환, 대기자에게 알림
            eventPublisher.publishEvent(
                new ReservationCancelledEvent(this.id, this.seat.getId())
            );
        }
    }
}
```

#### 2. **감사 로그(Audit Log) 기록**

```java
@Entity
public class User extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String userId;
    private String passwordHash;
    
    // 사용자 생성 후 로그 기록
    @PostPersist
    protected void logUserCreation() {
        AuditLogger auditLogger = BeanUtil.getBean(AuditLogger.class);
        auditLogger.log(
            "USER_CREATED",
            "New user created: " + this.userId + " (ID: " + this.id + ")",
            this.id
        );
        // DB에 감사 로그 테이블에 기록
    }
    
    // 사용자 정보 변경 후 로그 기록
    @PostUpdate
    protected void logUserUpdate() {
        AuditLogger auditLogger = BeanUtil.getBean(AuditLogger.class);
        auditLogger.log(
            "USER_UPDATED",
            "User modified: " + this.userId + " (ID: " + this.id + ")",
            this.id
        );
    }
    
    // 사용자 삭제 후 로그 기록
    @PostRemove
    protected void logUserDeletion() {
        AuditLogger auditLogger = BeanUtil.getBean(AuditLogger.class);
        auditLogger.log(
            "USER_DELETED",
            "User deleted: " + this.userId + " (ID: " + this.id + ")",
            this.id
        );
    }
}
```

#### 3. **캐시 무효화**

```java
@Entity
public class Event extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private Integer totalSeats;
    
    // 이벤트 수정 후 캐시 무효화
    @PostUpdate
    protected void invalidateCache() {
        CacheManager cacheManager = BeanUtil.getBean(CacheManager.class);
        
        // Redis 캐시에서 해당 이벤트 정보 삭제
        cacheManager.evict("events", this.id);
        cacheManager.evict("event-list", "all");
        
        // 프론트엔드에 실시간 업데이트 알림
        WebSocketNotifier notifier = BeanUtil.getBean(WebSocketNotifier.class);
        notifier.notifyEventUpdate(this.id);
    }
}
```

#### 4. **통계 집계**

```java
@Entity
public class Reservation extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    private Event event;
    
    // 예약 생성 후 통계 업데이트
    @PostPersist
    protected void updateStatistics() {
        StatisticsService statsService = BeanUtil.getBean(StatisticsService.class);
        
        // 이벤트별 예약 수 증가
        statsService.incrementReservationCount(this.event.getId());
        
        // 실시간 대시보드 업데이트
        statsService.updateEventDashboard(this.event.getId());
    }
    
    // 예약 취소 후 통계 업데이트
    @PostRemove
    protected void updateStatisticsOnDelete() {
        StatisticsService statsService = BeanUtil.getBean(StatisticsService.class);
        
        // 이벤트별 예약 수 감소
        statsService.decrementReservationCount(this.event.getId());
    }
}
```

#### 5. **연관 엔티티 자동 업데이트**

```java
@Entity
public class Seat extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    private Event event;
    
    @Enumerated(EnumType.STRING)
    private SeatStatus status;
    
    // 좌석 상태 변경 후 이벤트의 가용 좌석 수 업데이트
    @PostUpdate
    protected void updateEventAvailability() {
        if (this.status == SeatStatus.CONFIRMED) {
            EventService eventService = BeanUtil.getBean(EventService.class);
            
            // 가용 좌석 감소
            eventService.decreaseAvailableSeats(this.event.getId());
            
            // 좌석이 다 찼으면 이벤트 상태 변경
            if (eventService.isSoldOut(this.event.getId())) {
                eventService.markAsSoldOut(this.event.getId());
            }
        }
    }
}
```

#### 6. **ID 생성 후 처리 (중요!)**

```java
@Entity
public class Order extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // ← @PrePersist 시점에는 null!
    
    private String orderNumber;
    
    // ❌ @PrePersist에서는 ID가 아직 없음!
    @PrePersist
    protected void beforeSave() {
        // this.id는 null입니다!
        System.out.println("ID: " + this.id);  // null
    }
    
    // ✅ @PostPersist에서는 ID가 생성된 후!
    @PostPersist
    protected void afterSave() {
        // DB INSERT 완료 후 ID가 자동 생성됨
        System.out.println("ID: " + this.id);  // 1, 2, 3...
        
        // ID를 사용해서 주문번호 생성
        this.orderNumber = "ORD-" + String.format("%010d", this.id);
        
        // QR 코드 생성 (ID가 필요함)
        QRCodeService qrService = BeanUtil.getBean(QRCodeService.class);
        qrService.generateQRCode(this.id);
    }
}
```

### 언제 Pre를 쓰고 언제 Post를 쓸까?

| 상황            | 사용할 콜백                    | 이유                     |
| ------------- | ------------------------- | ---------------------- |
| 기본값 설정        | `@PrePersist`             | DB에 저장되기 전에 값이 있어야 함   |
| 데이터 검증        | `@PrePersist/Update`      | 잘못된 데이터가 DB에 들어가면 안 됨  |
| **이벤트 발행**    | **`@PostPersist/Update`** | **DB 저장 성공 후에만 알림**    |
| **로그 기록**     | **`@PostPersist/Update`** | **실제로 저장된 후 기록**       |
| **캐시 무효화**    | **`@PostUpdate`**         | **DB 변경 성공 후 캐시 갱신**   |
| **생성된 ID 사용** | **`@PostPersist`**        | **ID는 INSERT 후에야 생성됨** |

### 주의사항 ⚠️

```java
// ❌ 잘못된 사용
@PostPersist
protected void afterSave() {
    // 같은 트랜잭션 내에서 this를 다시 저장하면 무한 루프!
    repository.save(this);  // 위험!
}

// ✅ 올바른 사용
@PostPersist
protected void afterSave() {
    // 이벤트만 발행하고 실제 처리는 비동기로
    eventPublisher.publishEvent(new SomeEvent(this.id));
}
```

**PulseTicket 프로젝트에서 활용 예시:**

```java
@Entity
public class Reservation extends BaseEntity {
    
    @PostPersist
    protected void onReservationCreated() {
        // 예약 생성 완료 → 사용자에게 이메일 발송
        // "예약이 완료되었습니다. 5분 내 결제해주세요."
    }
    
    @PostUpdate
    protected void onReservationUpdated() {
        if (status == CONFIRMED) {
            // 예약 확정 → 티켓 발급, QR코드 생성
        } else if (status == CANCELLED) {
            // 예약 취소 → 좌석 반환, 대기자에게 알림
        }
    }
}
```

이렇게 **Post 콜백은 DB 작업이 성공한 후 추가 작업**을 할 때 주로 사용됩니다! 🎯



## JPA @GeneratedValue

IDENTITY, SEQUENCE, AUTO 가 있다.

이들의 차이점은 ? 

### IDENTITY

데이터베이스가 키 생성을 직접 담당.
auto-increment 기능을 사용한다.

그런데 키 값이 insert 수행 시점에만 생성되서 jpa 가 사전에 키 값을 알 수가 없음.
그래서 일괄저장 (batch insert) 최적화가 어려움.

-> 만약 일괄저장을 한다고하면, 저장할때마다 DB 에서 시퀀스 값을 호출해야 함.
이러니까 성능저하 일어남.


### SEQUENCE

DB 시퀀스를 사용해서 키 값을 미리 할당받음.
DB 시퀀스는 사전에 DB 에 시퀀스를 설정. 
엔티티를 insert 하기 전에 JPA 가 DB 로부터 시퀀스를 받아온다.

그러니까 JPA 가 사전에 시퀀스 값을 알 수가 있기때문에
batch insert 같은 최적화가 용이해짐.

100개 한꺼번에 저장한다고 하면 100개의 키를 미리 한번에 받아올 수 있음.

Oracle 이나 PostgreSQL 에서 주로 쓰는데, 시퀀스 객체를 네이티브로 지원하기 때문.
이 시퀀스 객체는 특정 테이블에 묶이지 않고 독립된 DB 객체로써 존재해서 고유번호를 생성하고 재사용이 가능함.

MySQL 은 이러한 네이티브 시퀀스 객체를 지원하지 않음. 그래서 SEQUENCE 전략을 직접 지원하지 않음.


### AUTO

JPA 구현체 (내 경우 Hibernates) 가 자동으로 설정

설정한 DB 종류에 따라 IDENTITY 또는 SEQUENCE 를 선택함

예를 들면 MsySQL -> Identity
Oracle, PostgreSQL -> Sequence

세부적인 키 생성방식 제어나 최적화에는 힘듦