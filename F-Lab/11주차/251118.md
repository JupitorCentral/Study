
## @RestController 를 쓰면 ResponseEntity 를 안써도 되는 이유


### @RestController vs @Controller

@ResponseBody 의 유무 이다.

### @ResponseBody ? 

만약 @Controller 에 @ResponseBody 를 안쓰고 엔드포인트에서 리턴해버리면
Spring 에서는 해당 객체의 toString 을 viewName 으로 인식해서
view 에 해당하는 이름을 찾는다.

왜냐하면 @Controller 는 Spring MVC 의 어노테이션이기 때문이다.

Spring MVC 는 Spring Framework 의 Web Module 이다.

그래서 이런 경우 보통 String 을 쓰고, 객체를 쓰면 거의 안되는게 객체.toString() 에 해당하는 view 를 찾게된다. (못찾으면 에러 발생)

그래서 @ResponseBody 가 의미하는 바는,
해당 엔드포인트의 리턴값을 HTTP Body 에 쓰라는 얘기이다.
View 를 통한 렌더링을 우회하고, HTTP Reponse 의 Body 에 직접 작성하라는 얘기.
객체가 직렬화 (serialized 되어 HTTP Body 에 기록된다)

더 자세히 들어가면 @ResponeEntity 를 쓰면 
`ViewResolver` 대신에 `HttpMessageConverter` 가 쓰여서
`HttpMessageConverter` 가 리턴 객체를 적절한 형식 (Json, XML) 등으로 변환하고
그걸 HTTP Body 에 쓰는 것.



## @Transactional & JpaRepository

어떠한 메서드 안에서 JpaRepository 의 메서드가 실행되면
각 Repository 마다 트랜잭션이 생성되는데
속한 그 메서드에 @Transactional 을 선언하게 되면

안에 있는 모든 sql 관련 작업에 대해 하나의 Transaction 만 생성되어 Hibernate, JDBC , DB 에 대한 최적화가 이루어진다.

그리고 특히 realOnly = true 는
- **Hibernate 최적화**: 스냅샷 생성 안 함, dirty checking 안 함​
- **JDBC 최적화**: 일부 JDBC 드라이버가 읽기 전용 힌트 활용​
- **데이터베이스 최적화**: 일부 DBMS가 읽기 전용 트랜잭션을 다르게 처리

**아무것도 안 쓰면**: 트랜잭션 없이 실행, 최적화 없음, 지연 로딩 문제 가능
**`@Transactional(readOnly = true)`**: 트랜잭션 존재, Hibernate 최적화, 메모리 절약, 안전한 지연 로딩



## JPA - @PrePersist


`@PrePersist`는 JPA (Java Persistence API) 어노테이션으로, 
엔티티가 데이터베이스에 영속화 (persist) 되기 직전에 실행되는 콜백 메서드를 지정하는 데 사용된다.

- 영속화 ? 
엔티티 객체가 JPA 관리 하에 들어가 DB 제 저장될 준비가 된 상태.
INSERT 되기 직전 시점.

그래서 이 어노테이션은 주로 엔티티의 상태를 특정 조건에 맞게 조정하거나, 생성일자, 수정일자, 상태값 등 
자동으로 채워야 하는 필드를 미리 세팅할 때 활용된다.

`@PrePersist`를 사용하는 이유는 엔티티가 데이터베이스에 저장되기 전에 어떤 작업을 반드시 수행해야 할 필요가 있기 때문입니다. 
예를 들어, 새로 생성하는 엔티티에 생성일 (`createdAt`)이나 생성자 (`createdBy`) 같은 필드 값을 자동으로 넣거나, 
엔티티의 상태값을 초기값으로 세팅하는데 유용합니다.

- 언제사용하는가 ? 
	- 엔티티가 처음 만들어져 저장되기 전
	- 생성 시점에 특정 필드 값을 자동 세팅하려는 경우
	- 엔티티의 무결성과 일관성을 유지하고자 할 때
	- 별도로 애플리케이션에서 수동으로 처리하지 않고 자동화하고 싶을 때


```java
package personnel.jupitorsendsme.pulseticket.entity;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;

import java.time.LocalDateTime;

/**
 * 공통 필드와 콜백 메서드를 제공하는 기본 엔티티
 */
@MappedSuperclass
public abstract class BaseEntity {

    /**
     * 생성 일시
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /**
     * 수정 일시
     */
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    /**
     * 엔티티 저장 전 실행되는 콜백 메서드
     * createdAt이 null인 경우 현재 시간으로 설정
     */
    @PrePersist
    public void prePersist() {
        LocalDateTime now = LocalDateTime.now();
        this.createdAt = this.createdAt == null ? now : this.createdAt;
        this.updatedAt = this.updatedAt == null ? now : this.updatedAt;
    }

    /**
     * 엔티티 업데이트 전 실행되는 콜백 메서드
     * updatedAt을 현재 시간으로 갱신
     */
    @PreUpdate
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
}
```


이런식으로 쓸 수 있는데, 
여기서

@MappedSuperclass 은 테이블과 매칭되지 않는 클래스로
해당 정보를 상속받은 엔티티에서 넘겨받는다.


이때, @prePersist 는 새로운 레코드가 저장될때만 딱 한번 실행되고
@preUpdate 는 이미 존재하는 (영속화된) 레코드가 업데이트 될때마다 실행된다.





## Docker Container 에 있는 Spring Application 의 Log 보는 툴

Grafana + Loki + Promtail 스택에서 각각의 역할은 다음과 같습니다:[](http://blog.omoknooni.me/135)​

### Promtail (로그 수집 에이전트)

서버나 Docker 컨테이너에서 생성되는 로그 파일을 실시간으로 모니터링하고 수집하는 에이전트입니다. 로그 파일의 끝부분을 계속 감시하는 'Tailing' 방식으로 동작하며, 수집한 로그에 메타데이터(파일명, 호스트 정보 등)를 라벨로 추가한 뒤 Loki로 **Push 방식**으로 전송합니다. positions.yaml 파일에 마지막으로 읽은 offset을 저장해서 재시작 시에도 중복 없이 이어서 수집할 수 있습니다.[](https://jminc00.tistory.com/91)​

### Loki (로그 저장 및 쿼리 서버)

Promtail에서 전송받은 로그를 저장하고 쿼리를 처리하는 메인 서버입니다. Elasticsearch와 달리 로그 전체를 인덱싱하지 않고 **메타데이터(라벨)만 인덱싱**해서 저장 공간과 리소스를 크게 절약합니다. Grafana에서 LogQL 쿼리 요청이 오면 저장된 로그를 검색해 결과를 반환합니다.[](https://maily.so/newslettertodevops/posts/vpzl9mxdzk9)​

### Grafana (시각화 및 대시보드)

Loki를 데이터소스로 연결해 로그를 쿼리하고 시각화하는 플랫폼입니다. LogQL로 로그를 검색하고, 대시보드를 구성하며, 로그 패턴 기반 알림 시스템도 설정할 수 있습니다. Prometheus도 함께 데이터소스로 등록하면 메트릭과 로그를 하나의 대시보드에서 통합 모니터링할 수 있습니다.[](https://creampuffy.tistory.com/213)​

