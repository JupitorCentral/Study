## @Transactional readOnly

### db 에 write 하는 메서드에 readOnly = true 를 사용해도 되는지 ?

읽기 전용 트랜잭션(readOnly=true)은 조회 쿼리에서 영속성 컨텍스트의 dirty checking, snapshot 저장 기능을 비활성화하여 효율을 높이기 때문에 update, insert, delete 등 쓰기 작업에는 절대로 사용하면 안 된다.​

- write 작업에 readOnly=true가 있으면 영속성 컨텍스트에서 데이터 변경 감지(dirty checking)가 비활성화되므로 JPA가 엔티티 상태 변화를 인지하지 못해서 업데이트/삭제가 반영되지 않을 수도 있다.
    
- 실제로 Hibernate에서는 update/insert/delete 쿼리가 아예 실행되지 않거나 예외를 발생시킬 수 있다.​
    

### true와 false의 차이점

| 옵션             | 기능 설명                                   | 사용처      | 결과                                |
| -------------- | --------------------------------------- | -------- | --------------------------------- |
| readOnly=true  | dirty checking off, snapshot 비저장, 성능 최적 | 조회 전용    | write 무시, update/insert/delete 불가 |
| readOnly=false | dirty checking on, snapshot 저장          | 변경 작업 포함 | 모든 JPA 행위 정상, 트랜잭션 commit에 flush  |

SnapShot ?

```java
@Transactional(readOnly = true)
public void updateUser(User user) {
    user.setName("changedName");
    // 변경해도 DB에 반영 안 됨!
}

@Transactional
public void updateUser(User user) {
    user.setName("changedName");
    // 정상적으로 update 됨!
}
```

### dirty checking ? snapshot ?

Hibernate 는 엔티티가 session에 load 될때 기존 상태의 snapshot, 즉 상태를 기억해둠.
이 스냅샷은  session 이 flushed 될때, 동기화가 필요한 변경사항을 탐지하기 위한 dirty cheking 에 쓰인다.

readonly = true 로 하면 이 snapshot 을 저장하지 않아 최적화가 되지만, snapshot 을 저장하지 않고 dirtychecking 을 안하기 때문에
변경사항을 탐지하지 못해 DB 에 저장이 안된다.



## 토비의 스프링 1권 2장

### 테스트와 테스트 클래스, 어플리케이션 콘텍스트

테스트 클래스의 메서드마다 테스트 클래스의 인스턴스가 생성됨

테스트 클래스에 적용되는 설정이 같으면,  그 클래스들끼리 공유하는 어플리케이션 컨텍스트가 생성됨.
그리고 그 어플리케이션 컨텍스트는 전체 프로젝트의 모든 bean 이 생성이 된다.

여기서 동일한 설정이라 함은

1. **@ContextConfiguration 애노테이션**:  
    테스트 클래스에 이 애노테이션이 있으면, 여기서 지정한 설정(예: XML 설정 파일이나 @Configuration 클래스)이 동일하면 같은 ApplicationContext를 공유합니다.
    
2. **@SpringBootTest 애노테이션**:  
    Spring Boot 환경이라면, 이 애노테이션이 붙은 테스트 클래스들은 기본적으로 같은 Spring Boot 어플리케이션 컨텍스트(즉, 같은 설정)를 공유합니다.
    
3. **프로파일, 환경설정, Bean 정의가 동일할 때**:  
    예를 들어, 테스트 클래스가 사용하는 프로파일(profile), 활성화된 환경변수, Bean 등록 방식 등도 동일하면 같은 설정으로 봅니다.

```java
// 1. @ContextConfiguration 사용 예시

// 같은 설정: 같은 설정 클래스를 지정 -> ApplicationContext 공유
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {AppConfig.class})
public class MyServiceTest {
    // 테스트 코드
}

@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {AppConfig.class}) 
public class AnotherServiceTest {
    // 테스트 코드
}

// 다른 설정: 다른 설정 클래스를 지정 -> 서로 다른 ApplicationContext 생성
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {DifferentConfig.class})
public class DifferentServiceTest {
    // 테스트 코드
}

```

```java
// 2. @SpringBootTest 사용 예시

// 같은 설정: 기본 설정으로 동일하게 전체 컨텍스트 로드 -> ApplicationContext 공유
@SpringBootTest
public class UserServiceIntegrationTest {
    // 테스트 코드
}

@SpringBootTest
public class OrderServiceIntegrationTest {
    // 테스트 코드
}

// 다른 설정: 특정 프로파일 또는 다른 properties 지정하여 설정 변경 -> 다른 ApplicationContext 생성
@SpringBootTest(properties = "app.featureX.enabled=true")
public class FeatureXEnabledTest {
    // 테스트 코드
}

@SpringBootTest(properties = "app.featureX.enabled=false")
public class FeatureXDisabledTest {
    // 테스트 코드
}
```

```java
// 3. 프로파일 지정 예시

// 같은 설정: 같은 프로파일 활성화 -> ApplicationContext 공유
@ActiveProfiles("test")
@SpringBootTest
public class UserServiceProfileTest {
    // 테스트 코드
}

@ActiveProfiles("test")
@SpringBootTest
public class OrderServiceProfileTest {
    // 테스트 코드
}

// 다른 설정: 다른 프로파일 활성화 -> 서로 다른 ApplicationContext 생성
@ActiveProfiles("dev")
@SpringBootTest
public class UserServiceDevProfileTest {
    // 테스트 코드
}
```


그리고 책에서는 @Before 어노테이션 갯수마다 어플리케이션이 생성된다고 하는데
이는 잘못됬다고 한다.

