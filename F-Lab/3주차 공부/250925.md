## Map 2

Map.entrySet -> Set.stream -> F-bounded Polymorphism or Recursive Generics
-> Function Class -> @FunctionalInterface -> Reflection


```java
public int[] topKFrequent(int[] nums, int k) {  
  
    int[] answer = new int[k];  
  
    Map<Integer, Integer> map = new HashMap<>();  
    for (int i=0; i<nums.length; i++) {  
        int x = nums[i];  
        map.merge(x, 1, Integer::sum);  
    }  
  
    List<Integer> sorted = map.entrySet()
				    .stream()
					.sorted(Map.Entry.<Integer, Integer>comparingByValue()
					.reversed())  
				    .map(Map.Entry::getKey)  
				    .collect(Collectors.toList());  
  
    for (int i=0; i<k; i++) {  
        answer[i] = sorted.get(i);  
    }  
    return answer;  
}
```


### Stream 의 선언부

```java
public interface Stream<T> extends BaseStream<T, Stream<T>>
```

#### F-bounded Polymorphsim or Recursive Generics
(F-제한 다형성 또는 재귀 제너릭)


Self Type Pattern 을 구현하기 위함

```java
public interface BaseStream<T, S extends BaseStream<T, S>>  
        extends AutoCloseable {
```

BaseStream 도 이런식으로 사용되는데, `S extends BaseStream<T, S>` 는 F-bounded Polymorphsim 이다.

Fluent API 에서 메소드 체이닝시 정확한 타입반환을 보장하기 위함.

만약 BaseStream 이 단순히 BaseStream\<T> 를 반환했다면

```java
employees.stream()
         .map(Employee::getSalary)
         .parallel()  // 여기서 BaseStream<T> 반환
         .reduce(0L, (acc, next) -> acc + next);  // 컴파일 에러!
```

이건 또 뭔소리냐.

일단 stream().map 을 알아야 할 것이다.

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
```

또 이 난리이다.

일단 \<R> 은 메소드 레벨의 제너릭 타입 선언이다.

```java
<T> void myGenericFunction (T object) {  }
```



#### Function Class ?

```java
@FunctionalInterface  
public interface Function<T, R> { ... }
```


#### @FunctionalInterface ?


```java
@Documented        // javadoc에 표시
@Retention(RUNTIME) // 런타임까지 어노테이션 정보 유지  
@Target(TYPE)      // 타입(클래스/인터페이스)에만 사용 가능
public @interface FunctionalInterface {}
```

Retension이 Runtime 이므로, 해당 타입의 어노테이션의 정보가 runtime 동안 유지된다.
그렇게 되면, 프레임워크/라이브러리가 해당 타입에 대해 처리할때 (프레임워크/라이브러리가 `리플렉션`으로 어노테이션을 읽음)
딸려있는 어노테이션의 정보에 따라 동작을 다르게 한다.
(Annotation 자체에도 값을 설정할 수 있다.)

리플렉션 ? 이거 많이 들어봤는데


#### Class class example 중에서

```java
public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE; }

Size.SMALL.getClass() == Size.class // true

-------------------

public enum Size
{
   SMALL,
   MEDIUM,
   LARGE,
   EXTRA_LARGE
   {
      public String toString() { return "XL"; }
   };
}

Size.EXTRA_LARGE.getClass() == Size.class // false
```

2번째 예시는 뭘 의미하는거지 ? 이 코드가 왜 튀어나왔는가 ?




#### Enumeration Class

모든 enum type 은 abstract class `Enum` 의 서브클래스들이다. 
그래서 Enum 에 정의된 메소드들을 사용가능.

그래서 만약에
```java
public enum Size {  
    SMALL ("S"),  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE  
}

public enum Size {  
    SMALL ("S"),  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE;  
  
    private final String sizeName;  
  
    Size(String sizeString) {  
        this.sizeName = sizeString;  
    }  
    Size() {  
        this.sizeName = "None";  
    }  
}
```

이렇게 쓰면 SMALL ("S") 때문에 컴파일이 불가능한데,
SMALL ("S") 라는 것은 기본 컨스트럭터를 사용하지 않고
파라미터가 있는 컨스트럭터를 사용하겠다는 의미이기 때문이다.

여기에는 parameter 가 있는 constructor 가 정의되어 있지 않기때문에 에러 발생.

그래서 아래 것이 허용되고, 이때 parameter 가 없는 constructor 를 지우면 MEDIUM, LARGE, EXTRA_LARGE 에 컴파일 오류가 뜬다.

그래서
```java
public enum Size  
{  
    SMALL,  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE  
	{  
		public String toString() { return "XL"; }  
	};  
}
```

이것에 대한 의미는, 뭐지? ㅋㅋ

이전 예시의 EXTRA_LARGE 는 Size 의 subclass 의 객체라고 하던데...






## 클래스가 ThreadSafe 하다는게 무슨 의미인가 ?


#### StringBuilder, StringBuffer




## 캐싱 스탬피드란 ?




## 캐시 expired 에 대한 고민



