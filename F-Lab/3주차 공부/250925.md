## Map 2

Map.entrySet -> Set.stream -> F-bounded Polymorphism or Recursive Generics
-> Function Class -> @FunctionalInterface -> Reflection


```java
public int[] topKFrequent(int[] nums, int k) {  
  
    int[] answer = new int[k];  
  
    Map<Integer, Integer> map = new HashMap<>();  
    for (int i=0; i<nums.length; i++) {  
        int x = nums[i];  
        map.merge(x, 1, Integer::sum);  
    }  
  
    List<Integer> sorted = map.entrySet()
				    .stream()
					.sorted(Map.Entry.<Integer, Integer>comparingByValue()
					.reversed())  
				    .map(Map.Entry::getKey)  
				    .collect(Collectors.toList());  
  
    for (int i=0; i<k; i++) {  
        answer[i] = sorted.get(i);  
    }  
    return answer;  
}
```


### Stream 의 선언부

```java
public interface Stream<T> extends BaseStream<T, Stream<T>>
```

#### F-bounded Polymorphsim or Recursive Generics
(F-제한 다형성 또는 재귀 제너릭)


Self Type Pattern 을 구현하기 위함

```java
public interface BaseStream<T, S extends BaseStream<T, S>>  
        extends AutoCloseable {
```

BaseStream 도 이런식으로 사용되는데, `S extends BaseStream<T, S>` 는 F-bounded Polymorphsim 이다.

Fluent API 에서 메소드 체이닝시 정확한 타입반환을 보장하기 위함.

만약 BaseStream 이 단순히 BaseStream\<T> 를 반환했다면

```java
employees.stream()
         .map(Employee::getSalary)
         .parallel()  // 여기서 BaseStream<T> 반환
         .reduce(0L, (acc, next) -> acc + next);  // 컴파일 에러!
```

이건 또 뭔소리냐.

일단 stream().map 을 알아야 할 것이다.

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
```

또 이 난리이다.

일단 \<R> 은 메소드 레벨의 제너릭 타입 선언이다.

```java
<T> void myGenericFunction (T object) {  }
```



#### Function Class ?

```java
@FunctionalInterface  
public interface Function<T, R> { ... }
```


#### @FunctionalInterface ?


```java
@Documented        // javadoc에 표시
@Retention(RUNTIME) // 런타임까지 어노테이션 정보 유지  
@Target(TYPE)      // 타입(클래스/인터페이스)에만 사용 가능
public @interface FunctionalInterface {}
```

Retension이 Runtime 이므로, 해당 타입의 어노테이션의 정보가 runtime 동안 유지된다.
그렇게 되면, 프레임워크/라이브러리가 해당 타입에 대해 처리할때 (프레임워크/라이브러리가 `리플렉션`으로 어노테이션을 읽음)
딸려있는 어노테이션의 정보에 따라 동작을 다르게 한다.
(Annotation 자체에도 값을 설정할 수 있다.)

리플렉션 ? 이거 많이 들어봤는데


#### Class class example 중에서

```java
public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE; }

Size.SMALL.getClass() == Size.class // true

-------------------

public enum Size
{
   SMALL,
   MEDIUM,
   LARGE,
   EXTRA_LARGE
   {
      public String toString() { return "XL"; }
   };
}

Size.EXTRA_LARGE.getClass() == Size.class // false
```

2번째 예시는 뭘 의미하는거지 ? 이 코드가 왜 튀어나왔는가 ?




#### Enumeration Class

모든 enum type 은 abstract class `Enum` 의 서브클래스들이다. 
그래서 Enum 에 정의된 메소드들을 사용가능.

그래서 만약에
```java
public enum Size {  
    SMALL ("S"),  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE  
}

public enum Size {  
    SMALL ("S"),  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE;  
  
    private final String sizeName;  
  
    Size(String sizeString) {  
        this.sizeName = sizeString;  
    }  
    Size() {  
        this.sizeName = "None";  
    }  
}
```

이렇게 쓰면 SMALL ("S") 때문에 컴파일이 불가능한데,
SMALL ("S") 라는 것은 기본 컨스트럭터를 사용하지 않고
파라미터가 있는 컨스트럭터를 사용하겠다는 의미이기 때문이다.

여기에는 parameter 가 있는 constructor 가 정의되어 있지 않기때문에 에러 발생.

그래서 아래 것이 허용되고, 이때 parameter 가 없는 constructor 를 지우면 MEDIUM, LARGE, EXTRA_LARGE 에 컴파일 오류가 뜬다.

그래서
```java
public enum Size  
{  
    SMALL,  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE  
	{  
		public String toString() { return "XL"; }  
	};  
}
```

이것에 대한 의미는, 뭐지? ㅋㅋ

이전 예시의 EXTRA_LARGE 는 Size 의 subclass 의 객체라고 하던데...






## 클래스가 ThreadSafe 하다는게 무슨 의미인가 ?

- 구글에 검색해보면...
여러개의 쓰레드들이 구동되는 프로그램들 중에서, 
쓰레드들 사이에서 원하지 않는 동작이 발생하지 않는 것.

thread-safty 한 클래스와 그렇지 않은 클래스를 구분하는 가장 큰 특성
-> correctness. 
#### Correctness 란 무엇인가 ?

클래스가 그에 대한 요구사항 (specification) 을 잘 따르는 것을 말함.
(specification of class - 클래스가 가지고 있는 변수, 클래스가 하는 일. 즉 클래스 자체가 무엇을 위해 존재하고
어떤 동작을 하는지에 대한 정보로 생각할 수 있을듯 하다.)

객체의 상태를 저장하는 변수를 정의하고, 어떤 동작 (method) 에 의해 변하는 상태를 잘 묘사할 수 있는 
specification 이 좋은 specification .

우리가 적절한 클래스의 specification 을 잘 명세, 파악하지 않는데
어떻게 클래스의 correctness 를 논할 수 있을것인지 ?

즉, Thread safe 한 클래스는, 이렇게 정의할 수 있다.
여러개의 쓰레드에 의해 접근이 되어도, 객체의 correctness 를 잘 유지하며 동작하는 객체의 클래스.


##### ThreadSafe 한 클래스의 예시 - A Stateless servlet
-> 상태가 없는 클래스는, Thread-safe 하다.

stateless 한 클래스이다 -> 그 클래스에는 내부에 field가 없고,
다른 클래스의 field 를 reference 하는게 없음을 의미.

즉 서로 다른 쓰레드가 하나의 servlet 에 접근하여 동작할때,
하나의 쓰레드가 동작하는 결과가 다른 어떤 클래스의 상태에도 관여하지 않는다.
왜냐하면 해당 servlet 은 stateless 하기 때문.

	즉 stateless 한 객체는 항상 Thread-Safe gkek.


#### Atomicity

만약 클래스의 field 가 하나라도 생기면 어떻게 될까?

```java
++count;
```
이 단순한 코드 하나는 짧기떄문에 thread-safe 할 것 같지만,
사실 위 코드는 3가지의 동작으로 나누어져 있다.

1. 해당 변수(상태)에 현재 값을 가져온다
2. 가져온 값에 1을 더한다
3. 그리고 해당 변수에 구한 값을 더한다.

즉 여러가지 쓰레드가 해당 동작을 실행하게 될때,
한 쓰레드가 값을 읽어서 원래 변수에 값을 적용하기 전에
다른 쓰레드가 그 사이에 값을 읽어서 그 쓰레드의 임시 공간에서 가져온 값에 1을 더하게 되고,
이러면 count 에 2가 더해져야 하는 상황에 1만 더해지는 상황이 일어날 수 있게 되는것

(register = a , -> register += 1 -> a = register)

#### Race condition

여러 쓰레드가 동일한 상태에 접근하는 경우 
접근 순서에 따라 값이 바뀌는 상황

(위 상황이 race condition 이다)

race condition 에서는 무조건 값이 잘못되게 나오는 것이 아니지만, 
예상하는 동작이 나올지는 unreliable 하다.


#### compound Actions
-> 여러 동작들의 조합


race condition 을 해결하기 위해선, 우리가 어떤 상태를 변경하고 있는 도중에
다른 Thread 가 그 값을 사용하는 것을 막아서  ,다른 쓰레드가 
오직 우리가 수정하기 전이나 - 수정한 후에 상태를 보게끔을 확실하게 할 방법이 필요하다.
-> Memory visibility. 
한 쓰레드가 변경한 값을 다른 쓰레드가 볼 수 있는 특성.

만약 A와 B가 "with respect to each other" atomic하다면:
- Thread 1은 B operation을 **완전히 끝나거나 아예 시작하지 않은** 상태로만 본다
- Thread 2는 A operation을 **완전히 끝나거나 아예 시작하지 않은** 상태로만 본다

즉 중간상태가 서로에게 노출되지 않는다.
서로의 실행과정에 간섭하지 않는다.

all or nothing.

```java
Thread 1: temp1 = count (0)    // 읽기
Thread 2: temp2 = count (0)    // 같은 값을 읽음!
Thread 1: temp1 = temp1 + 1 (1)
Thread 2: temp2 = temp2 + 1 (1)
Thread 1: count = temp1 (1)    // 쓰기
Thread 2: count = temp2 (1)    // 덮어씀!
```

즉 위 상황은 thread 2 가 thread 1 가 수정하고 있는 중간상태를 바라보게 되는 것이다.

그래서 thread 2 의 관점에서 thread 1 이 완전히 실행하고 있지 않는다고 간주할경우
thread 2 가 실행이 되고, thread 1 이 그 다음에 실행될때, thread 2 가 시작했으므로
무조건 다 완료가 되었다는 가정하에 해당 동작을 해야 한다는 것이다.


```java
// 가능한 실행 순서 1:
Thread 1: count++ 완전히 실행 (0→1)
Thread 2: count++ 완전히 실행 (1→2)

// 가능한 실행 순서 2:
Thread 2: count++ 완전히 실행 (0→1)  
Thread 1: count++ 완전히 실행 (1→2)

```



#### Java 에서의 예시


##### StringBuilder, StringBuffer







## 캐싱 스탬피드란 ?




## 캐시 expired 에 대한 고민



