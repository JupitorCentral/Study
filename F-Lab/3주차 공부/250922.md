## Map 


From neetcode top-k-elements solution
[[250922 needcode top-k-elements]]

```java
public int[] topKFrequent(int[] nums, int k) {  
  
    int[] answer = new int[k];  
  
    Map<Integer, Integer> map = new HashMap<>();  
    for (int i=0; i<nums.length; i++) {  
        int x = nums[i];  
        map.merge(x, 1, Integer::sum);  
    }  
  
    List<Integer> sorted = map.entrySet().stream().sorted(Map.Entry.<Integer, Integer>comparingByValue().reversed())  
    .map(Map.Entry::getKey)  
    .collect(Collectors.toList());  
  
    for (int i=0; i<k; i++) {  
        answer[i] = sorted.get(i);  
    }  
    return answer;  
}
```

map.entrySet ? 
stream ?
sorted ?
Map.Entry\<Integer, Integer>comparingByValue ? 

### Map.entrySet

```java
public static void main(String[] args) throws Exception {  
  
    Map<Integer, Integer> map = new HashMap<>();  
  
    map.put(3, 4);  
    map.put(5, 3);  
  
    for (Map.Entry<Integer, Integer> entry : map.entrySet() ) {  
        entry.setValue(15);  
    }  
  
    for (Map.Entry<Integer, Integer> entry : map.entrySet() ) {  
        printf("key : " + entry.getKey() + ", value : " + entry.getValue() + "\n");  
    }   
}
-------
key : 3, value : 15
key : 5, value : 15

```

javaDoc 을 보면 entrySet 은 Map.Entry 형식으로 key-value pair 를 반환하는데,
이 Entry 들은 원래 Map 을 투영하며, 연결을 유지한다고 함. (These instances maintain a connection to the original, backing map.)
for 문 안에서 entry 는 entry-set view 의 반복 동안에만 그 연결을 유지함.

연결이 유지되면, 어떤 Entrry 의 값을 수정하면 원본 Map 에 영향이 간다는 이야기.
그러니까 쉽게말하자면 map 의 iteration 안의 entry 를 수정하면 map 의 해당 키-value 값에 영향이 간다는 뜻.

해당 Map 의 iteration 외부에서의 Entry 에 대한 접근은 undefined, 예측할 수 없다.
-> 내 생각에는 외부에 Entry reference 를 만들고 iteration  내부에서 해당 reference 에 특정 entry 를 집어넣을 경우를 말하는 듯 하다.


### Set.stream

`map.entrySet()` 의 return type 은 Set\<Map.Entry\<K, V>> 이다.
즉 `Set` 을 반환한다. 
그러니까 `map.entrySet()` 은 `Set` 이고, `Set` 은 `Collection` 의 자식 클래스이므로 stream 을 호출 할 수 있다.
stream funtion 은 return type 이 Stream\<E> 이다.

### Stream ?

```java
public interface Stream<T> extends BaseStream<T, Stream<T>>
```

선언이 신기하다. 자기 자신이 들어가네 ?

#### F-bounded Polymorphsim or Recursive Generics
(F-제한 다형성 또는 재귀 제너릭)

-> 250925 

#### Function Class ?

```java
@FunctionalInterface  
public interface Function<T, R> { ... }
```



#### @FunctionalInterface ?


```java
@Documented        // javadoc에 표시
@Retention(RUNTIME) // 런타임까지 어노테이션 정보 유지  
@Target(TYPE)      // 타입(클래스/인터페이스)에만 사용 가능
public @interface FunctionalInterface {}
```

Retension이 Runtime 이므로, 해당 타입의 어노테이션의 정보가 runtime 동안 유지된다.
그렇게 되면, 프레임워크/라이브러리가 해당 타입에 대해 처리할때 (프레임워크/라이브러리가 리플렉션으로 어노테이션을 읽음)
딸려있는 어노테이션의 정보에 따라 동작을 다르게 한다.
(Annotation 자체에도 값을 설정할 수 있다.)

리플렉션 ? 이거 많이 들어봤는데


#### @Documented ?

```java
(1)
If the annotation @Documented is present on the declaration of an annotation interface A, 
then any @A annotation on an element is considered part of the element's public contract. 

(2)
In more detail, when an annotation interface A is annotated with Documented, 
the presence and value of A annotations are a part of the public contract of the elements A annotates. 

(3)
Conversely, if an annotation interface B is not annotated with Documented, 
the presence and value of B annotations are not part of the public contract of the elements B annotates. 

(4)
Concretely, if an annotation interface is annotated with Documented, 
by default a tool like javadoc will display annotations of that interface in its output 
while annotations of annotation interfaces without Documented will not be displayed
```

- [ ] Concretely #EnglishWord ➕ 2025-09-22 
      in a definitive or conclusive way.
      구체적으로, 명확하게
      She explained her ideas concretely with examples.
		(그녀는 예시를 들어 구체적으로 설명했다).

- [ ] conclusive #EnglishWord  ➕ 2025-09-22 
      "결정적인 (decisive)", "최종적인", **"설득력 있는"*

- [ ] Decisive vs conclusive #EnglishWord ➕ 2025-09-22 
      Decisive -> 의사능력에 초점. 빠르고 효과적으로 결정을 내리는 능력, 행동력과 리더쉽
      conclusive : (conclusion : 결론) -> 결론을 확립하기에 충분한 증거


A 가 그냥 어노테이션을 뜻하고, @A -> 실제로 사용된 어노테이션을 말함.
```java
// 1. 어노테이션 인터페이스 A 정의 (설계도)
@interface MyAnnotation {
    String value();
}

// 2. @A 사용 (실제 적용)
@MyAnnotation("test")  // 이게 @A
public class MyClass { }
```

```java
If the annotation @Documented is present on the declaration of an annotation interface A, 
then any @A annotation on an element is considered part of the element's public contract. 
```
(1) -> 어노테이션 인터페이스 -> 어노테이션 정의하는 것을 얘기함.


```java
(1)
If the annotation @Documented is present on the declaration of an annotation interface A, 
then any @A annotation on an element is considered part of the element's public contract. 

(2)
In more detail, when an annotation interface A is annotated with Documented, 
the presence and value of A annotations are a part of the public contract of the elements A annotates. 

(3)
Conversely, if an annotation interface B is not annotated with Documented, 
the presence and value of B annotations are not part of the public contract of the elements B annotates. 

(4)
Concretely, if an annotation interface is annotated with Documented, 
by default a tool like javadoc will display annotations of that interface in its output 
while annotations of annotation interfaces without Documented will not be displayed
```

(1) 만약 @Documentation 이 어떤 Annotation interface 의 정의에 붙어있으면 (Annotation interface -> 어노테이션 정의부분),
어떤 요소에 어노테이션을 적용한 것은 (@A - Annotation 의 사용) 요소의 public contract 의 부분으로 간주된다.

> Public Contract -> 외부에서 의존할 수 있는 공식 API 부분이라는 뜻.
> -> 다른 개발자가 이 메서드/클래스를 사용할때 반드시 알아야 하는 정보

(2) 더 말하자면, 어떤 어노테이션이 @Documented 와 같이 정의되면
어노테이션 A 의 존재나 값이 A 가 주석을 하는 요소의 public contract 의 부분이 되는 것이다.
-> Annotation 에 관련된 정보가 공식 문서에 들어간다는 얘기로 들린다.

- [ ] Annotate #EnglishWord ➕ 2025-09-22 
      주석을 달다, 해결하다 

(3) 반대로, 어노테이션 B 의 정의가 Documented 어노테이션과 함께 정의되지 않으면,
어노테이션 B 의 값이나 존재 유무는 어노테이션 B 가 annotate 하는 요소의 public contract 의 부분이 되지 않는것

(4) 더 확실히 하자면, 만약 annotation interface 가 Documented 와 함께 정의되면, 
기본적으로 javadoc 같은 도구가 해당 inerface 의 어노테이션을 그 도구의 출력에 보여줄 것이고
그게 아니면 안보여준다.

그러니까 @Documented 와 함께 정의된 annotation interface 는 공식 API 문서의 부분이 된다
-> 공개적으로 보여진다.



### Java Reflection Library

```java
// 1. 기본 진입점
java.lang.Class          // 모든 리플렉션의 시작점

// 2. java.lang.reflect 패키지의 주요 클래스들
java.lang.reflect.Method      // 메서드 정보/실행
java.lang.reflect.Field       // 필드 정보/접근
java.lang.reflect.Constructor // 생성자 정보/실행
java.lang.reflect.Modifier    // 접근제어자 확인
```


클래스가 뭘할 수 있는지 분석할 수 있다면 그것을 `reflective` 하다고 말한다.

`Java Reflection` 을 이용해
1. 런타임에 클래스가 뭘할 수 있는지 파악
2. 객체를 런타임에 면밀히 관찰 (inspect) 할 수 있음
	-> 예를들면, 모든 클래스적용되는 toString method 를 만든다던지
3. Generic array 조작 코드를 구현할 수 있음 (뭔소리야)
4. C++ 에서와 같은 Function Parameter 같이 동작하는 `Method` 객체의 이점을 누릴 수 있다.


#### `Class` class

class 명이 Class 이다. `class` 는 키워드, 여기서 Class 는 클래스명.

프로그램이 실행될 동안 자바 런타임은 모든 객체에 대해 `runtime type idenfication` 이라는 것을 유지한다.
이는 JVM 이 올바른 method 를 선택하는데에 쓰인다.

우리도 `Class` 라는 클래스를 이용해 이 정보에 접근 가능.

```java
Employee e;

(1)
Class cl = e.getClass();

(2)
“String className = "java.util.Scanner";
Class cl = Class.forName(className);”

(3)
Class cl1 = Scanner.class; // if you import java.util.*;
Class cl2 = int.class;
Class cl3 = Double[].class; 
```

클래스의 getName 으로 패키지 + 클래스명 을 String 으로 반환받을 수 있음.

> [!info] 사실 `Class` 클래스는 Generic 클래스이다.
> getName 은 배열에 대해선 이상하게 출력된다. 역사적 이유때문에...

```java
public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE; }

Size.SMALL.getClass() == Size.class // true

-------------------

public enum Size
{
   SMALL,
   MEDIUM,
   LARGE,
   EXTRA_LARGE
   {
      public String toString() { return "XL"; }
   };
}

Size.EXTRA_LARGE.getClass() == Size.class // false
```

2번째 예시는 뭘 의미하는거지 ?


#### Enumeration Class

모든 enum type 은 abstract class `Enum` 의 서브클래스들이다. 
그래서 Enum 에 정의된 메소드들을 사용가능.

그래서 만약에
```java
public enum Size {  
    SMALL ("S"),  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE  
}

public enum Size {  
    SMALL ("S"),  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE;  
  
    private final String sizeName;  
  
    Size(String sizeString) {  
        this.sizeName = sizeString;  
    }  
    Size() {  
        this.sizeName = "None";  
    }  
}
```

이렇게 쓰면 SMALL ("S") 때문에 컴파일이 불가능한데,
SMALL ("S") 라는 것은 기본 컨스트럭터를 사용하지 않고
파라미터가 있는 컨스트럭터를 사용하겠다는 의미이기 때문이다.

여기에는 parameter 가 있는 constructor 가 정의되어 있지 않기때문에 에러 발생.

그래서 아래 것이 허용되고, 이때 parameter 가 없는 constructor 를 지우면 MEDIUM, LARGE, EXTRA_LARGE 에 컴파일 오류가 뜬다.

그래서
```java
public enum Size  
{  
    SMALL,  
    MEDIUM,  
    LARGE,  
    EXTRA_LARGE  
	{  
		public String toString() { return "XL"; }  
	};  
}
```

이것에 대한 의미는, 뭐지? ㅋㅋ

이전 예시의 EXTRA_LARGE 는 Size 의 subclass 의 객체라고 하던데...