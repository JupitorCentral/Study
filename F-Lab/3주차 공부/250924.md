
## 클래스가 ThreadSafe 하다는게 무슨 의미인가 ?

- 구글에 검색해보면...
여러개의 쓰레드들이 구동되는 프로그램들 중에서, 
쓰레드들 사이에서 원하지 않는 동작이 발생하지 않는 것.

thread-safty 한 클래스와 그렇지 않은 클래스를 구분하는 가장 큰 특성
-> correctness. 
#### Correctness 란 무엇인가 ?

클래스가 그에 대한 요구사항 (specification) 을 잘 따르는 것을 말함.
(specification of class - 클래스가 가지고 있는 변수, 클래스가 하는 일. 즉 클래스 자체가 무엇을 위해 존재하고
어떤 동작을 하는지에 대한 정보로 생각할 수 있을듯 하다.)

객체의 상태를 저장하는 변수를 정의하고, 어떤 동작 (method) 에 의해 변하는 상태를 잘 묘사할 수 있는 
specification 이 좋은 specification .

우리가 적절한 클래스의 specification 을 잘 명세, 파악하지 않는데
어떻게 클래스의 correctness 를 논할 수 있을것인지 ?

즉, Thread safe 한 클래스는, 이렇게 정의할 수 있다.
여러개의 쓰레드에 의해 접근이 되어도, 객체의 correctness 를 잘 유지하며 동작하는 객체의 클래스.


##### ThreadSafe 한 클래스의 예시 - A Stateless servlet
-> 상태가 없는 클래스는, Thread-safe 하다.

stateless 한 클래스이다 -> 그 클래스에는 내부에 field가 없고,
다른 클래스의 field 를 reference 하는게 없음을 의미.

즉 서로 다른 쓰레드가 하나의 servlet 에 접근하여 동작할때,
하나의 쓰레드가 동작하는 결과가 다른 어떤 클래스의 상태에도 관여하지 않는다.
왜냐하면 해당 servlet 은 stateless 하기 때문.

	즉 stateless 한 객체는 항상 Thread-Safe gkek.


#### Atomicity

만약 클래스의 field 가 하나라도 생기면 어떻게 될까?

```java
++count;
```
이 단순한 코드 하나는 짧기떄문에 thread-safe 할 것 같지만,
사실 위 코드는 3가지의 동작으로 나누어져 있다.

1. 해당 변수(상태)에 현재 값을 가져온다
2. 가져온 값에 1을 더한다
3. 그리고 해당 변수에 구한 값을 더한다.

즉 여러가지 쓰레드가 해당 동작을 실행하게 될때,
한 쓰레드가 값을 읽어서 원래 변수에 값을 적용하기 전에
다른 쓰레드가 그 사이에 값을 읽어서 그 쓰레드의 임시 공간에서 가져온 값에 1을 더하게 되고,
이러면 count 에 2가 더해져야 하는 상황에 1만 더해지는 상황이 일어날 수 있게 되는것

(register = a , -> register += 1 -> a = register)

#### Race condition

여러 쓰레드가 동일한 상태에 접근하는 경우 
접근 순서에 따라 값이 바뀌는 상황

(위 상황이 race condition 이다)

race condition 에서는 무조건 값이 잘못되게 나오는 것이 아니지만, 
예상하는 동작이 나올지는 unreliable 하다.


#### compound Actions
-> 여러 동작들의 조합


race condition 을 해결하기 위해선, 우리가 어떤 상태를 변경하고 있는 도중에
다른 Thread 가 그 값을 사용하는 것을 막아서  ,다른 쓰레드가 
오직 우리가 수정하기 전이나 - 수정한 후에 상태를 보게끔을 확실하게 할 방법이 필요하다.
-> Memory visibility. 
한 쓰레드가 변경한 값을 다른 쓰레드가 볼 수 있는 특성.

만약 A와 B가 "with respect to each other" atomic하다면:
- Thread 1은 B operation을 **완전히 끝나거나 아예 시작하지 않은** 상태로만 본다
- Thread 2는 A operation을 **완전히 끝나거나 아예 시작하지 않은** 상태로만 본다

즉 중간상태가 서로에게 노출되지 않는다.
서로의 실행과정에 간섭하지 않는다.

all or nothing.

```java
Thread 1: temp1 = count (0)    // 읽기
Thread 2: temp2 = count (0)    // 같은 값을 읽음!
Thread 1: temp1 = temp1 + 1 (1)
Thread 2: temp2 = temp2 + 1 (1)
Thread 1: count = temp1 (1)    // 쓰기
Thread 2: count = temp2 (1)    // 덮어씀!
```

즉 위 상황은 thread 2 가 thread 1 가 수정하고 있는 중간상태를 바라보게 되는 것이다.

그래서 thread 2 의 관점에서 thread 1 이 완전히 실행하고 있지 않는다고 간주할경우
thread 2 가 실행이 되고, thread 1 이 그 다음에 실행될때, thread 2 가 시작했으므로
무조건 다 완료가 되었다는 가정하에 해당 동작을 해야 한다는 것이다.


```java
// 가능한 실행 순서 1:
Thread 1: count++ 완전히 실행 (0→1)
Thread 2: count++ 완전히 실행 (1→2)

// 가능한 실행 순서 2:
Thread 2: count++ 완전히 실행 (0→1)  
Thread 1: count++ 완전히 실행 (1→2)

```

-> 나중에 Java Concurrency in Practice - 2.1 Locking 을 이어서 보자.


#### Java 에서의 예시


##### StringBuilder, StringBuffer


```java
class TestThread extends Thread {  
    private Object buffer;  
    private String word;  
      
    public TestThread(Object buffer, String word) {  
        this.buffer = buffer;  
        this.word = word;  
    }  
      
    @Override  
    public void run() {  
        for (int i = 0; i < 100; i++) {  
            if (buffer instanceof StringBuilder) {  
                ((StringBuilder) buffer).append(word);  
            } else if (buffer instanceof StringBuffer) {  
                ((StringBuffer) buffer).append(word);  
            }  
        }  
    }  
}  
  
public class Solution {  
    public static void main(String[] args) throws Exception {  
        System.out.println("StringBuilder:");  
        for (int round = 1; round <= 2; round++) {  
            StringBuilder sb = new StringBuilder();  
              
            Thread t1 = new TestThread(sb, "A");  
            Thread t2 = new TestThread(sb, "B");    
            Thread t3 = new TestThread(sb, "C");  
              
            t1.start();  
            t2.start();  
            t3.start();  
              
            t1.join();  
            t2.join();  
            t3.join();  
              
            System.out.println(sb.toString());  
        }  
          
        System.out.println("StringBuffer:");  
        for (int round = 1; round <= 2; round++) {  
            StringBuffer sb = new StringBuffer();  
              
            Thread t1 = new TestThread(sb, "A");  
            Thread t2 = new TestThread(sb, "B");    
            Thread t3 = new TestThread(sb, "C");  
              
            t1.start();  
            t2.start();  
            t3.start();  
              
            t1.join();  
            t2.join();  
            t3.join();  
              
            System.out.println(sb.toString());  
        }  
    }  
}
```

```java
java ./Solution.java

StringBuilder:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCBBBBCCBCBBBCCBCBBBCBBCBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

StringBuffer:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
```
