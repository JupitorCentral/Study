---
tags:
  - kafka
  - concurrency
  - spring
  - thread
--- 

### 제 프로젝트에서 Kafka의 역할은 무엇인가요?

Apache Kafka는 분산 이벤트 스트리밍 플랫폼으로, 서로 다른 애플리케이션 간에 비동기적으로 메시지를 주고받을 수 있게 해주는 메시지 브로커 역할을 합니다. 대용량 실시간 데이터 처리에 최적화되어 있으며, 시스템 간의 결합도를 낮추는 데 탁월합니다.

BankForge 뱅킹 시스템에서 Kafka는 마이크로서비스 간의 **실시간 이벤트 기반 통신의 중추(Backbone)** 역할을 담당합니다.

#### 핵심 기능 (Core Functions)

- **이벤트 기반 통신:** `account-command-service`와 `account-query-service` 같은 8개의 분리된 모듈 간의 비동기 통신을 가능하게 하여, 각 서비스가 독립적으로 동작할 수 있게 합니다.
    
- **메시지 스트리밍 및 처리:** Event Store 서비스에서 발생하는 모든 뱅킹 이벤트(트랜잭션, 계좌 업데이트 등)를 안정적으로 전달하고 처리합니다.
    

#### 아키텍처와의 통합

- **CQRS 패턴 지원:** 쓰기(Command) 측과 읽기(Query) 측을 연결합니다. 명령 서비스가 이벤트를 생성하면 Kafka가 이를 조회 서비스로 스트리밍하여 읽기 모델을 업데이트합니다.
    
- **실시간 기능:** WebSocket을 통한 실시간 잔액 업데이트, 거래 상태 변경 알림 등을 가능하게 합니다.
    
- **멀티 데이터베이스 조율:** PostgreSQL, Redis, MongoDB 간의 데이터 흐름을 관리하고 결과적 일관성(Eventual Consistency)을 보장합니다.
    

#### 구체적인 뱅킹 사용 사례

- **트랜잭션 처리:** 사기 탐지(Fraud detection) 및 즉각적인 처리를 위해 거래 이벤트를 스트리밍합니다.
    
- **계좌 업데이트:** 계좌 잔액 변경 사항을 모든 관련 서비스에 방송(Broadcast)합니다.
    
- **알림 시스템:** SMS, 이메일, 실시간 알림 전송을 트리거합니다.
    
- **감사 추적(Audit Trail):** 모든 뱅킹 이벤트를 로그로 남기고 모니터링 시스템으로 전달합니다.
    

---

### Spring 프로젝트는 독립적인 애플리케이션인데, 어떻게 Kafka 같은 외부 프로그램과 통신하나요?

맞습니다. Kafka는 Spring Boot 애플리케이션 외부에서 독립적으로 실행되는 프로그램입니다. 통합은 Spring Boot 서비스가 **Kafka 클라이언트**로서 네트워크를 통해 외부 Kafka 인스턴스에 접속함으로써 이루어집니다.

#### 연결 모델 (The Connection Model)

Spring Boot 안에 Kafka가 포함된 것이 아닙니다. 대신 **Spring Kafka 라이브러리**를 사용하여 연결합니다.

- **Kafka 클러스터:** 별도의 서버나 컨테이너에서 실행됩니다.
    
- **Spring Boot 서비스:** 각 서비스는 Spring Kafka 라이브러리를 포함하며, 이를 통해 Kafka 클러스터에 클라이언트(Producer 또는 Consumer)로 접속합니다.
    
- **통신:** 네트워크 연결(TCP)을 통해 메시지를 주고받습니다.
    

설정은 `application.properties`에서 이루어집니다:

```properties
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=transaction-service-group
```

코드는 어노테이션과 템플릿을 사용합니다:

- `@KafkaListener`: 메시지를 수신(Consume)할 때 사용.
- `KafkaTemplate`: 메시지를 전송(Produce)할 때 사용.

---

### 사용자 요청이 들어왔을 때, Tomcat 스레드에서 Kafka 통신까지의 스레드 흐름은 어떻게 되나요?

HTTP 요청부터 Kafka 상호작용까지의 스레드 수명 주기를 따라가 봅시다.

#### 1. 요청 도착 (Tomcat Thread Pool)
사용자 요청이 오면 Tomcat 스레드 풀에서 하나의 **HTTP 스레드**가 할당되어 초기 처리를 담당합니다.

#### 2. Spring Boot 처리 (동일 스레드)
**같은 HTTP 스레드**가 Controller -> Service -> Repository 계층을 실행합니다.

#### 3. Event Store 상호작용 (여전히 동일 스레드)
HTTP 스레드는 비즈니스 로직을 수행하고 DB(Event Store)에 저장하는 동기 호출을 합니다. DB 작업이 끝날 때까지 스레드는 **블로킹(대기)**됩니다.

#### 4. Kafka 통신 (스레드 동작이 갈림)
DB 저장 후, 같은 HTTP 스레드가 Kafka 통신을 시작합니다. 여기서 구현 방식에 따라 나뉩니다.

- **방식 A: 동기 Kafka (스레드 블로킹)**
    HTTP 스레드가 메시지를 보내고 Kafka 브로커의 확인(ACK)을 받을 때까지 **기다립니다**.
    ```java
    // .get() 때문에 HTTP 스레드가 블로킹됨
    kafkaTemplate.send("transaction-events", event).get();
    ```
    
- **방식 B: 비동기 Kafka (스레드 핸드오프)**
    HTTP 스레드는 메시지를 프로듀서 내부 버퍼에 넣고 **즉시 리턴**합니다. 실제 네트워크 전송은 별도의 백그라운드 스레드가 처리합니다.
    ```java
    // HTTP 스레드는 기다리지 않고 즉시 다음 코드 실행
    kafkaTemplate.send("transaction-events", event);
    ```

뱅킹 시스템에서는 중요 트랜잭션의 경우 일관성을 위해 동기 방식을, 알림 같은 비핵심 작업은 성능을 위해 비동기 방식을 주로 사용합니다.

---

### 2단계(Kafka 통신)의 상세 흐름을 더 자세히 설명해 주세요.

#### 경로 A: 동기 Kafka 통신 (HTTP 스레드 대기)
안정성을 최우선으로 하는 방식입니다.

1.  **시작:** HTTP 스레드가 DB 저장을 마치고 `send().get()`을 호출합니다.
2.  **블로킹:** `.get()`으로 인해 HTTP 스레드는 멈춥니다.
3.  **내부 동작:**
    - 이벤트 객체 직렬화 (Byte 변환).
    - 파티셔너가 파티션 결정.
    - 메시지가 내부 버퍼(RecordAccumulator)에 담김.
    - **Sender 스레드(백그라운드 I/O 스레드)**가 버퍼에서 메시지를 가져와 네트워크로 전송.
4.  **확인 및 해제:**
    - Sender 스레드가 브로커로부터 ACK 수신.
    - `future.get()`이 완료됨.
    - **HTTP 스레드 블로킹 해제** 후 사용자에게 응답 반환.

#### 경로 B: 비동기 Kafka 통신 (HTTP 스레드 핸드오프)
빠른 응답 속도를 최우선으로 하는 방식입니다.

1.  **시작:** HTTP 스레드가 `send()` 호출 ( `.get()` 없음).
2.  **큐잉:** 메시지가 직렬화되어 버퍼에 담김.
3.  **즉시 리턴:** `send()` 메서드가 **즉시 종료**됩니다. HTTP 스레드는 사용자에게 응답을 보내고 Tomcat 풀로 돌아가 다른 요청을 처리할 준비를 합니다.
4.  **백그라운드 처리 (병렬):**
    - 별도로 동작하는 **Kafka Producer I/O 스레드**가 독립적으로 버퍼의 메시지를 가져와 브로커로 전송하고 ACK를 처리합니다.

---

### 그럼 HTTP 스레드가 실행 중에 Kafka와 통신한다는 건가요?

네, HTTP 스레드가 Kafka 통신을 **시작(Initiate)**합니다. 하지만 통신이 끝날 때까지 **기다리는지 여부**가 다릅니다.

- **동기:** HTTP 스레드가 직접 통신 결과를 기다립니다.
- **비동기:** HTTP 스레드는 "전송 부탁해"라고 버퍼에 넘기고(Handoff) **즉시 떠납니다**. 실제 전송은 백그라운드 스레드가 합니다.

어느 경우든 시작은 항상 HTTP 스레드가 `kafkaTemplate.send()`를 호출함으로써 이루어집니다.

---

### Kafka가 로드 밸런서처럼 서버 성능을 최적화하기 위해 스레드를 제어하는 건가요?

비슷한 느낌을 받으셨겠지만, 메커니즘이 다릅니다. Kafka는 **스레드 관리**를 통해 성능을 최적화하지만, 로드 밸런서는 아닙니다.

**Kafka의 스레드 관리 역할**
Kafka는 **애플리케이션 스레드를 느린 네트워크 I/O로부터 분리**함으로써 성능을 최적화합니다.
- **비동기 처리:** HTTP 스레드가 네트워크 응답을 기다리느라 낭비되는 시간을 없애줍니다. HTTP 스레드는 빠르게 요청을 처리하고 풀로 돌아갈 수 있습니다.
- **내부 스레드 풀:** Kafka 프로듀서는 자체적으로 최적화된 백그라운드 I/O 스레드를 가지고 있어 네트워크 통신을 전담합니다.

**Kafka vs Load Balancer**
- **Kafka:** **단일 서버 내의 스레드** 간 작업 분배를 최적화 (내부 교통 정리).
- **Load Balancer:** **여러 서버 간**의 트래픽 분산 (외부 교통 정리).

---

### 헷갈려요. HTTP 스레드가 Kafka, 다른 모듈, DB와 동시에 통신하나요?

아니요, 그렇지 않습니다. 하나의 HTTP 스레드는 작업을 **순차적(Sequentially)**으로 하나씩 처리합니다. 동시에(Parallel) 하지 않습니다.

**HTTP 스레드의 타임라인:**
1.  DB와 통신 (완료될 때까지 대기)
2.  Kafka와 통신 (동기면 대기, 비동기면 넘기고 진행)
3.  응답 반환

"다른 모듈"과의 통신도 구분해야 합니다:
1.  **같은 마이크로서비스 내 (동기):** HTTP 스레드가 `ValidationService` 등을 직접 호출. 순차적으로 실행됨.
2.  **다른 마이크로서비스 간 (비동기):** HTTP 스레드는 Kafka에 이벤트를 던지고 끝납니다. 이벤트를 받아 처리하는 건 **완전히 다른 서비스의, 다른 스레드**가 나중에 수행합니다.

즉, 시스템 전체로 보면 병렬 처리가 일어나지만(여러 서비스가 동시에 도니까), **하나의 HTTP 스레드 관점에서는 순차적**으로 일어납니다.

---

### 요약 (Summary)

**아키텍처 내 Kafka의 핵심 역할**
- **비동기 메시징 백본:** 서비스 간의 실시간 데이터 흐름을 담당합니다.
- **마이크로서비스 분리:** 서비스들이 서로 직접 연결되지 않게 해줍니다.
- **CQRS 지원:** 쓰기 모델과 읽기 모델 사이의 다리 역할을 합니다.

**HTTP 스레드 실행 흐름**
- **순차적 실행:** HTTP 스레드는 DB 작업 -> Kafka 전송 -> 응답 반환 순서로 작업을 하나씩 처리합니다. 멀티태스킹 하지 않습니다.

**동기 vs 비동기 통신**
- **동기 (`.get()`):** HTTP 스레드가 Kafka 전송 완료를 기다립니다. **데이터 안전성**이 중요한 금융 트랜잭션에 사용합니다.
- **비동기 (Default):** HTTP 스레드는 메시지만 맡기고 즉시 다음 작업을 합니다. 실제 전송은 백그라운드 스레드가 합니다. **성능**이 중요한 알림 등에 사용합니다.

**성능 최적화**
- Kafka는 로드 밸런서가 아니지만, **느린 네트워크 I/O 작업을 백그라운드 스레드로 넘겨줌으로써** 메인 HTTP 스레드가 더 많은 요청을 빠르게 처리할 수 있게 도와줍니다. (내부 스레드 효율화)