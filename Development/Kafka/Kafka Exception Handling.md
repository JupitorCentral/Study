---
tags:
  - kafka
  - transaction
  - exception-handling
---

### 트랜잭션 메서드가 예외를 던지면 Kafka 전송은 어떻게 되나요? 동기 vs 비동기 전송 중 무엇을 써야 할까요?

Spring의 `@Transactional` 어노테이션이 붙은 메서드에서 예외가 발생하면, 트랜잭션 인터셉터에 의해 **Kafka 트랜잭션도 자동으로 롤백**됩니다. 즉, 비즈니스 로직이 실패하면 해당 Kafka 메시지는 커밋되지 않으며, `read_committed` 격리 수준으로 설정된 컨슈머에게는 보이지 않게 됩니다.

#### 트랜잭션 내에서의 Kafka 전송 동작

트랜잭션 안에서의 Kafka 전송은 순수하게 비동기적이지 않습니다. 메시지는 브로커로 즉시 전송되지만 **'미확정(Uncommitted)'** 상태로 표시됩니다. 트랜잭션이 성공적으로 완료(Commit)되어야만 컨슈머가 이 메시지를 읽을 수 있습니다. 만약 트랜잭션이 실패하면 이 메시지들은 중단(Aborted) 처리됩니다.

#### 동기(Sync) vs 비동기(Async) Kafka 전송

프로듀서가 전송 작업을 처리하는 방식은 두 가지가 있습니다.

- **비동기 (Default):**
    - `producer.send()`를 호출하고 콜백(Callback)을 사용합니다.
    - 메시지를 배치(Batch)로 모아 보내므로 처리량(Throughput)이 높습니다.
    - 메시지가 전송되고 확인되기 전에 애플리케이션이 종료되면 데이터 손실 위험이 있습니다.
- **동기 (Synchronous):**
    - `producer.send()`가 반환하는 `Future` 객체의 `.get()`을 호출합니다. 브로커가 전송 완료 및 확인(ACK)을 줄 때까지 스레드가 블로킹(대기)됩니다.
    - 다음 단계로 넘어가기 전에 메시지가 확실히 저장되었음을 보장합니다.
    - 처리량은 낮아지지만 신뢰성은 높아집니다.

#### 뱅킹 시스템을 위한 권장 접근 방식

귀하의 프로젝트와 같은 중요한 뱅킹 시스템에서는 다음을 권장합니다:

- **핵심 트랜잭션 데이터에는 동기 전송 사용:** `producer.send().get()`을 호출하여 확실한 저장을 보장하세요.
- **견고한 예외 처리:** 네트워크 문제 같은 일시적 장애에 대해 재시도(Retry) 로직을 구현하세요.
- **Dead-Letter Topic 설정:** 반복적으로 실패하는 메시지를 별도로 격리하여 처리하세요.
- **`acks=all` 설정:** 메시지가 모든 복제본(Replica)에 저장된 후에만 성공으로 간주하도록 설정하세요.

#### 예외 처리 전략

예외 유형에 따라 재시도 여부를 결정하세요:

- **재시도 가능 (Retryable):** 네트워크 타임아웃, 일시적인 브로커 사용 불가.
- **재시도 불가능 (Non-retryable):** 직렬화 오류, 인증 실패.
- Spring의 `DefaultAfterRollbackProcessor`를 사용하여 롤백 후 커스텀 처리 로직을 정의할 수 있습니다.

---

### 만약 애플리케이션 로직은 성공했는데, 비동기 Kafka 전송 후 데이터베이스에서 실패가 발생하면 어떻게 되나요?

비동기 Kafka 전송을 사용한 뒤 데이터베이스 트랜잭션이 실패하면 **데이터 불일치** 문제가 발생합니다.

#### 비동기 Kafka + DB 실패 시나리오

1.  Kafka 메시지는 비동기(Non-blocking)로 전송되어 브로커에 도착(혹은 성공)할 수 있습니다.
2.  그 직후 데이터베이스 트랜잭션이 실패하여 롤백됩니다.
3.  **결과:** Kafka에는 "이체 완료" 메시지가 있는데, 데이터베이스에는 해당 이체 내역이 없는 심각한 불일치가 발생합니다.

#### Kotlin 뱅킹 시스템을 위한 해결책

1.  **동기 Kafka 전송 (Synchronous Sends)**
    DB 커밋을 시도하기 *전에* Kafka 전송 확인(ACK)을 기다립니다. Kafka에 확실히 저장된 후에만 DB 상태를 변경합니다.
    ```kotlin
    // DB 커밋 전 Kafka 확인 대기
    val future = producer.send(record)
    future.get() // Kafka가 확인할 때까지 블로킹
    
    // 그 후 DB 작업 진행
    ```

2.  **Transactional Outbox 패턴**
    DB 쓰기와 메시지 발행을 원자적(Atomic)으로 처리합니다.
    - 하나의 DB 트랜잭션 안에서 비즈니스 데이터(계좌 업데이트)와 Kafka 메시지(Outbox 테이블)를 같이 저장합니다.
    - 별도의 폴러(Poller) 프로세스가 Outbox 테이블을 읽어 Kafka로 전송합니다.

3.  **Saga 패턴**
    보상 트랜잭션을 사용합니다. Kafka 메시지 전송 후 DB가 실패하면, "취소 메시지"를 다시 Kafka로 보내 이전 작업을 되돌립니다.

---

### 제 뱅킹 프로젝트에서 비동기 Kafka 호출이 적합한 사용 사례가 있나요?

네, 핵심 로직에는 동기 전송이 필수적이지만, 비동기 호출이 유용한 곳도 있습니다.

#### 권장 전략: 핵심은 동기, 나머지는 비동기

- **데이터 일관성**과 **규정 준수(감사)**가 필요한 모든 **핵심 뱅킹 업무(이체, 입금, 출금)**에는 **동기 전송**을 기본으로 사용하세요.

#### 비동기 Kafka 사용이 적합한 경우 (높은 처리량, 결과적 일관성 허용)

- **비핵심 이벤트:**
    - 사용자 로그인/로그아웃 이력.
    - 애플리케이션 성능 지표 및 메트릭 수집.
    - 시스템 헬스 체크 핑.
- **대량의 비트랜잭션 데이터:**
    - 사용자 행동 분석 (클릭, 페이지 조회).
    - 실시간 마케팅 데이터 스트림.
- **백그라운드 작업 트리거:**
    - 리포트 생성 요청.
    - 배치 작업 완료 알림.
    - 캐시 무효화 이벤트 전파.

---

### 요약 (Summary)

**핵심 트랜잭션 동작**
- `@Transactional` 메서드가 실패하면 연결된 Kafka 트랜잭션도 롤백되어, 커밋되지 않은 메시지가 노출되는 것을 막습니다.

**동기 vs 비동기 전송**
- **동기:** `Future.get()`으로 브로커의 확인을 기다립니다. 처리량은 낮지만 **신뢰성이 필수적인 뱅킹 데이터**에 적합합니다.
- **비동기:** 기본값입니다. 빠르지만, DB 롤백 시 데이터 불일치 위험이 있습니다.

**분산 상태 처리 (DB + Kafka)**
- **문제:** 비동기 전송 후 DB가 실패하면 Kafka에만 데이터가 남습니다.
- **해결:**
    - **동기 전송:** DB 커밋 전 Kafka 저장을 보장합니다.
    - **Outbox 패턴:** DB에 메시지를 같이 저장하고 별도 프로세스가 전송합니다.
    - **Saga 패턴:** 보상 트랜잭션으로 되돌립니다.

**뱅킹 시스템 권장 전략**
- **핵심 업무(이체 등):** 무조건 **동기 전송**으로 데이터 무결성 보장.
- **부가 업무(로그, 분석):** **비동기 전송**으로 성능 확보.

**주요 설정**
- **`acks=all`:** 데이터 유실 방지를 위한 필수 설정.
- **Dead Letter Queue (DLQ):** 실패 메시지 격리.
- **멱등성 컨슈머:** 중복 메시지 안전 처리.