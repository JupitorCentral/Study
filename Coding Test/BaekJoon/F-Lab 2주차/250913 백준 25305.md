Quick sort 하다가 망해버렸다. 한 두시간은 디버깅하면서 끙끙댄듯.

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.security.Key;
import java.util.Random;
import java.util.StringTokenizer;

public class Main {

    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static StringBuilder sb;
    static int answer;
    static int[] arr;
    static int n;
    static int k;

    public static void main(String[] args) throws Exception {

        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        sb = new StringBuilder();
        // st = new StringTokenizer(br.readLine());

        // n = Integer.parseInt(st.nextToken());
        // k = Integer.parseInt(st.nextToken());
        // k = n - k;
        Random random = new Random();
        n = 10;
        k = random.nextInt(n-1) + 1;
        k = n - k;

        // st = new StringTokenizer(br.readLine());
        arr = new int[n];
        for (int i=0; i<n; i++) {
            // arr[i] = Integer.parseInt(st.nextToken());
            arr[i] = random.nextInt(99) + 1;
        }

        System.out.println("k : " + k);
        answer = findK(0, arr.length-1);

        sb.append(answer);
        bw.write(sb.toString());
        bw.close();
    }

    static int findK (int left, int right) {

        while(left <= right) {
            System.out.println();
            System.out.println("left and right : " + left + ", " + right);
            int mid = (left + right) /2;


            int pivot = arr[mid];
            arr[mid] = arr[right];
            arr[right] = pivot;
            System.out.println("mid : " + mid + " pivot : " + pivot);

            // mid = pivot
            int i = left;
            int j = mid;
            while (i < j) {
                while(arr[i] < pivot && i < right) i++;
                while(arr[j] > pivot && j > left) j--;
                if (i < j) {
                    System.out.println(i + ", " + j);
                    int t = arr[i];
                    arr[i] = arr[j];
                    arr[j] = t;
                    i++;
                    j--;
                }
            }

            if (arr[i] > pivot) {
                arr[right] = arr[i];
                arr[i] = pivot;
            } else if ( arr[i] < pivot && i < right) {
                arr[right] = arr[i+1];
                arr[i+1] = pivot;
            }
            for (int x : arr) {
                System.out.print(x + " ");
            }
            System.out.println();
            System.out.println("i : " + i);

            if (i == k) return arr[i];
            else if (k > i) { left = i+1; }
            else { right = i-1; }
        }

        return -1;
    }

}

```

bubble sort 로 하면 간단하겠지만, pivot sort 가 좋으니
처음부터 quick sort 를 먼저 깔끔하게 구현하고 나서 문제에 해당하는 부분을 바꾸는게 좋았을텐데.
같이 해버리니까 폭삭 망한 것 같다.

quick sort 를 대략적으로는 알고 있는데, 오랜만에 보니 또 까먹은듯.
근데 이렇게 자꾸 까먹으면, 나중에 어떻게 코딩테스트를 붙나... 걱정이다.
내일 다시 보자. 

아니 포기할 수 없었다. 산책한번 땡긴 뒤에 
다시 디버깅 해봤는데....

이게 보니까, pivot 의 위치가 구하고자 하는 순위를 건너뛰어버릴 수 있다는 사실을 알게되었다.
pivot의 위치는 시시각각 변한다.

예를들어, n = 10, k = 4 라고 하면, 정렬된 배열을 생각하면 구하고자 하는 index 는 (n-1) - (k-1) = 6 이다.
그럼, pivot 이 만약 4 -> 9 -> 7 ->  5 이렇게 움직여 버리면, 5 일때 이미 right 은 6 이 되고, 다음 메서드에서는 left : 6, right : 6 이 되어서 
안에 실행이 안되게 된다. 

그럼 만약에 while 문 밖에 i == j == target 일때 수를 리턴하면 되지 않나 ? 생각할 수 있는데

4 -> 9 -> 7 -> 5 보다 더 크리티컬 한 순서가 있었고, 그걸 intelliJ 에서 디버깅하면서 발견했는데
그 순서가 기억이 나질 않는다.

암튼 그냥 quickSort 해버린다음에 arr\[target] 해서 구해버렸다.

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class Main {

    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static StringBuilder sb;
    static int answer;
    static int[] arr;
    static int n;
    static int k;
    static int target;

    public static void main(String[] args) throws Exception {

        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        sb = new StringBuilder();
        st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());
        target = (n-1) - (k-1);

        arr = new int[n];

        st = new StringTokenizer(br.readLine());
        for (int i=0; i<n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        quickSort (0, n-1);

        sb.append(arr[target]);
        bw.write(sb.toString());
        bw.close();
    }

    public static void quickSort (int left, int right) {
        while (left < right) {
            int mid = (left + right) / 2;
            int pivot = arr[mid];
            int i = left;
            int j = right-1;

            swap(mid, right);
            while (i < j) {
                while(arr[i] <= pivot && i <= right-2) i++;
                while(arr[j] > pivot && j >= left+1) j--;

                if (i < j) {
                    swap(i, j);
                    i++;
                    j--;
                }
            }
            if (arr[i] > pivot) {
                swap(i, right);
            } else {
                swap(++i, right);
            }
            // i -> position of pivot
            quickSort(left, i-1);
            quickSort(i+1, right);
            return;
        }
    }

    public static void swap (int i, int j) {
        int t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}

```

덕분에 quickSort 에 대해서 좀 더 알게된 계기가 아닐지...

